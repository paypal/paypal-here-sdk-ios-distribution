//
// Copyright (c) 2016, PayPal, Inc.
// All rights reserved.
//
// This source code is licensed under the modified BSD-style license found in the
// LICENSE file in the root directory of this source tree.  Please note that if you
// modify the source code and redistribute these modifications for commercial purposes,
// you agree and understand you may need to certify or comply with any relevant
// certification or compliance entities to process payments.
//

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/CachedServerFile.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var manticore = require('manticore'),
    RetailSDKUtil = require('../common/RetailSDKUtil'),
    Log = require('manticore-log')('cachedServerFile');

/**
 * The ServerBackedFile class is responsible to retrieve and cache a server backed file
 */

var CachedServerFile = function () {

    /**
     * @param fileId    - Unique Id to the file
     * @param remoteUrl - Server URL for the file
     */
    function CachedServerFile(fileId, remoteUrl) {
        _classCallCheck(this, CachedServerFile);

        this.url = remoteUrl;
        this.fileId = fileId;
        this.storageType = RetailSDKUtil.StorageType.Secure;
    }

    /**
     * Looks for a JSON file from local cache store, server and returns the most recent version
     * @param callback  -   Callback will be invoked with the error (if any) and http response as first and second parameters
     */


    CachedServerFile.prototype.get = function get(callback) {
        var _this = this;

        this._retrieveCachedFile(function (e, cachedJson) {
            var request = { url: _this.url, format: 'json', headers: {} };
            if (cachedJson && cachedJson.headers) {
                var lm = cachedJson.headers['Last-Modified'],
                    eTag = cachedJson.headers.ETag;

                if (lm) {
                    request.headers['If-Modified-Since'] = lm;
                }

                if (eTag) {
                    request.headers['If-None-Match'] = eTag;
                }
            }

            Log.debug(function () {
                return 'GET File ' + _this.fileId + '\nRequest: ' + JSON.stringify(request);
            });
            manticore.http(request, function (err, response) {
                if (err || response && response.statusCode >= 300) {
                    Log[response && response.statusCode === 304 ? 'debug' : 'error'](function () {
                        return 'Remote file load did not return new file. statusCode: ' + response.statusCode + ', ' + (err ? err.message : 'undefined');
                    });
                    callback(null, cachedJson ? cachedJson.body : null);
                } else if (response.body) {
                    manticore.setItem(_this.fileId, _this.storageType, JSON.stringify(response), function (err) {
                        Log.debug(function () {
                            return 'Using server version of ' + _this.fileId;
                        });
                        callback(null, response.body);
                    });
                } else {
                    Log.debug(function () {
                        return 'Using CACHED version of ' + _this.fileId;
                    });
                    callback(null, cachedJson ? cachedJson.body : null);
                }
            });
        });
    };

    CachedServerFile.prototype._retrieveCachedFile = function _retrieveCachedFile(callback) {
        var _this2 = this;

        manticore.getItem(this.fileId, this.storageType, function (e, cachedData) {
            if (e) {
                Log.warn('Failed to get cached file with Id ' + _this2.fileId + ' from storage Type: \'' + _this2.storageType + '\'. Error: ' + e);
                callback(e, null);
            }

            try {
                callback(null, cachedData ? JSON.parse(cachedData) : null);
            } catch (e) {
                Log.warn('Unable to parse cached file ' + cachedData + ' to json. Error : ' + e);
                callback(e, null);
            }
        });
    };

    return CachedServerFile;
}();

module.exports = CachedServerFile;

},{"../common/RetailSDKUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/RetailSDKUtil.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Features.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FeatureMapJson = require('../../resources/feature-map.json'),
    Log = require('manticore-log')('features'),
    CachedServerFile = require('./CachedServerFile');

var Features = function () {
    function Features() {
        _classCallCheck(this, Features);

        this.map = FeatureMapJson;
    }

    /**
     * Loads the remote feature map
     */


    Features.prototype.loadRemoteFeatureMap = function loadRemoteFeatureMap() {
        var _this = this;

        var url = 'https://www.paypalobjects.com/webstatic/mobile/retail-sdk/feature-map.json',
            file = new CachedServerFile(Features.FileId, url);

        file.get(function (err, remoteMap) {
            if (err || !remoteMap) {
                Log.error('Could not retrieve remote feature. Error: ' + err);
                return;
            }

            Log.info('Version of local feature map: ' + _this.map.VERSION + ' remote/cached: ' + remoteMap.VERSION);
            if (parseFloat(_this.map.VERSION) < parseFloat(remoteMap.VERSION)) {
                Log.debug('Replacing local feature map with remote');
                _this.map = remoteMap;
            }

            //Log.debug(() => `SDK will use feature map : ${JSON.stringify(this.map, null, 2)}`);
        });
    };

    return Features;
}();

Features.FileId = 'FeatureMapStoreKey';

module.exports = new Features();

},{"../../resources/feature-map.json":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/resources/feature-map.json","./CachedServerFile":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/CachedServerFile.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Merchant.js":[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sdkErrors = require('./sdkErrors');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var manticore = require('manticore'),
    Log = require('manticore-log')('merchant'),
    RestApi = require('paypalrest-manticore').default,
    Invoice = require('paypal-invoicing').Invoice,
    InvoiceAddress = require('paypal-invoicing').InvoiceAddress,
    EventEmitter = require('events').EventEmitter,
    SdkFeature = require('./Features'),
    async = require('async'),
    BN = require('bignumber.js'),
    $$ = function $$(a) {
    return a === undefined || a === null ? null : new BN(a);
};

/**
 * The merchant represents the account that all calls to the PayPal services will affect. Essentially this is
 * where all collected money will go, which account locations and checkin operations will occur under, etc.
 * @class
 * @property {string} emailAddress The email address of the merchant. @readonly
 * @property {string} businessName The name of the business operated by the merchant. @readonly
 * @property {string} currency The "home" currency of the merchant. @readonly
 * @property {InvoiceAddress} address The business address of the merchant @readonly
 * @property {string} environment The PayPal environment this merchant exists in - live or sandbox. Sandbox means the money is not real!
 * @property {decimal} signatureRequiredAbove The invoice total amount above which signature would be collected for swipe transactions.
 * @property {bool} isCertificationMode Run in certification mode.
 * PLEASE NOTE: manipulating this setting (especially upwards) may cause you to be liable for chargebacks in the event we cannot retrieve
 * a signature for the transaction. MODIFY THIS SETTING AT YOUR OWN RISK!
 */

var Merchant = function (_EventEmitter) {
    _inherits(Merchant, _EventEmitter);

    /**
     * Only JS will make Merchants.
     * @private
     */
    function Merchant() {
        _classCallCheck(this, Merchant);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        _this.api = null;
        _this.userInfo = {};
        _this.status = {};
        _this.cbs = [];
        _this.environment = 'live';
        return _this;
    }

    Merchant.prototype.initialize = function initialize(token, callback) {
        var _this2 = this;

        // TODO this means "last attempt wins" on merchant init. Probably ok, but make sure to rationalize
        // with any multi-merchant behavior we might introduce.
        require('paypal-invoicing').InvoicingRequester.api = this.api = RestApi.fromToken(token);
        this.environment = this.api.env;
        this.api.addResolver('retail', resolver);
        this.api.addResolver('auth', resolver);
        this.api.addResolver('invoicing', makeInvoiceResolver(this.api));
        this.api.addResolver('payments', resolver);

        // This is a "non-server SDK" generally, so warn if they have app info
        if (this.api.app) {
            Log.warn('Using debug-only SDK token with embedded app secret. DO NOT USE IN LIVE APPS.');
        }

        async.parallel([this._loadMerchantUserInfo.bind(this), this._loadMerchantStatus.bind(this)], function (err) {
            Merchant.active = _this2;
            Merchant.events.emit('initialized', err);
            if (err) {
                Log.error('Merchant initialize failed: ' + err);
            }
            callback(err, _this2);
        });

        return true;
    };

    Merchant.prototype._loadMerchantUserInfo = function _loadMerchantUserInfo(cb) {
        var _this3 = this;

        Log.debug('Loading merchant user info...');
        this.api.request({
            service: 'auth',
            op: 'userinfo?schema=openid',
            format: 'json'
        }, function (err, userInfo) {
            if (err && err.code === 400 && !_this3._retriedUserInfo) {
                // Bug PPPLPAYPT-2414 still not fixed...
                _this3._retriedUserInfo = true;
                return _this3.api.refresh(function (refreshError) {
                    if (refreshError) {
                        return cb(refreshError, _this3);
                    }
                    _this3._loadMerchantUserInfo(cb);
                });
            }
            // Shouldn't really be possible to come through here again, but just for correctness...
            delete _this3._retriedUserInfo;
            _this3.userInfo = userInfo ? userInfo.body : null;
            if (err) {
                return cb(err, _this3);
            }
            if (!_this3.userInfo) {
                Log.error('Failed to load merchant information. Empty response.');
                return cb((0, _sdkErrors.getError)(new Error(), _sdkErrors.merchant.failedToLoad), null);
            }

            if (!_this3.userInfo.address || !_this3.userInfo.address.country || !_this3.userInfo.email || !_this3.userInfo.name) {
                Log.error('Failed to load required merchant information like address, country code, email or name. May be the scope used to generate token was not right?');
                return cb((0, _sdkErrors.getError)(new Error(), _sdkErrors.merchant.requiredInfoNotLoaded), null);
            }

            Invoice.DefaultMerchant = {
                emailAddress: _this3.emailAddress,
                businessName: _this3.businessName,
                address: _this3.address
            };

            Log.info('Successfully loaded merchant user info!');
            Log.debug(function () {
                return 'Merchant Info: \n' + JSON.stringify(userInfo.body, null, 4);
            });
            Log.debug(function () {
                return 'DefaultMerchant : \n' + JSON.stringify(Invoice.DefaultMerchant, null, 4);
            });
            cb(err, _this3);
        });
    };

    // TODO userInfo sometimes returns non-200 status
    // TODO Move on to Here Api status calls.


    Merchant.prototype._loadMerchantStatus = function _loadMerchantStatus(cb) {
        var _this4 = this;

        Log.debug('Loading merchant status...');
        this.api.request({
            service: 'retail',
            op: 'status',
            format: 'json'
        }, function (err, hereApiStatus) {
            if (err) {
                return cb(err, _this4);
            }
            _this4.status = hereApiStatus.body;
            Invoice.DefaultCurrency = _this4.currency;
            Log.debug(function () {
                return 'Successfully loaded merchant status ' + JSON.stringify(hereApiStatus.body, null, 4);
            });
            cb(err, _this4);
        });
    };

    Merchant.prototype.request = function request(options, callback) {
        return this.api.request(options, callback);
    };

    _createClass(Merchant, [{
        key: 'signatureRequiredAbove',
        get: function get() {
            return $$(this._signatureRequiredAbove) || $$(this.cardSettings.signatureRequiredAbove) || $$(0);
        },
        set: function set(value) {
            this._signatureRequiredAbove = value;
        }
    }, {
        key: 'featureMap',
        get: function get() {
            return SdkFeature.map[this.country];
        }
    }, {
        key: 'emailAddress',
        get: function get() {
            return this.userInfo ? this.userInfo.email : null;
        }
    }, {
        key: 'businessName',
        get: function get() {
            return this.userInfo ? this.userInfo.businessName || this.userInfo.name : null;
        }
    }, {
        key: 'currency',
        get: function get() {
            return this.status.currencyCode;
        }
    }, {
        key: 'country',
        get: function get() {
            return this.address.country;
        }
    }, {
        key: 'cardSettings',
        get: function get() {
            return this.status.cardSettings;
        }
    }, {
        key: 'address',
        get: function get() {
            if (this._address) {
                return this._address;
            }
            var u = this.userInfo;
            var a = this._address = new InvoiceAddress();
            if (u && u.address) {
                u = u.address;
                a.country = u.country;
                a.postalCode = u.postal_code;
                a.city = u.locality;
                a.line1 = u.street_address;
                a.state = u.region;
            }
            return a;
        }
    }]);

    return Merchant;
}(EventEmitter);

Merchant.events = new EventEmitter();
module.exports = Merchant;

function resolver(api, options) {
    var env = api.env,
        service = options.service,
        op = options.op;
    if (!env || env === 'live') {
        return simpleUrl('api', service, op);
    } else if (env.indexOf('stage2') === 0) {
        if (service === 'retail') {
            return 'https://www.' + env + '.stage.paypal.com/webapps/hereapi/merchant/v1/' + op;
        } else if (service === 'auth') {
            return 'https://www.' + env + '.stage.paypal.com/webapps/auth/protocol/openidconnect/v1/' + op;
        } else if (service === 'payments') {
            return 'https://www.' + env + '.stage.paypal.com:11888/v1/payments/' + op;
        }
    } else if (env === 'sandbox') {
        return simpleUrl('api.sandbox', service, op);
    }
}

function simpleUrl(host, service, op) {
    if (service === 'retail') {
        return 'https://' + host + '.paypal.com/retail/merchant/v1/' + op;
    } else if (service === 'auth') {
        return 'https://' + host + '.paypal.com/v1/identity/openidconnect/' + op;
    } else if (service === 'payments') {
        return 'https://' + host + '.paypal.com/v1/payments/' + op;
    }
}

function makeInvoiceResolver(api) {
    var exResolver = api.resolvers.invoicing;
    return function (service, opts) {
        opts.headers = opts.headers || {};
        opts.headers['X-PAYPAL-REQUEST-SOURCE'] = 'MPA-DEVICE';
        return exResolver(service, opts);
    };
}

},{"./Features":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Features.js","./sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","async":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/async/lib/async.js","bignumber.js":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/bignumber.js/bignumber.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","paypal-invoicing":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/index.js","paypalrest-manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypalrest-manticore/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/RetailSDKUtil.js":[function(require,module,exports){
'use strict';

var _retailPaymentDevice = require('retail-payment-device');

var _sdkErrors = require('./sdkErrors');

var FormFactor = _retailPaymentDevice.PaymentDevice.FormFactor;

module.exports.StorageType = {
  Secure: 'S',
  Blob: 'B',
  String: 'V',
  SecureBlob: 'E'
};

module.exports.getEnumName = function (obj, val) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      if (obj[prop] === val) {
        return prop;
      }
    }
  }

  return val;
};

module.exports.transactionCancelledError = function (error) {
  return error && (error.code === _retailPaymentDevice.deviceError.paymentCancelled.code && error.domain === _retailPaymentDevice.errorDomain || error.code === _sdkErrors.transaction.customerCancel.code && error.domain === _sdkErrors.domain.transaction);
};

module.exports.hereAPICardDataFromCard = function (card) {
  // Fix up the reader type for EMV swipes
  var vendor = card.reader.manufacturer.toUpperCase();
  if (card.formFactor === FormFactor.MagneticCardSwipe) {
    if (vendor === 'MIURA') {
      // Decide what type of swipe this is
      if (card.isMSRFallbackAllowed) {
        // Wouldn't have been allowed to be swiped if not in fallback
        vendor = 'MIURA_FB_SWIPE';
      } else {
        vendor = 'MIURA_SWIPE';
      }
    }
  }

  var cardData = {
    reader: {
      vendor: vendor,
      readerSerialNumber: card.reader.serialNumber,
      deviceModel: card.reader.model
    }
  };

  if (card.formFactor === FormFactor.MagneticCardSwipe) {
    cardData.reader.keySerialNumber = card.ksn;
    cardData.inputType = 'swipe';
    cardData.track1 = card.track1;
    cardData.track2 = card.track2;
    cardData.track3 = card.track3;
  } else if (card.formFactor === FormFactor.SecureManualEntry) {
    cardData.inputType = 'keyIn';
    cardData.emvData = card.emvData;
    if (card.expiration && card.expiration.length > 2) {
      cardData.expirationMonth = card.expiration.substring(2);
      cardData.expirationYear = parseInt(card.expiration.substring(0, 2), 10) + 2000;
    }
    cardData.cvv = card.cvv;
  } else if (card.formFactor === FormFactor.Chip) {
    cardData.inputType = 'chip';
    cardData.emvData = card.emvData.apdu.data.toString('hex');
  } else if (card.formFactor === FormFactor.EmvCertifiedContactless) {
    cardData.inputType = card.isContactlessMSD ? 'contactless_msd' : 'contactless_chip';
    cardData.emvData = card.emvData.apdu.data.toString('hex');
  } else {
    throw new Error('Cannot generate HereAPI card data from ' + card);
  }

  return cardData;
};

},{"./sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/cal.js":[function(require,module,exports){
'use strict';

var stringify = require('qs/lib/stringify'),
    RetailSDKUtil = require('../common/RetailSDKUtil'),
    manticore = require('manticore'),
    manticore_log = require('manticore-log'),
    Log = manticore_log('cal');

var queueDetails,
    logGroup = generateGroupId(),
    logInvoiceId = '',
    requestSource = 'RetailSDK',
    savingLogStore = false,
    overlappedSaves = [],
    messageRunCounter = 0;

var MAX_CAL_EVENT_LENGTH = 20,
    CAL_LOG_SUCCESS = 0,
    CAL_LOG_FAIL = -1,
    MAX_CAL_STORE_LENGTH = 5,
    CAL_LOG_STORE_KEY = 'CalLogStore';

var RootCalConfig = {
    level: 'INFO',
    children: {}
};

/**
 * Attach the CAL logger to the manticore logging infra and setup the various counters.
 * @param callback
 */
module.exports.attach = function (callback) {
    // Load the existing log set
    manticore.getItem(CAL_LOG_STORE_KEY, RetailSDKUtil.StorageType.Secure, function (e, jsonString) {
        if (e) {
            Log.error('Failed to get persisted CAL queue ' + e.message);
        }
        if (jsonString) {
            queueDetails = JSON.parse(jsonString);
            // Increment the run counter since this is a new run
            queueDetails.runCounter++;
        } else {
            queueDetails = {
                // Currently queued events
                events: [],
                // When we're in the process of posting, we need to know how many we're saving
                // so that we can recover gracefully
                saving: 0,
                runCounter: 1,
                msgCounter: 0
            };
        }
        manticore_log.addLogger(calLog);
        callback(e);
    });
};

module.exports.configure = function (json) {
    manticore_log.configure(json, RootCalConfig);
};

/**
 * Mostly for testing purposes, but this will shut down CAL logging and unregister from manticore logging
 * @param callback
 */
module.exports.detach = function (callback) {
    saveLogStore(function (e) {
        manticore_log.removeLogger(calLog);
        if (callback) {
            callback(e);
        }
    });
};

/**
 * Flush the queued logs to the server
 * @param cb
 */
module.exports.flush = function (cb) {
    if (queueDetails.saving) {
        if (cb) {
            cb(new Error('Save already in progress.'));
        }
        return;
    }
    if (queueDetails.events.length) {
        var body = JSON.stringify({ events: queueDetails.events });
        queueDetails.saving = queueDetails.events.length;
        Log.debug('Flushing ' + queueDetails.saving + ' to CAL server.');
        doHttpPost(body, cb);
    } else {
        if (cb) {
            cb(null, 0);
        }
    }
};

// TODO these won't work like this if and when we don't have a single active transaction. We should restructure
// this soon to avoid the problem later. Easiest thing is probably to have some closure trick that will create a
// "logging facade" that stores this info and merges it with the fourth argument to regular logging.
module.exports.newGroup = newLogGroup;
module.exports.setInvoiceId = setCurrentInvoiceId;
module.exports.setRequestSourceId = setRequestSourceId;

/**
 * Cal logging framework for the SDK.
 * Cal logs require: name, actionId, status (0=success, -1 = fail), type (always set to "BIZ")
 * and logData consisting of actionId dependent values such as
 * timestamp (universal yyyy-MM-dd HH:mm:ss:fff +0000), duration, message details
 * The method signature is the same as the manticore log, with one additional Cal logging parameter: calLogData
 * manticore logs are verbose messages that can be logged as-is. These will be logged with "message" actionId (ToDo).
 * We could have a configuration that specifies what level of logs should be sent to Cal as messages.
 * For non-message logs, e.g. ClientInfo, NetworkResponse etc., the code will include Cal-specific log calls
 * These Cal-specific calls will send cal-specific information in the calLogData object.
 * Open for discussion: What comes first? manticore-log, and that in turn calls Cal log,
 * or Start with Cal log, and then call Manticore log from Cal?
 * @param level Debug, Trace, Info, Warn, Error
 * @param component ?
 * @param fnOrString Log message. You can pass a string, or use an es6 template INSIDE a function (for best performance).
 * @param calLogData json object with actionId dependent values
 * e.g. actionId=SWIPE/CreateInvoice etc., status=0/-1 (Success = 0, Fail = -1+ ...
 */
function calLog(level, component, fnOrString, calLogData) {

    //avoid recursive calls.
    if (component.name === 'cal') {
        return;
    }

    if (!component.calConfig) {
        buildCalConfigMapping(component);
    }

    if (manticore_log.Ranks[level] < manticore_log.levelFor(component.calConfig)) {
        return;
    }

    //default actionId = message
    if (!calLogData) {
        calLogData = { 'actionId': 'Message' };
    }

    setDefaultCalLogData(calLogData, level, fnOrString);

    //ToDo: calculate status based on the level, if it is not available in calLogData
    var calLogEvent = {
        'status': calLogData.status,
        'type': 'BIZ',
        'name': calLogData.actionId + '.CLIENT'
    };

    //cal log data expects the status as 'result', so change that before stringifying the json object.
    calLogData.result = calLogData.status;
    delete calLogData.status;
    if (typeof fnOrString === 'function') {
        //ToDo:Question save this in details or reason?
        calLogData.details = fnOrString().toString();
    } else {
        calLogData.details = fnOrString.toString();
    }
    calLogData.logGroup = logGroup;
    calLogData.invoiceId = logInvoiceId;
    calLogEvent.data = stringify(calLogData, { encode: false });
    manticore.setTimeout(function () {
        return addCalEvent(calLogEvent);
    }, 0);
}

function buildCalConfigMapping(component) {
    // Build the association of CAL configuration to manticore-log component
    var loggers = component.name.split('.'),
        myComponent = RootCalConfig,
        parent = RootCalConfig;
    for (var i = 0; i < loggers.length; i++) {
        if (!myComponent.children[loggers[i]]) {
            myComponent.children[loggers[i]] = { children: {}, parent: parent };
        }
        myComponent = myComponent.children[loggers[i]];
        parent = myComponent;
    }
    component.calConfig = myComponent;
}

function setDefaultCalLogData(calLogData, level, fnOrString) {
    //Set the actionId to message if not specified
    if (!calLogData.actionId) {
        calLogData.actionId = 'message';
    }
    //Set the status based on level, if not specified in calLogData
    if (!calLogData.status) {
        switch (level.toLowerCase()) {
            case 'debug':
                calLogData.status = CAL_LOG_SUCCESS;
                break;
            case 'info':
                calLogData.status = CAL_LOG_SUCCESS;
                break;
            case 'error':
                calLogData.status = CAL_LOG_FAIL;
                break;
            case 'warn':
                calLogData.status = CAL_LOG_FAIL;
                break;
            default:
                calLogData.status = CAL_LOG_FAIL;
                break;
        }
    }

    // Build the msgId which is an incrementing-per-sdk-launch "runId", a forever-incrementing message counter, and a
    // per-run message counter
    calLogData.msgId = queueDetails.runCounter + '.' + ++queueDetails.msgCounter + '.' + ++messageRunCounter;
}

function addCalEvent(calLogEvent) {
    var logOverflow = function logOverflow() {
        return MAX_CAL_EVENT_LENGTH <= queueDetails.events.length;
    };
    if (logOverflow()) {
        Log.debug('CAL log overflow. Max messages: ' + MAX_CAL_EVENT_LENGTH);
    }

    //if the previous flush attempt was not successful, then remove an element from the array
    while (logOverflow()) {
        queueDetails.events.shift();
        if (queueDetails.saving) {
            queueDetails.saving--;
        }
    }
    queueDetails.events.push(calLogEvent);
    saveLogStore();
}

function addMessage(message) {
    queueDetails.events.push(message);
    saveLogStore();
}

function saveLogStore(cb) {
    if (savingLogStore) {
        // Even if it's null, because we need to know to save again
        return overlappedSaves.push(cb);
    }
    manticore.setItem(CAL_LOG_STORE_KEY, RetailSDKUtil.StorageType.SecureBlob, JSON.stringify(queueDetails), function (saveError) {
        savingLogStore = false;
        if (overlappedSaves.length) {
            (function () {
                var nextSaves = overlappedSaves;
                overlappedSaves = [];
                saveLogStore(function (e) {
                    for (var _iterator = nextSaves, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                        var _ref;

                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            _i = _iterator.next();
                            if (_i.done) break;
                            _ref = _i.value;
                        }

                        var savedCallback = _ref;

                        if (savedCallback) {
                            savedCallback(e);
                        }
                    }
                });
            })();
        }
        if (cb) {
            cb(saveError);
        }
    });
}

function removePostedLogs(cb) {
    Log.debug(function () {
        return 'Removing ' + queueDetails.saving + ' posted logs.';
    });
    queueDetails.events.splice(0, queueDetails.saving);
    queueDetails.saving = 0;
    saveLogStore(cb);
}

function doHttpPost(calLogMessageBody, cb) {
    var Merchant = require('../common/Merchant'),
        saved = queueDetails.saving;
    if (Merchant.active) {
        Merchant.active.request({
            service: 'retail',
            op: 'cal',
            method: 'POST',
            headers: {
                'X-PAYPAL-REQUEST-SOURCE': requestSource,
                'Content-Type': 'application/json'
            },
            body: calLogMessageBody
        }, function (error) {
            if (!error) {
                removePostedLogs(function (e) {
                    if (cb) {
                        cb(e, saved);
                    }
                });
            } else {
                queueDetails.saving = 0;
                // TODO decide whether to re-post now or some other time... Or whether
                // someone else should handle that decision based on the callback
                if (cb) {
                    cb(error);
                }
            }
        });
    } else {
        if (cb) {
            cb(new Error('No merchant available, cannot post CAL logs'));
        }
    }
}

//Log grouping
//Logs can grouped by associating a logGroup with each log within a transaction
//The transaction manager can invoke newLogGroup() to generate a new log group

function newLogGroup(groupId) {
    logGroup = groupId || generateGroupId();
    logInvoiceId = '';
    Log.debug(function () {
        return 'Set group Id to ' + logGroup;
    });
    return logGroup;
}

function setCurrentInvoiceId(invoiceId) {
    logInvoiceId = invoiceId;
}

function setRequestSourceId(id) {
    if (id) {
        requestSource = 'RetailSDK.' + id.substr(0, 150);
    }
}

function generateGroupId() {
    return Date.now() + '-' + Math.random();
}

//calLog('debug', 'cal', 'debug message 1');
//newLogGroup();
//calLog('info', 'cal', 'info message 1');
//setCurrentInvoiceId('Invoice1');
//calLog('error', 'cal', 'error message 1');

//Cal log examples from the Windows SDK:
//BuildAbstractHereJsonRequest(_serverMapping.HereAPIBaseURI, "/webapps/hereapi/merchant/v1/cal/", HttpMethodEnum.Post)
//live log content:
//{"events":[{"status":0,"type":"BIZ","name":"Message.CLIENT","data":"sessionId=d6696eda-238f-4c81-a904-499496acc778&timestamp=2015-07-21 18:43:47:605 +0000&actionId=Message&level=Debug&result=0&reason=PPHSDK%2BCardReaderManager-Activate&modelNo=Dell+Inc.+-+Latitude+E7240&osVersion=Windows+NT+6.3&sdkVersion=1.0.0.0&appVersion=1.0.0.0&appName=PayPalHereSDKPrivateSampleApp"},{"status":0,"type":"BIZ","name":"Message.CLIENT","data":"sessionId=d6696eda-238f-4c81-a904-499496acc778&timestamp=2015-07-21 18:43:47:605 +0000&actionId=Message&level=Debug&result=0&reason=PPHSDK%2BCardReaderManager-isMandatoryUpdateRequired+%3A+False&modelNo=Dell+Inc.+-+Latitude+E7240&osVersion=Windows+NT+6.3&sdkVersion=1.0.0.0&appVersion=1.0.0.0&appName=PayPalHereSDKPrivateSampleApp"},{"status":0,"type":"BIZ","name":"Message.CLIENT","data":"sessionId=d6696eda-238f-4c81-a904-499496acc778&timestamp=2015-07-21 18:43:47:902 +0000&actionId=Message&level=Debug&result=0&reason=PPHSDK.CardReaderWatcher.InvalidAudio-Not+a+valid+audio+device+%5C%5C%3F%5CSWD%23MMDEVAPI%23%7B0.0.0.00000000%7D.%7Bde63f815-d337-4765-ad7f-e96a54610559%7D%23%7Be6327cad-dcec-4949-ae8a-991e976a79d2%7D(True)+-+audioEndpointType%3A+DigitalAudioDisplayDeviceHDMI%2C+EnclosureLocation+%3A+Unknown&modelNo=Dell+Inc.+-+Latitude+E7240&osVersion=Windows+NT+6.3&sdkVersion=1.0.0.0&appVersion=1.0.0.0&appName=PayPalHereSDKPrivateSampleApp"},{"status":0,"type":"BIZ","name":"Message.CLIENT","data":"sessionId=d6696eda-238f-4c81-a904-499496acc778&timestamp=2015-07-21 18:43:47:980 +0000&actionId=Message&level=Debug&result=0&reason=PPHSDK.CardReaderWatcher.InvalidAudio-Not+a+valid+audio+device+%5C%5C%3F%5CSWD%23MMDEVAPI%23%7B0.0.0.00000000%7D.%7B897d524e-a5d5-4dc1-94c9-49b516bd68f5%7D%23%7Be6327cad-dcec-4949-ae8a-991e976a79d2%7D(True)+-+audioEndpointType%3A+Speakers%2C+EnclosureLocation+%3A+Unknown&modelNo=Dell+Inc.+-+Latitude+E7240&osVersion=Windows+NT+6.3&sdkVersion=1.0.0.0&appVersion=1.0.0.0&appName=PayPalHereSDKPrivateSampleApp"},{"status":0,"type":"BIZ","name":"Message.CLIENT","data":"sessionId=d6696eda-238f-4c81-a904-499496acc778&timestamp=2015-07-21 18:43:47:980 +0000&actionId=Message&level=Debug&result=0&reason=PPHSDK.CardReaderWatcher.InvalidAudio-Not+a+valid+audio+device+%5C%5C%3F%5CSWD%23MMDEVAPI%23%7B0.0.1.00000000%7D.%7B085aa242-6239-45a2-89a6-3efb67ce3549%7D%23%7B2eef81be-33fa-4800-9670-1cd474972c3f%7D(True)+-+audioEndpointType%3A+UnknownFormFactor%2C+EnclosureLocation+%3A+Unknown&modelNo=Dell+Inc.+-+Latitude+E7240&osVersion=Windows+NT+6.3&sdkVersion=1.0.0.0&appVersion=1.0.0.0&appName=PayPalHereSDKPrivateSampleApp"}]}
//POST https://www.paypal.com/webapps/hereapi/merchant/v1/cal/ HTTP/1.1

},{"../common/Merchant":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Merchant.js","../common/RetailSDKUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/RetailSDKUtil.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","qs/lib/stringify":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/qs/lib/stringify.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/flow.js":[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventEmitter = require('events').EventEmitter,
    Log = require('manticore-log')('flow');

var FACADE = Symbol();

/**
 * A flow is a series of steps in order to complete a process. Each step may complete, cancel, go forward or back
 * in the process. In code, a flow is an array of functions. The functions take one argument - a flow controller -
 * which exposes methods to control the next step in the flow.
 *
 */

var Flow = function (_EventEmitter) {
    _inherits(Flow, _EventEmitter);

    /**
     * Construct a new flow with steps pass as individual arguments (each a function) OR
     * as a single array as the second argument.
     * Call start() after setting up appropriate event handlers.
     */
    function Flow(thisForSteps, allSteps) {
        _classCallCheck(this, Flow);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        _this.owner = thisForSteps;
        if (Array.isArray(allSteps)) {
            _this.steps = allSteps;
        } else {
            _this.steps = Array.prototype.slice.call(arguments, 1);
        }
        /**
         * A grab bag of data that can be used to share information among steps
         * @type {object}
         */
        _this.data = {};
        _this[FACADE] = null;
        _this.stepIndex = 0;
        _this.previousSteps = [];
        return _this;
    }

    Flow.prototype.start = function start() {
        this[FACADE] = new FlowFacade(this);
        this[FACADE]._executeStep(0);
        return this;
    };

    Flow.prototype.abortFlow = function abortFlow(error) {
        if (!this[FACADE]) {
            Log.error('Abort called on an inactive flow!');
            return;
        }
        this[FACADE].abortFlow(error);
    };

    return Flow;
}(EventEmitter);

/**
 * Present a protected view of the flow to a particular step so that it can't call the
 * true flow step after it is deactivated.
 */


var FlowFacade = function (_EventEmitter2) {
    _inherits(FlowFacade, _EventEmitter2);

    function FlowFacade(flow) {
        _classCallCheck(this, FlowFacade);

        var _this2 = _possibleConstructorReturn(this, _EventEmitter2.call(this));

        _this2.active = true;
        _this2.flow = flow;
        return _this2;
    }

    FlowFacade.prototype._prepareForChange = function _prepareForChange(noPush) {
        var f = this.flow;
        if (!noPush) {
            f.previousSteps.push(f.stepIndex);
        }
        if (f[FACADE]) {
            f[FACADE].active = false;
        }
        f[FACADE] = new FlowFacade(f);
    };

    FlowFacade.prototype._check = function _check() {
        if (!this.active) {
            Log.error('Flow step completion function called by inactive step ' + this.stepName + '!');
            this.flow.emit('flowError', new Error('Flow step completion function called by inactive step!'));
            return false;
        }
        return true;
    };

    FlowFacade.prototype._executeStep = function _executeStep(index) {
        var _this3 = this;

        var direction = index < this.flow.stepIndex ? 'regressing' : 'advancing';
        this.flow.stepIndex = index;
        var stepFn = this.flow.steps[index];
        Log.debug(function () {
            return 'Flow ' + direction + ' to ' + _this3.stepName;
        });

        try {
            stepFn.call(this.flow.owner, this.flow[FACADE]);
        } catch (e) {
            Log.error(this.stepName + ' execution returned an error: ' + e);
            this.flow[FACADE].abortFlow(e);
        }
    };

    /**
     * A flow step should call next to advance to the next step, or complete if it's the last
     */


    FlowFacade.prototype.next = function next() {
        if (!this._check()) {
            Log.debug('Flow::next called out of turn!');
            return;
        }
        var f = this.flow;
        if (f.stepIndex + 1 >= f.steps.length) {
            return this.completeFlow();
        }
        f.emit('next', f.stepIndex);
        this._prepareForChange();
        this._executeStep(f.stepIndex + 1);
    };

    /**
     * A flow step should call back to end the current step and go back to the previous step
     * (or abort if you're the first)
     * TODO how do we continue to go back if the previous step was skipped?
     */


    FlowFacade.prototype.back = function back() {
        if (!this._check()) {
            Log.debug('Flow::back called out of turn!');
            return;
        }
        var f = this.flow;
        if (f.previousSteps.length === 0) {
            return this.abortFlow();
        }
        f.emit('back', f.steps[f.stepIndex], f.steps[f.stepIndex - 1]);
        this._prepareForChange(true);
        this._executeStep(f.previousSteps.pop());
    };

    /**
     * Immediately complete the flow, firing the completed event
     */


    FlowFacade.prototype.completeFlow = function completeFlow() {
        var _this4 = this;

        if (!this._check()) {
            Log.debug('Flow::complete called out of turn!');
            return;
        }
        Log.debug(function () {
            return (_this4.flow.name || 'Anonymous') + ' Flow completed.';
        });
        var f = this.flow;
        this._prepareForChange();
        f.stepIndex = null;
        f[FACADE] = null;
        f.emit('completed', f.data);
        f.emit('ended', f.data);
    };

    /**
     * Immediately abort the flow, firing the aborted event
     */


    FlowFacade.prototype.abortFlow = function abortFlow(error) {
        if (!this._check()) {
            Log.debug('Flow::abortFlow called out of order!');
            return;
        }
        Log.debug((this.flow.name || 'Anonymous') + ' Flow aborted');
        var f = this.flow;
        if (error) {
            f.data.error = error;
        }
        f[FACADE].emit('aborted');
        this._prepareForChange();
        f.stepIndex = null;
        f[FACADE] = null;
        f.emit('aborted', f.data);
        f.emit('ended', f.data);
    };

    FlowFacade.prototype.nextOrAbort = function nextOrAbort(error) {
        if (error) {
            this.abortFlow(error);
        } else {
            this.next();
        }
    };

    _createClass(FlowFacade, [{
        key: 'stepName',
        get: function get() {
            var fn = this.flow.steps[this.flow.stepIndex];
            return fn ? fn.fnName || fn.name : undefined;
        }
    }, {
        key: 'data',
        get: function get() {
            return this.flow.data;
        }
    }, {
        key: 'stepIndex',
        get: function get() {
            return this.flow.stepIndex;
        }
    }, {
        key: 'previousSteps',
        get: function get() {
            return this.flow.previousSteps;
        }
    }]);

    return FlowFacade;
}(EventEmitter);

module.exports = Flow;

},{"events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js":[function(require,module,exports){
'use strict';

/**
 * Load the overall retail SDK localization files
 */

module.exports = require('l10n-manticore')({
  en: require('./localized/en'),
  jp: require('./localized/jp')
});

},{"./localized/en":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/localized/en.js","./localized/jp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/localized/jp.js","l10n-manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/l10n-manticore/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/localized/en.js":[function(require,module,exports){
"use strict";

module.exports = {
  "Done": "Done",
  "Cancel": "Cancel",
  "Ok": "OK",
  "Yes": "Yes",
  "No": "No",
  "Error": "Oops!",
  "Sig": {
    "Title": "Charge ${amount} to ${cardIssuer} *${lastFour}",
    "Here": "Sign Here",
    "Footer": "I agree to pay the amount above according to the terms applicable to my card."
  },
  "Rcpt": {
    "Title": "${amount}",
    "Prompt": "Would you like a receipt?",
    "EmailButtonTitle": "Email",
    "SMSButtonTitle": "Text",
    "NoThanksButtonTitle": "No Thanks",
    "Sending": "Sending Receipt...",
    "Disclaimer": "Receipts will be delivered by PayPal. See your receipt for PayPal's Privacy Policy",
    "Email": {
      Title: "EMAIL RECEIPT",
      Placeholder: "me@somewhere.com",
      Disclaimer: "By entering my email, I agree to receive emails for all future PayPal Here transactions.",
      SendButtonTitle: "Send"
    },
    "SMS": {
      Title: "TEXT RECEIPT",
      Placeholder: "+14085551212",
      Disclaimer: "You agree that you're authorized to add this phone number and consent to receiving automated texts. Message and data rates may apply. Receipts will be delivered by PayPal. See your receipt for PayPal's Privacy Policy.",
      SendButtonTitle: "Send"
    }
  },
  "Tx": {
    "Alert": {
      "Ready": {
        "Title": "Ready",
        "Msg": "Tap, Insert or Swipe a card when ready."
      },
      "EnterPin": {
        "Title": "Enter PIN"
      },
      "ReadyForInsertOrSwipeOnly": {
        "Title": "Ready",
        "Msg": "Insert or swipe a card when ready."
      },
      "ReadyForSwipeOnly": {
        "Title": "Please Swipe Card",
        "Msg": "Swipe the card at the top of the reader"
      },
      "ReadyForInsertOnly": {
        "Title": "Ready",
        "Msg": "Insert a card when ready."
      },
      "Cancelled": {
        "Title": "Cancelled",
        "Msg": "Transaction Cancelled"
      },
      "Cancel": {
        "Title": "Cancel",
        "Msg": "Would you like to cancel this transaction?"
      },
      "TimeOut": {
        "Title": "Transaction Timed Out",
        "Msg": "Transaction was not completed.",
        "Button": "Cancel transaction"
      },
      "NfcNotAllowed": {
        "Title": "Insert or swipe card",
        "Msg": "Card provider requires that you insert or swipe card."
      },
      "NfcFallback": {
        "Title": "Unable to Read Card",
        "Msg": "Insert or swipe card now, or try a different card."
      },
      "NfcPaymentDeclined": {
        "Title": "Contactless Transaction Declined",
        "Msg": "Do you want to try again by inserting the card?"
      },
      "InsertOrSwipe": {
        "Title": "Insert or Swipe Card",
        "Msg": "Card issuer requires\nthat you insert or swipe card",
        "Button": "Cancel transaction"
      },
      "IncorrectOnlinePin": {
        "Title": "Incorrect PIN",
        "Msg": "The PIN entered was incorrect. Please try again."
      },
      "GenericError": {
        "Title": "Transaction failed",
        "PaymentMessage": "Unable to process payment",
        "RefundMessage": "Unable to process refund"
      },
      "TapDifferentCard": {
        "Title": "Unable to read card",
        "Msg": "Please insert or swipe card now, or press OK and tap a different card"
      },
      "BlockedCardInserted": {
        "Title": "Declined",
        "Msg": "Please remove the card and contact the card issuer for more information"
      },
      "BlockedCardTapped": {
        "Title": "Declined",
        "Msg": "Please contact the card issuer for more information"
      },
      "BlockedCardSwiped": {
        "Title": "Declined",
        "Msg": "Please contact the card issuer for more information"
      },
      "ChipCardSwiped": {
        "Title": "Chip card detected",
        "Msg": "Please insert card"
      },
      "UnsuccessfulInsert": {
        "Title": "Unable to read card",
        "Msg": "Please try again. Firmly insert the card, chip first, into the bottom of the reader"
      },
      "AmountTooLow": {
        "Title": "Amount Too Low",
        "Msg": "The minimum amount for card payments is ${amount}. Please enter a new amount or choose a different payment method."
      },
      "AmountTooHigh": {
        "Title": "Amount Too High",
        "Msg": "The maximum amount for card payments is ${amount}. Please enter a new amount or choose a different payment method."
      }
    },
    "Retry": "Try again?",
    "CancelledByUser": "Payment Cancelled",
    "TransactionFailed": "Payment Declined",
    "TransactionSuccessful": "Payment Successful",
    "RefundSuccessful": "Refund Complete",
    "RefundFailed": "Refund Failed"
  },
  "SwUpgrade": {
    "Required": {
      "Title": "Update Required",
      "Msg": "Your card reader must be updated before you can process transactions."
    },
    "Optional": {
      "Title": "Update available",
      "Msg": "An update is available for your card reader."
    },
    "Buttons": {
      "Ok": "Update Now",
      "Cancel": "Not Now",
      "Retry": "Try again"
    },
    "Failed": {
      "Title": "Software Update Failed",
      "Msg": "Sorry, the update could not be completed.",
      "BatteryLow": "Please recharge the card reader."
    },
    "Updating": {
      "Title": "Updating Reader",
      "Msg": "Do not disconnect your reader"
    },
    "Initializing": "Initializing card reader... Do not disconnect",
    "ValidatingSecurityKeys": "Validating security keys... Do not disconnect",
    "SecurityKeysInstalled": "Security keys installed.",
    "UpdatingOS": "Updating OS ${progress}%... Do not disconnect",
    "UpdatingMPI": "Updating Terminal ${progress}%... Do not disconnect",
    "UpdatingConfig": "Updating Configuration ${progress}%... Do not disconnect",
    "Restarting": "Restarting card reader... Do not disconnect",
    "Reconnecting": "Reconnecting to card reader... Do not disconnect",
    "Connected": "Connected",
    "Usb": {
      "UsbUnplug": "Please unplug your USB reader and press OK",
      "UsbWait": "Please wait before plugging in your USB reader.",
      "UsbPlug": "Please reconnect your USB reader."
    }
  },
  "EMV": {
    "Processing": "Processing...",
    "ProcessingRefund": "Processing Refund...",
    "Auth": "Authorizing...",
    "Cancelling": "Cancelling...",
    "Finalize": "Completing Payment...",
    "DoNotRemove": "Do not remove the card.",
    "Remove": "Please remove card.",
    "Complete": "${amount} paid",
    "RefundComplete": "${amount} refunded",
    "Failed": "Transaction Failed",
    "Select": "Choose an application:",
    "Device": {
      "RemoveCard": "Please remove card.",
      "DoNotRemove": "Do not remove card."
    }
  }
};

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/localized/jp.js":[function(require,module,exports){
"use strict";

module.exports = {
  "Sig": {
    "Footer": ""
  }
};

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.sdk = exports.network = exports.retail = exports.merchant = exports.transaction = exports.domain = undefined;
exports.getError = getError;

var _manticorePaypalerror = require('manticore-paypalerror');

var domain = exports.domain = {
  transaction: 'transaction',
  merchant: 'merchant',
  retail: 'retail',
  sdk: 'sdk',
  network: 'network'
};

/**
 * Usage: decorate(new Error(), SdkError.transaction.customerCancel)
 */
function getError(error, info) {
  // TODO PayPalError.makeError should assign {message} after localization is implemented
  // This function would not be needed at that point
  error.message = info.message;
  return _manticorePaypalerror.PayPalError.makeError(error, info);
}

function payPalError(errDomain, code, message) {
  var error = {
    domain: errDomain,
    code: code,
    message: message,
    withDevMessage: function withDevMessage(msg) {
      error.developerMessage = msg;
      return error;
    },
    withDebugId: function withDebugId(id) {
      error.debugId = id;
      return error;
    }
  };

  return error;
}

/**
 * All errors are belong to here. One assignment per domain will keep auto-complete happy.
 */
var transaction = exports.transaction = {
  customerCancel: payPalError(domain.transaction, 1, 'Transaction cancelled by customer'),
  genericCancel: payPalError(domain.transaction, 2, 'The transaction was cancelled'),
  cardCantContinue: payPalError(domain.transaction, 3, 'Cannot continue with specified card.'),
  noFunctionalDevices: payPalError(domain.transaction, 4, 'No functional devices.'),
  invoiceStatusMismatch: payPalError(domain.transaction, 5, 'The invoice status is not eligible for the given transaction method'),
  amountTooLow: payPalError(domain.transaction, 6, 'The invoice amount was too low'),
  amountTooHigh: payPalError(domain.transaction, 7, 'The invoice amount was too high'),
  failedToCollectSignature: payPalError(domain.transaction, 8, 'Failed to collect signature'),
  cannotSwipeChipCard: payPalError(domain.transaction, 9, 'Cannot swipe a chip card'),
  mustSwipeCard: payPalError(domain.transaction, 10, 'Must swipe the card'),
  refundCardMismatch: payPalError(domain.transaction, 1, 'Presented card does not card used in original transaction')
};

var merchant = exports.merchant = {
  failedToLoad: payPalError(domain.merchant, 1, 'Failed to load the merchant information.'),
  requiredInfoNotLoaded: payPalError(domain.merchant, 2, 'Failed to load required merchant information'),
  notInitialized: payPalError(domain.merchant, 3, 'Merchant not initialized')
};

//The error codes used here must match the codes returned by the retail payments endpoint
var retail = exports.retail = {
  nfcPaymentDeclined: payPalError(domain.retail, 600075),
  incorrectOnlinePin: payPalError(domain.retail, 6000164),
  onlinePinMaxRetryExceed: payPalError(domain.retail, 6000165),
  contactIssuer: payPalError(domain.retail, 580031)
};

var network = exports.network = {
  requestFailed: payPalError(domain.network, 1, 'Request failed'),
  networkOffline: payPalError(domain.network, -1001)
};

var sdk = exports.sdk = {
  userCancelled: payPalError(domain.sdk, 1, 'Action was cancelled by user'),
  fileNotFound: payPalError(domain.sdk, 2, 'Unable to retrieve file from device storage')
};

},{"manticore-paypalerror":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-paypalerror/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/debug.js":[function(require,module,exports){
'use strict';

var m = require('manticore');

m.miuraSwRepo = 'dev-stage-2';

},{"manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/BaseTransactionFlow.js":[function(require,module,exports){
'use strict';

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _retailPaymentDevice = require('retail-payment-device');

var _sdkErrors = require('../common/sdkErrors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Flow = require('../common/flow'),
    l10n = require('../common/l10n'),
    SignatureStep = require('./steps/SignatureStep'),
    FinalizePaymentStep = require('./steps/FinalizePaymentStep'),
    MerchantTakePaymentStep = require('./steps/MerchantTakePaymentStep'),
    ReceiptStep = require('./steps/ReceiptStep'),
    TransactionRecord = require('../transaction/TransactionRecord'),
    PaymentErrorHandler = require('./PaymentErrorHandler'),
    Cal = require('../common/cal'),
    manticore = require('manticore'),
    messageHelper = require('./messageHelper');

var Log = (0, _manticoreLog2.default)('flow.baseTransactionFlow');
var AuthCode = _retailPaymentDevice.PaymentDevice.authCode;

/**
 * Parent class to manage payment flows (swipe, nfc and emv)
 */

var BaseTransactionFlow = function () {
    function BaseTransactionFlow(card, context, onCompleteCallback) {
        var _this = this;

        _classCallCheck(this, BaseTransactionFlow);

        this.card = card;
        this.context = context;
        this.onCompleteCallback = onCompleteCallback;
        this.transactionCancelRequested = function () {
            Log.info('Transaction cancel was requested from device ' + _this.card.reader.id);
            _this.card.reader.deactivate(_this.context, false, function () {
                Log.info('Deactivated card reader ' + _this.card.reader.id);
                _this.flow.abortFlow((0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.paymentCancelled));
            });
        };
        this.transactionCancelled = function () {
            Log.info('Transaction on device ' + _this.card.reader.id + ' was cancelled');
            _this.flow.abortFlow((0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.paymentCancelled));
        };
    }

    /***
     * Sets the flow steps for the controller
     * @param flowName - Name for the flow
     * @param flowSteps - Sequence flow steps that will be executed by the flow controller
     * @returns {BaseTransactionFlow} - Returns 'this' object for enabling Fluent Interface
     */


    BaseTransactionFlow.prototype.setFlowSteps = function setFlowSteps(flowName, flowSteps) {
        this.flowName = flowName;
        this.flowSteps = flowSteps;
        this.flow = new Flow(this, this.flowSteps);
        return this;
    };

    BaseTransactionFlow.prototype.addFlowEndedHandler = function addFlowEndedHandler(handler) {
        if (this.flow === undefined) {
            throw new Error('Flow needs to be initialized first');
        }
        this.flow.on('ended', handler);
        return this;
    };

    /***
     * Sets the flow that should be triggered on completion of the flowSteps registered via 'setFlowSteps' function
     * @param completionFlowName - Name fr the completion flow
     * @param flowCompletionSteps - List of flow steps
     * @returns {BaseTransactionFlow} - Returns 'this' object for enabling Fluent Interface
     */


    BaseTransactionFlow.prototype.setCompletionSteps = function setCompletionSteps(completionFlowName, flowCompletionSteps) {

        this.completionFlowName = completionFlowName;
        this.completionFlowSteps = flowCompletionSteps;
        return this;
    };

    /**
     * Starts executing the flow steps that were set by the 'setFlowSteps' function
     */


    BaseTransactionFlow.prototype.startFlow = function startFlow() {
        var _this2 = this;

        Log.debug(function () {
            return 'Start executing ' + _this2.flowSteps.length + ' steps for ' + _this2.flowName + ' flow';
        });
        var rootFlow = this.flow;
        this.flow.name = this.flowName;
        this.flow.on('completed', function (data) {
            _this2.completeTransaction(data);
        });
        this.flow.on('aborted', function (data) {
            _this2.abortTransaction(data);
        });

        this.flow.start();
    };

    BaseTransactionFlow.prototype.invokeCompleteCallback = function invokeCompleteCallback(flowData, action) {
        flowData.alert && flowData.alert.dismiss();
        this.invokeCompleteCallbackWithoutDismissingAlert(flowData, action);
    };

    BaseTransactionFlow.prototype.invokeCompleteCallbackWithoutDismissingAlert = function invokeCompleteCallbackWithoutDismissingAlert(flowData, action) {
        this.onCompleteCallback(flowData.error, action, flowData.tx);
    };

    BaseTransactionFlow.prototype.completeTransaction = function completeTransaction(data) {
        var _this3 = this;

        Log.debug(function () {
            return 'Starting completion steps for ' + _this3.flowName + ' flow';
        });
        if (!this.completionFlowSteps) {
            Log.debug(function () {
                return 'Flow ended and completion steps not defined. Proceeding to invoke complete callback';
            });
            this.invokeCompleteCallback(data, null);
        } else {
            this.completionFlow = new Flow(this, this.completionFlowSteps);
            this.completionFlow.name = this.completionFlowName;
            this.completionFlow.data = data;
            this.completionFlow.on('ended', function (data) {
                Log.debug(function () {
                    return 'Flow ended. Proceeding to invoke flow complete callback (error: ' + data.error + ')';
                });
                _this3.invokeCompleteCallback(data, null);
            });
        }

        if (this.card && this.card.reader) {
            // Reset the terminal
            this.card.reader.clearTransaction(function () {
                _this3.completionFlow && _this3.completionFlow.start();
            });
        } else {
            this.completionFlow && this.completionFlow.start();
        }
    };

    BaseTransactionFlow.prototype.abortTransaction = function abortTransaction(data) {
        var _this4 = this;

        this.voidPaymentIfApplicable(data);
        var err = data.error,
            formFactor = this.card && this.card.formFactor,
            reader = this.card && this.card.reader;

        Log.warn('Flow (formFactor: ' + formFactor + ') aborted with error code: \'' + err.code + '\'\n' + err);
        if (err.code) {
            new PaymentErrorHandler(this.context).handle(err, formFactor, reader, function (action) {
                if (action === PaymentErrorHandler.action.abort) {
                    _this4.completeTransaction(data);
                } else if (action === PaymentErrorHandler.action.retryWithSwipe) {
                    _this4.invokeCompleteCallbackWithoutDismissingAlert(data, action);
                } else {
                    _this4.invokeCompleteCallback(data, action);
                }
            });
            return;
        }

        if (reader) {
            reader.display(_retailPaymentDevice.PaymentDevice.Message.TransactionCancelled, messageHelper.formattedInvoiceTotal(this.context.invoice), function (err) {
                _this4.completeTransaction(data);
            });
        } else {
            this.completeTransaction(data);
        }
    };

    BaseTransactionFlow.prototype.voidPaymentIfApplicable = function voidPaymentIfApplicable(data) {
        var _this5 = this;

        if (data && data.tx && data.tx.transactionHandle) {
            (function () {

                var body = { invoiceId: _this5.context.invoice.payPalId };
                if (data.tx.responseCode) {
                    body.responseCode = data.tx.responseCode;
                }

                if (data.cardResponse && data.cardResponse.apdu && data.cardResponse.apdu.data) {
                    body.emvData = data.cardResponse.apdu.data.toString('hex');
                }

                var op = 'payment/' + data.tx.transactionHandle + '/void';
                Log.debug(function () {
                    return 'Invoice void request:' + JSON.stringify(body, null, 4);
                });
                _this5.context.merchant.request({
                    service: 'retail',
                    op: op,
                    format: 'json',
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                }, function (error, voidRz) {
                    if (error) {
                        return Log.error('Void request ' + op + ' returned an error for payload: ' + JSON.stringify(body, null, 4) + '\n' + error + ' ');
                    }

                    Log.debug(function () {
                        return 'Successfully voided invoice id: ' + _this5.context.invoice.payPalId + ' \n' + JSON.stringify(voidRz || {}, null, 4);
                    });
                });
            })();
        }
    };

    BaseTransactionFlow.prototype.saveInvoiceStep = function saveInvoiceStep(flow) {
        var _this6 = this;

        this.context.invoice.save(function (error) {
            if (error) {
                Log.error('Unable to save invoice. Error: ' + error + '\n' + JSON.stringify(_this6.context.invoice, null, 4));
                var authCode = AuthCode.TransactionFailure;
                if (error.code === _sdkErrors.network.networkOffline.code) {
                    authCode = AuthCode.NoNetwork;
                }
                Log.debug('Pushing authCode : ' + authCode);
                _this6.card.reader.completeTransaction(authCode, function (err, rz) {
                    if (err) {
                        Log.error('Error response on pushing auth code to terminal ' + JSON.stringify(err));
                    }
                    return flow.abortFlow(error);
                });
            } else {
                Cal.setInvoiceId(_this6.context.invoice.payPalId);
                flow.next();
            }
        });
    };

    BaseTransactionFlow.prototype.createFlowMessageStep = function createFlowMessageStep(messageHelperFunc) {
        var _this7 = this;

        return function (flow) {
            messageHelperFunc(_this7.context, flow.data, function (alert) {
                flow.next();
            });
        };
    };

    BaseTransactionFlow.prototype.stopBatteryPollStep = function stopBatteryPollStep(flow) {
        if (this.card && this.card.reader) {
            this.card.reader.stopPollForBattery();
        }
        flow.next();
    };

    BaseTransactionFlow.prototype.startBatteryPollStep = function startBatteryPollStep(flow) {
        if (this.card && this.card.reader) {
            this.card.reader.startPollForBattery();
        }
        flow.next();
    };

    BaseTransactionFlow.prototype.stopWatchingForTransactionCancel = function stopWatchingForTransactionCancel(flow) {
        this._removeTransactionCancelListener();
        flow.next();
    };

    return BaseTransactionFlow;
}();

module.exports = BaseTransactionFlow;

},{"../common/cal":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/cal.js","../common/flow":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/flow.js","../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../common/sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","../transaction/TransactionRecord":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/TransactionRecord.js","./PaymentErrorHandler":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/PaymentErrorHandler.js","./messageHelper":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/messageHelper.js","./steps/FinalizePaymentStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FinalizePaymentStep.js","./steps/MerchantTakePaymentStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/MerchantTakePaymentStep.js","./steps/ReceiptStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/ReceiptStep.js","./steps/SignatureStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/SignatureStep.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/CreditCardFlow.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _messageHelper = require('./messageHelper');

var _messageHelper2 = _interopRequireDefault(_messageHelper);

var _BaseTransactionFlow2 = require('./BaseTransactionFlow');

var _BaseTransactionFlow3 = _interopRequireDefault(_BaseTransactionFlow2);

var _retailPaymentDevice = require('retail-payment-device');

var _ReadCardStep = require('./steps/ReadCardStep');

var _ReadCardStep2 = _interopRequireDefault(_ReadCardStep);

var _MerchantTakePaymentStep = require('./steps/MerchantTakePaymentStep');

var _MerchantTakePaymentStep2 = _interopRequireDefault(_MerchantTakePaymentStep);

var _SignatureStep = require('./steps/SignatureStep');

var _SignatureStep2 = _interopRequireDefault(_SignatureStep);

var _FinalizePaymentStep = require('./steps/FinalizePaymentStep');

var _FinalizePaymentStep2 = _interopRequireDefault(_FinalizePaymentStep);

var _UpdateInvoicePaymentStep = require('./steps/UpdateInvoicePaymentStep');

var _UpdateInvoicePaymentStep2 = _interopRequireDefault(_UpdateInvoicePaymentStep);

var _RemoveCardStep = require('./steps/RemoveCardStep');

var _RemoveCardStep2 = _interopRequireDefault(_RemoveCardStep);

var _ReceiptStep = require('./steps/ReceiptStep');

var _ReceiptStep2 = _interopRequireDefault(_ReceiptStep);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Steps


var Log = (0, _manticoreLog2.default)('flow.creditCardFlow');

var CreditCardFlow = function (_BaseTransactionFlow) {
  _inherits(CreditCardFlow, _BaseTransactionFlow);

  function CreditCardFlow(card, context, callback) {
    _classCallCheck(this, CreditCardFlow);

    Log.debug('Initializing Credit Flow');

    var _this = _possibleConstructorReturn(this, _BaseTransactionFlow.call(this, card, context, callback));

    _BaseTransactionFlow.prototype.setFlowSteps.call(_this, 'Credit', [_this.stopBatteryPollStep, function addPaymentCancelListeners(flow) {
      if (context.allowInProgressPaymentCancel) {
        this.card.reader.once(_retailPaymentDevice.PaymentDevice.Event.cardRemoved, this.transactionCancelRequested);
        this.card.reader.once(_retailPaymentDevice.PaymentDevice.Event.cancelRequested, this.transactionCancelRequested);
        this.card.reader.once(_retailPaymentDevice.PaymentDevice.Event.disconnected, this.transactionCancelRequested);
        this.card.reader.once(_retailPaymentDevice.PaymentDevice.Event.cancelled, this.transactionCancelled);
      }
      flow.next();
    }, _this.createFlowMessageStep(_messageHelper2.default.showProcessingMessage), new _ReadCardStep2.default(context).flowStep, _this.saveInvoiceStep, _this.createFlowMessageStep(_messageHelper2.default.showAuthMessage), new _MerchantTakePaymentStep2.default(context, _this.voidPaymentIfApplicable).flowStep, new _SignatureStep2.default(context).flowStep, _this.createFlowMessageStep(_messageHelper2.default.showFinalizeMessage), function removePaymentCancelListeners(flow) {
      this._removePaymentCancelListeners();
      flow.next();
    }, new _FinalizePaymentStep2.default(context).flowStep, new _UpdateInvoicePaymentStep2.default(context).flowStep, new _RemoveCardStep2.default(context).flowStep, _this.createFlowMessageStep(_messageHelper2.default.showCompleteMessage)]).addFlowEndedHandler(function () {
      return _this._removePaymentCancelListeners();
    }).setCompletionSteps('Credit-Receipt', [_this.startBatteryPollStep, new _ReceiptStep2.default(_this.context).flowStep]).startFlow();
    return _this;
  }

  CreditCardFlow.prototype._removePaymentCancelListeners = function _removePaymentCancelListeners() {
    var r = this.card.reader;
    if (this.context.allowInProgressPaymentCancel) {
      r.removeListener(_retailPaymentDevice.PaymentDevice.Event.cardRemoved, this.transactionCancelRequested);
      r.removeListener(_retailPaymentDevice.PaymentDevice.Event.cancelRequested, this.transactionCancelRequested);
      r.removeListener(_retailPaymentDevice.PaymentDevice.Event.disconnected, this.transactionCancelRequested);
      r.removeListener(_retailPaymentDevice.PaymentDevice.Event.cancelled, this.transactionCancelled);
    }
  };

  return CreditCardFlow;
}(_BaseTransactionFlow3.default);

exports.default = CreditCardFlow;

},{"./BaseTransactionFlow":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/BaseTransactionFlow.js","./messageHelper":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/messageHelper.js","./steps/FinalizePaymentStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FinalizePaymentStep.js","./steps/MerchantTakePaymentStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/MerchantTakePaymentStep.js","./steps/ReadCardStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/ReadCardStep.js","./steps/ReceiptStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/ReceiptStep.js","./steps/RemoveCardStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/RemoveCardStep.js","./steps/SignatureStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/SignatureStep.js","./steps/UpdateInvoicePaymentStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/UpdateInvoicePaymentStep.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/PaymentErrorHandler.js":[function(require,module,exports){
'use strict';

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _manticore = require('manticore');

var _manticore2 = _interopRequireDefault(_manticore);

var _l10n = require('../common/l10n');

var _l10n2 = _interopRequireDefault(_l10n);

var _sdkErrors = require('../common/sdkErrors');

var _manticoreUtil = require('manticore-util');

var _messageHelper = require('./messageHelper');

var _messageHelper2 = _interopRequireDefault(_messageHelper);

var _retailPaymentDevice = require('retail-payment-device');

var _Merchant = require('../common/Merchant');

var _Merchant2 = _interopRequireDefault(_Merchant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Log = (0, _manticoreLog2.default)('flow.paymentErrorHandler');
var FormFactor = _retailPaymentDevice.PaymentDevice.FormFactor;

/**
 * The PaymentErrorHandler class is responsible for displaying appropriate alerts on the App and terminal based on
 * the errorCode and formFactor properties on the error object.
 */

var PaymentErrorHandler = function () {
  function PaymentErrorHandler(context) {
    var _this = this,
        _nfcHandlersForDevice,
        _insertHandlersForDev,
        _swipeHandlersForDevi,
        _commonHandlersForDev,
        _nfcHandlersForApiErr,
        _insertHandlersForApi,
        _commonHandlersForApi,
        _swipeHandlersForTran,
        _commonHandlersForTra,
        _deviceErrorDomain,
        _sdkErrorDomain$retai,
        _sdkErrorDomain$trans,
        _errorHandlers;

    _classCallCheck(this, PaymentErrorHandler);

    this.context = context;
    this.formattedAmount = _messageHelper2.default.formattedInvoiceTotal(this.context.invoice);
    var action = PaymentErrorHandler.action,
        nfcContactIssuer = void 0,
        insertContactIssuer = void 0;
    var nfcHandlersForDeviceErrors = (_nfcHandlersForDevice = {}, _nfcHandlersForDevice[_retailPaymentDevice.deviceError.nfcTimeout.code] = function (pd, cb) {
      _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.NfcTimeOut, _this.formattedAmount, {
        title: (0, _l10n2.default)('Tx.Alert.TimeOut.Title'),
        message: (0, _l10n2.default)('Tx.Alert.TimeOut.Msg'),
        buttons: [(0, _l10n2.default)('Tx.Retry')],
        cancel: (0, _l10n2.default)('Tx.Alert.TimeOut.Button')
      }, function (a, ix) {
        if (ix === 0) {
          _this.context.promptForPaymentInstrument();
          cb(action.retry);
        } else {
          cb(action.abort);
        }
      });
    }, _nfcHandlersForDevice[_retailPaymentDevice.deviceError.nfcNotAllowed.code] = function (pd, cb) {
      _this._nfcPaymentDeclineErrorHandler(pd, function (performAction) {
        if (performAction === PaymentErrorHandler.action.retryWithInsertOrSwipe) {
          cb(performAction);
        } else {
          cb(action.OfflineDecline);
        }
      });
    }, _nfcHandlersForDevice[_retailPaymentDevice.deviceError.tryDifferentCard.code] = function (pd, cb) {
      _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.UnableToReadNfcCard, _this.formattedAmount, {
        title: (0, _l10n2.default)('Tx.Alert.TapDifferentCard.Title'),
        message: (0, _l10n2.default)('Tx.Alert.TapDifferentCard.Msg'),
        cancel: (0, _l10n2.default)('Ok')
      }, function () {
        _this.context.promptForPaymentInstrument();
        cb(action.retry);
      });
    }, _nfcHandlersForDevice[_retailPaymentDevice.deviceError.contactIssuer.code] = nfcContactIssuer = function nfcContactIssuer(pd, cb) {
      _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.ContactIssuer, _this.formattedAmount, {
        title: (0, _l10n2.default)('Tx.Alert.BlockedCardTapped.Title'),
        message: (0, _l10n2.default)('Tx.Alert.BlockedCardTapped.Msg'),
        cancel: (0, _l10n2.default)('Ok')
      }, function () {
        return cb(action.abort);
      });
    }, _nfcHandlersForDevice[_retailPaymentDevice.deviceError.contactlessPaymentAbortedByCardInsert.code] = PaymentErrorHandler._doNothing, _nfcHandlersForDevice[_retailPaymentDevice.deviceError.contactlessPaymentAbortedByCardSwipe.code] = PaymentErrorHandler._doNothing, _nfcHandlersForDevice);

    var insertHandlersForDeviceErrors = (_insertHandlersForDev = {}, _insertHandlersForDev[_retailPaymentDevice.deviceError.cardBlocked.code] = insertContactIssuer = function insertContactIssuer(pd, cb) {
      pd.once(_retailPaymentDevice.PaymentDevice.Event.cardRemoved, function () {
        _this.alert && _this.alert.dismiss();
        _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.ContactIssuer, null, null, function () {
          return cb(action.abort);
        });
      });

      _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.BlockedCardInserted, _this.formattedAmount, {
        title: (0, _l10n2.default)('Tx.Alert.BlockedCardInserted.Title'),
        message: (0, _l10n2.default)('Tx.Alert.BlockedCardInserted.Msg')
      });
    }, _insertHandlersForDev[_retailPaymentDevice.deviceError.contactIssuer.code] = insertContactIssuer, _insertHandlersForDev[_retailPaymentDevice.deviceError.invalidChip.code] = function (pd, cb) {
      Log.debug(function () {
        return 'Invalid chip card (Attempt: ' + (_this.context.retryCountInvalidChip + 1) + ')';
      });
      if (_this.context.retryCountInvalidChip >= _retailPaymentDevice.PaymentDevice.constant.InvalidChipRetryCount) {
        _this._updateDisplay(null, null, null, {
          title: (0, _l10n2.default)('Tx.Alert.ReadyForSwipeOnly.Title'),
          message: (0, _l10n2.default)('Tx.Alert.ReadyForSwipeOnly.Msg'),
          imageIcon: 'img_emv_swipe',
          cancel: (0, _l10n2.default)('Cancel')
        }, function () {
          return cb(action.abort);
        });
        _this.context.allowFallBackSwipe = true;
        return cb(action.retryWithSwipe);
      }

      _this.context.retryCountInvalidChip += 1;
      pd.once(_retailPaymentDevice.PaymentDevice.Event.cardRemoved, function () {
        _this.context.promptForPaymentInstrument(new Set([FormFactor.MagneticCardSwipe, FormFactor.Chip]));
      });

      _this._updateDisplay(null, null, null, {
        title: (0, _l10n2.default)('Tx.Alert.UnsuccessfulInsert.Title'),
        message: (0, _l10n2.default)('Tx.Alert.UnsuccessfulInsert.Msg')
      });
      cb(action.retryWithInsertOrSwipe);
    }, _insertHandlersForDev);

    var swipeHandlersForDeviceErrors = (_swipeHandlersForDevi = {}, _swipeHandlersForDevi[_retailPaymentDevice.deviceError.contactIssuer.code] = function (pd, cb) {
      _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.ContactIssuer, _this.formattedAmount, {
        title: (0, _l10n2.default)('Tx.Alert.BlockedCardSwiped.Title'),
        message: (0, _l10n2.default)('Tx.Alert.BlockedCardSwiped.Msg'),
        cancel: (0, _l10n2.default)('Ok')
      }, function () {
        return cb(action.abort);
      });
    }, _swipeHandlersForDevi);

    //Handler for errors from payment device that apply to all card presentation types
    var commonHandlersForDeviceErrors = (_commonHandlersForDev = {}, _commonHandlersForDev[_retailPaymentDevice.deviceError.mustSwipeCard.code] = function (pd, cb) {
      _this._mustSwipeCardHandler(pd, cb);
    }, _commonHandlersForDev[_retailPaymentDevice.deviceError.generic.code] = function (pd, cb) {
      _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.TransactionCancelled, _this.formattedAmount, {
        title: (0, _l10n2.default)('Tx.Alert.GenericError.Title'),
        message: (0, _l10n2.default)('Tx.Alert.GenericError.' + (_this.context.isRefund() ? 'RefundMessage' : 'PaymentMessage')),
        cancel: (0, _l10n2.default)('Ok')
      }, function () {
        return cb(action.abort);
      });
    }, _commonHandlersForDev[_retailPaymentDevice.deviceError.paymentCancelled.code] = function (pd, cb) {
      _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.TransactionCancelled, _this.formattedAmount, null, function () {
        return cb(action.abort);
      });
    }, _commonHandlersForDev);

    var nfcHandlersForApiErrors = (_nfcHandlersForApiErr = {}, _nfcHandlersForApiErr[_sdkErrors.retail.nfcPaymentDeclined.code] = function (pd, cb) {
      _this._nfcPaymentDeclineErrorHandler(pd, cb);
    }, _nfcHandlersForApiErr[_sdkErrors.retail.onlinePinMaxRetryExceed.code] = nfcContactIssuer, _nfcHandlersForApiErr[_sdkErrors.retail.contactIssuer.code] = nfcContactIssuer, _nfcHandlersForApiErr);

    var insertHandlersForApiErrors = (_insertHandlersForApi = {}, _insertHandlersForApi[_sdkErrors.retail.contactIssuer.code] = insertContactIssuer, _insertHandlersForApi[_sdkErrors.retail.onlinePinMaxRetryExceed.code] = insertContactIssuer, _insertHandlersForApi);

    var commonHandlersForApiErrors = (_commonHandlersForApi = {}, _commonHandlersForApi[_sdkErrors.retail.incorrectOnlinePin.code] = function (pd, cb) {
      _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.IncorrectPin, _this.formattedAmount, {
        title: (0, _l10n2.default)('Tx.Alert.IncorrectOnlinePin.Title'),
        message: (0, _l10n2.default)('Tx.Alert.IncorrectOnlinePin.Msg'),
        cancel: (0, _l10n2.default)('Ok')
      }, function () {
        _this.context.promptForPaymentInstrument();
        cb(action.retry);
      });
    }, _commonHandlersForApi);

    var swipeHandlersForTransactionErrors = (_swipeHandlersForTran = {}, _swipeHandlersForTran[_sdkErrors.transaction.cannotSwipeChipCard.code] = function (pd, cb) {
      _this._updateDisplay(null, null, null, {
        title: (0, _l10n2.default)('Tx.Alert.ChipCardSwiped.Title'),
        message: (0, _l10n2.default)('Tx.Alert.ChipCardSwiped.Msg'),
        cancel: (0, _l10n2.default)('Ok')
      }, function () {
        _this.context.promptForPaymentInstrument(new Set([FormFactor.Chip]));
      });
      cb(action.retryWithInsert);
    }, _swipeHandlersForTran);

    //Handlers that apply to all form of transactions (insert, tap & swipe)
    var commonHandlersForTransactionErrors = (_commonHandlersForTra = {}, _commonHandlersForTra[_sdkErrors.transaction.mustSwipeCard.code] = function (pd, cb) {
      _this._mustSwipeCardHandler(pd, cb);
    }, _commonHandlersForTra[_sdkErrors.transaction.amountTooLow.code] = function (pd, cb) {
      var allowedMin = _messageHelper2.default.formattedAmount(_this.context.invoice.currency, _Merchant2.default.active.cardSettings.minimum);
      _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.AmountTooLow, allowedMin, {
        title: (0, _l10n2.default)('Tx.Alert.AmountTooLow.Title'),
        message: (0, _l10n2.default)('Tx.Alert.AmountTooLow.Msg', allowedMin),
        cancel: (0, _l10n2.default)('Ok')
      }, function () {
        return cb(action.abort);
      });
    }, _commonHandlersForTra[_sdkErrors.transaction.amountTooHigh.code] = function (pd, cb) {
      var allowedMax = _messageHelper2.default.formattedAmount(_this.context.invoice.currency, _Merchant2.default.active.cardSettings.maximum);
      _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.AmountTooHigh, allowedMax, {
        title: (0, _l10n2.default)('Tx.Alert.AmountTooHigh.Title'),
        message: (0, _l10n2.default)('Tx.Alert.AmountTooHigh.Msg', allowedMax),
        cancel: (0, _l10n2.default)('Ok')
      }, function () {
        return cb(action.abort);
      });
    }, _commonHandlersForTra[_sdkErrors.transaction.customerCancel.code] = function (pd, cb) {
      _this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.TransactionCancelled, _this.formattedAmount, {
        title: (0, _l10n2.default)('Tx.Alert.Cancelled.Title'),
        message: (0, _l10n2.default)('Tx.Alert.Cancelled.Msg'),
        cancel: (0, _l10n2.default)('Ok')
      }, function () {
        return cb(action.abort);
      });
    }, _commonHandlersForTra);

    this.errorHandlers = (_errorHandlers = {}, _errorHandlers[_retailPaymentDevice.errorDomain] = (_deviceErrorDomain = {}, _deviceErrorDomain[FormFactor.None] = commonHandlersForDeviceErrors, _deviceErrorDomain[FormFactor.EmvCertifiedContactless] = (0, _manticoreUtil.extend)(nfcHandlersForDeviceErrors, commonHandlersForDeviceErrors), _deviceErrorDomain[FormFactor.Chip] = (0, _manticoreUtil.extend)(insertHandlersForDeviceErrors, commonHandlersForDeviceErrors), _deviceErrorDomain[FormFactor.MagneticCardSwipe] = (0, _manticoreUtil.extend)(swipeHandlersForDeviceErrors, commonHandlersForDeviceErrors), _deviceErrorDomain), _errorHandlers[_sdkErrors.domain.retail] = (_sdkErrorDomain$retai = {}, _sdkErrorDomain$retai[FormFactor.None] = commonHandlersForApiErrors, _sdkErrorDomain$retai[FormFactor.EmvCertifiedContactless] = (0, _manticoreUtil.extend)(nfcHandlersForApiErrors, commonHandlersForApiErrors), _sdkErrorDomain$retai[FormFactor.Chip] = (0, _manticoreUtil.extend)(insertHandlersForApiErrors, commonHandlersForApiErrors), _sdkErrorDomain$retai[FormFactor.MagneticCardSwipe] = commonHandlersForApiErrors, _sdkErrorDomain$retai), _errorHandlers[_sdkErrors.domain.transaction] = (_sdkErrorDomain$trans = {}, _sdkErrorDomain$trans[FormFactor.None] = commonHandlersForTransactionErrors, _sdkErrorDomain$trans[FormFactor.EmvCertifiedContactless] = commonHandlersForTransactionErrors, _sdkErrorDomain$trans[FormFactor.Chip] = commonHandlersForTransactionErrors, _sdkErrorDomain$trans[FormFactor.MagneticCardSwipe] = (0, _manticoreUtil.extend)(swipeHandlersForTransactionErrors, commonHandlersForTransactionErrors), _sdkErrorDomain$trans), _errorHandlers);
  }

  PaymentErrorHandler._doNothing = function _doNothing(pd, cb) {
    cb(null);
  };

  PaymentErrorHandler.prototype._mustSwipeCardHandler = function _mustSwipeCardHandler(pd, cb) {
    this._updateDisplay(pd, null, null, {
      title: (0, _l10n2.default)('Tx.Alert.ReadyForSwipeOnly.Title'),
      message: (0, _l10n2.default)('Tx.Alert.ReadyForSwipeOnly.Msg'),
      imageIcon: 'img_emv_swipe'
    });
    this.context.allowFallBackSwipe = true;
    cb(PaymentErrorHandler.action.retryWithSwipe);
  };

  PaymentErrorHandler.prototype._nfcPaymentDeclineErrorHandler = function _nfcPaymentDeclineErrorHandler(pd, cb) {
    var _this2 = this;

    this._updateDisplay(pd, _retailPaymentDevice.PaymentDevice.Message.NfcDecline, null, {
      title: (0, _l10n2.default)('Tx.Alert.NfcPaymentDeclined.Title'),
      message: (0, _l10n2.default)('Tx.Alert.NfcPaymentDeclined.Msg'),
      buttons: [(0, _l10n2.default)('Ok')],
      cancel: (0, _l10n2.default)('Cancel')
    }, function (a, ix) {
      if (ix === 0) {
        _this2.context.promptForPaymentInstrument(new Set([FormFactor.Chip, FormFactor.MagneticCardSwipe]));
        cb(PaymentErrorHandler.action.retryWithInsertOrSwipe);
      } else {
        cb(PaymentErrorHandler.action.abort);
      }
    });
  };

  /**
   * Display alerts on the payment device and app
   */


  PaymentErrorHandler.prototype._updateDisplay = function _updateDisplay(pd, deviceMessageId, deviceMessageSubstitutions, alertOptions, cb) {
    var _this3 = this;

    var onDeviceDisplay = function onDeviceDisplay() {
      if (!alertOptions) {
        return cb && cb();
      }
      _this3.alert = _manticore2.default.alert(alertOptions, function (a, ix) {
        _this3.alert && _this3.alert.dismiss();
        cb && cb(a, ix);
      });
    };

    if (pd && deviceMessageId) {
      pd.display(deviceMessageId, deviceMessageSubstitutions, onDeviceDisplay);
    } else {
      onDeviceDisplay();
    }
  };

  /**
   * Handles payment errors by displaying appropriate alerts on the terminal and app side.
   * @param {PayPalError} error
   * @param formFactor
   * @param paymentDevice
   * @param cb Callback to invoke after the error was handled. A single parameter with value action.abort or
   *                  action.retry will be passed to the callback function.
   */


  PaymentErrorHandler.prototype.handle = function handle(error, formFactor, paymentDevice, cb) {
    if (error.domain && formFactor && this.errorHandlers[error.domain] && this.errorHandlers[error.domain][formFactor] && this.errorHandlers[error.domain][formFactor][error.code]) {
      return this.errorHandlers[error.domain][formFactor][error.code](paymentDevice, cb);
    }

    Log.warn('No handlers were defined for domain: ' + error.domain + ' form factor : ' + formFactor + ' and Error code ' + error.code);
    this._updateDisplay(paymentDevice, _retailPaymentDevice.PaymentDevice.Message.TransactionCancelled, this.formattedAmount, {
      title: (0, _l10n2.default)('Tx.Alert.GenericError.Title'),
      message: (0, _l10n2.default)('Tx.Alert.GenericError.' + (this.context.isRefund() ? 'RefundMessage' : 'PaymentMessage')),
      cancel: (0, _l10n2.default)('Ok')
    }, function () {
      return cb(PaymentErrorHandler.action.abort);
    });
  };

  return PaymentErrorHandler;
}();

/**
 * Contains the list of actions PaymentErrorHandler class could request the caller of Handle function to perform
 * @type {{Abort: string, Retry: string}}
 * @private
 */


PaymentErrorHandler.action = {
  OfflineDecline: 'OfflineDecline',
  abort: 'abort',
  retry: 'retry',
  retryWithInsertOrSwipe: 'retryWithInsertOrSwipe',
  retryWithInsert: 'retryWithInsert',
  retryWithSwipe: 'retryWithSwipe'
};

module.exports = PaymentErrorHandler;

},{"../common/Merchant":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Merchant.js","../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../common/sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","./messageHelper":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/messageHelper.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","manticore-util":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/TransactionCancelFlow.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _flow = require('../common/flow');

var _flow2 = _interopRequireDefault(_flow);

var _messageHelper = require('./messageHelper');

var _messageHelper2 = _interopRequireDefault(_messageHelper);

var _ReceiptStep = require('./steps/ReceiptStep');

var _ReceiptStep2 = _interopRequireDefault(_ReceiptStep);

var _l10n = require('../common/l10n');

var _l10n2 = _interopRequireDefault(_l10n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Log = (0, _manticoreLog2.default)('flow.transactionCancelFlow');

var TransactionCancelFlow = function TransactionCancelFlow(card, context, callback) {
  _classCallCheck(this, TransactionCancelFlow);

  Log.debug('Initializing Transaction Cancel Flow');
  var error = { message: (0, _l10n2.default)('Tx.TransactionFailed') };
  var cancelAlert = void 0;
  this.cancellationFlow = new _flow2.default(this, [function showCancellationMessage(flow) {
    _messageHelper2.default.showCancellationMessage(context, flow, function (alert) {
      cancelAlert = alert;
      flow.next();
    });
  }, function saveInvoiceStep(flow) {
    context.invoice.save(function (err) {
      if (err) {
        Log.error('Unable to save invoice. Error: ' + err + '\n' + JSON.stringify(context.invoice, null, 4)); // eslint-disable-line max-len
        context.end(err, null);
        return flow.abortFlow(err);
      }
      cancelAlert.dismiss();
      flow.next();
    });
  }, new _ReceiptStep2.default(context).flowStep]);

  this.cancellationFlow.data = { error: error };
  this.cancellationFlow.on('ended', function (data) {
    return callback(data);
  });
  this.cancellationFlow.start();
};

exports.default = TransactionCancelFlow;

},{"../common/flow":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/flow.js","../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","./messageHelper":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/messageHelper.js","./steps/ReceiptStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/ReceiptStep.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/messageHelper.js":[function(require,module,exports){
'use strict';

var manticore = require('manticore'),
    Log = require('manticore-log')('flow.messageHelper'),
    l10n = require('../common/l10n'),
    Currency = require('paypal-invoicing').Currency,
    PaymentDevice = require('retail-payment-device').PaymentDevice;

// Local helper methods.
function formattedInvoiceTotal(invoice) {
    return formattedAmount(invoice.currency, invoice.total);
}

function formattedAmount(currency, total) {
    return {
        amount: Currency.format(currency, total)
    };
}

function displayOrReuseAlert(flowData, options) {
    flowData.alert = manticore.alert(options, function () {});
    return flowData.alert;
}

function readerDisplay(context, messageId, values, cb, displaySystemIcons) {
    if (context.card && context.card.reader) {
        context.card.reader.display(messageId, values, cb, displaySystemIcons);
    } else {
        cb();
    }
}

function showSimpleMessage(title, message, showActivity, flowData) {
    return displayOrReuseAlert(flowData, {
        title: title,
        message: message,
        showActivity: showActivity,
        replace: true
    });
}

// Exposed interface.
module.exports.showSimpleMessage = showSimpleMessage;
module.exports.formattedInvoiceTotal = formattedInvoiceTotal;
module.exports.formattedAmount = formattedAmount;
module.exports.showProcessingMessage = function (context, flowData, cb) {
    var _processingKeys;

    var alertOptions = {
        title: l10n('EMV.Processing'),
        showActivity: true,
        replace: true,
        audio: {
            file: 'success_card_read.mp3'
        }
    };

    if (context.card && context.card.formFactor === PaymentDevice.FormFactor.Chip) {
        alertOptions.message = l10n('EMV.DoNotRemove');
    }

    var alert = manticore.alert(alertOptions, function () {});
    flowData.alert = alert;

    // TODO: Add more keys here when they become available/needed.
    var processingKeys = (_processingKeys = {}, _processingKeys[PaymentDevice.FormFactor.Chip] = PaymentDevice.Message.ProcessingContact, _processingKeys);

    var messageId = context.card && processingKeys[context.card.formFactor] || PaymentDevice.Message.Processing;
    readerDisplay(context, messageId, formattedInvoiceTotal(context.invoice), function () {
        return cb(alert);
    });
};

module.exports.showEnterPinMessage = function (context, flowData, cb) {
    var message = context.card && context.card.formFactor === PaymentDevice.FormFactor.Chip ? l10n('EMV.DoNotRemove') : null;
    return cb(showSimpleMessage(l10n('Tx.Alert.EnterPin.Title'), message, true, flowData));
};

module.exports.showProcessingWithPinMessage = function (context, flowData, cb) {
    readerDisplay(context, PaymentDevice.Message.ProcessingWithPin, null, cb);
};

module.exports.showAuthMessage = function (context, flowData, cb) {
    return cb(showSimpleMessage(l10n('EMV.Auth'), null, true, flowData));
};

module.exports.showCancellationMessage = function (context, flowData, cb) {
    var alert = showSimpleMessage(l10n('EMV.Cancelling'), null, true, flowData);
    readerDisplay(context, PaymentDevice.Message.TransactionCancelling, null, function () {
        return cb(alert);
    });
};

module.exports.showFinalizeMessage = function (context, flowData, cb) {
    var alert = showSimpleMessage(l10n('EMV.Finalize'), null, true, flowData);
    var formattedAmount = formattedInvoiceTotal(context.invoice);
    readerDisplay(context, PaymentDevice.Message.CompletingPayment, formattedAmount, function () {
        return cb(alert);
    });
};

module.exports.showRefundProcessingMessage = function (context, flowData, cb) {
    return cb(showSimpleMessage(l10n('EMV.ProcessingRefund'), null, true, flowData));
};

module.exports.showRemoveCardMessage = function (context, flowData, cb) {
    var formattedAmount = formattedInvoiceTotal(context.invoice),
        title = 'EMV.Complete',
        messageId = PaymentDevice.Message.PaidRemoveCard;

    if (context.isRefund()) {
        title = 'EMV.RefundComplete';
        messageId = PaymentDevice.Message.RefundRemoveCard;
    }

    var alert = showSimpleMessage(l10n(title, formattedAmount), l10n('EMV.Remove'), false, flowData);

    // TODO Remove the cb parameter in this and showAuthMessage, showFinalizeMessage functions after device EMV device display method
    // is updated to not require a cb
    readerDisplay(context, messageId, formattedAmount, function () {
        return cb(alert);
    });
};

module.exports.showCompleteMessage = function (context, flowData, cb) {
    var formattedAmount = formattedInvoiceTotal(context.invoice),
        msgId = context.isRefund() ? PaymentDevice.Message.Refund : PaymentDevice.Message.Paid;
    readerDisplay(context, msgId, formattedAmount, function () {
        return cb(flowData);
    });
};

module.exports.showSelectApplicationPrompt = function (context, flowData, applicationPairs, cb) {
    var buttons = [];
    for (var _iterator = applicationPairs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
        }

        var app = _ref;

        buttons.push(app[1] || app[0]);
    }

    flowData.alert = manticore.alert({
        title: l10n('EMV.Select'),
        buttons: buttons
    }, function (error, ix) {
        var applicationId = applicationPairs[ix][0],
            applicationName = applicationPairs[ix][1];
        cb && cb(applicationId, applicationName);
    });

    return flowData.alert;
};

},{"../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","paypal-invoicing":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/refundFlow.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _manticore = require('manticore');

var _manticore2 = _interopRequireDefault(_manticore);

var _messageHelper = require('./messageHelper');

var _messageHelper2 = _interopRequireDefault(_messageHelper);

var _UpdateInvoicePaymentStep = require('./steps/UpdateInvoicePaymentStep');

var _UpdateInvoicePaymentStep2 = _interopRequireDefault(_UpdateInvoicePaymentStep);

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _BaseTransactionFlow2 = require('./BaseTransactionFlow');

var _BaseTransactionFlow3 = _interopRequireDefault(_BaseTransactionFlow2);

var _retailPaymentDevice = require('retail-payment-device');

var _ReadCardStep = require('./steps/ReadCardStep');

var _ReadCardStep2 = _interopRequireDefault(_ReadCardStep);

var _CheckRefundEligibilityStep = require('./steps/CheckRefundEligibilityStep');

var _CheckRefundEligibilityStep2 = _interopRequireDefault(_CheckRefundEligibilityStep);

var _IssueRefundStep = require('./steps/IssueRefundStep');

var _IssueRefundStep2 = _interopRequireDefault(_IssueRefundStep);

var _RemoveCardStep = require('./steps/RemoveCardStep');

var _RemoveCardStep2 = _interopRequireDefault(_RemoveCardStep);

var _ReceiptStep = require('./steps/ReceiptStep');

var _ReceiptStep2 = _interopRequireDefault(_ReceiptStep);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = (0, _manticoreLog2.default)('flow.refundFlow');

var RefundFlow = function (_BaseTransactionFlow) {
  _inherits(RefundFlow, _BaseTransactionFlow);

  function RefundFlow(card, context, callback) {
    _classCallCheck(this, RefundFlow);

    Log.debug('Initializing Refund Flow');

    var _this = _possibleConstructorReturn(this, _BaseTransactionFlow.call(this, card, context, callback));

    _BaseTransactionFlow.prototype.setFlowSteps.call(_this, 'Refund', [_this.stopBatteryPollStep, function addPaymentCancelListeners(flow) {
      if (this.card) {
        this.card.reader.once(_retailPaymentDevice.PaymentDevice.Event.cardRemoved, this.transactionCancelRequested);
        this.card.reader.once(_retailPaymentDevice.PaymentDevice.Event.cancelRequested, this.transactionCancelRequested);
        this.card.reader.once(_retailPaymentDevice.PaymentDevice.Event.cancelled, this.transactionCancelled);
      }
      flow.next();
    }, _this.createFlowMessageStep(_messageHelper2.default.showProcessingMessage), new _ReadCardStep2.default(context).flowStep, function endTransactionOnTerminal(flow) {
      if (this.card) {
        this.card.reader.abortTransaction(function () {
          flow.next();
        });
      } else {
        flow.next();
      }
    }, new _CheckRefundEligibilityStep2.default(context).flowStep, _this.createFlowMessageStep(_messageHelper2.default.showRefundProcessingMessage), function removePaymentCancelListeners(flow) {
      this._removePaymentCancelListeners();
      flow.next();
    }, new _IssueRefundStep2.default(context).flowStep, new _UpdateInvoicePaymentStep2.default(context).flowStep, new _RemoveCardStep2.default(context).flowStep, _this.createFlowMessageStep(_messageHelper2.default.showCompleteMessage)]).addFlowEndedHandler(function () {
      return _this._removePaymentCancelListeners();
    }).setCompletionSteps('Refund-Receipt', [_this.startBatteryPollStep, new _ReceiptStep2.default(_this.context).flowStep]);

    var paymentToRefund = context.invoice.payments && context.invoice.payments[0];
    if (paymentToRefund) {
      _this.flow.data.transactionNumber = paymentToRefund.transactionID;
      _this.flow.data.amount = paymentToRefund.amount;
    }

    _this.startFlow();
    return _this;
  }

  RefundFlow.prototype._removePaymentCancelListeners = function _removePaymentCancelListeners() {
    if (this.card) {
      this.card.reader.removeListener(_retailPaymentDevice.PaymentDevice.Event.cardRemoved, this.transactionCancelRequested);
      this.card.reader.removeListener(_retailPaymentDevice.PaymentDevice.Event.cancelRequested, this.transactionCancelRequested);
      this.card.reader.removeListener(_retailPaymentDevice.PaymentDevice.Event.cancelled, this.transactionCancelled);
    }
  };

  return RefundFlow;
}(_BaseTransactionFlow3.default);

exports.default = RefundFlow;

},{"./BaseTransactionFlow":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/BaseTransactionFlow.js","./messageHelper":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/messageHelper.js","./steps/CheckRefundEligibilityStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/CheckRefundEligibilityStep.js","./steps/IssueRefundStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/IssueRefundStep.js","./steps/ReadCardStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/ReadCardStep.js","./steps/ReceiptStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/ReceiptStep.js","./steps/RemoveCardStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/RemoveCardStep.js","./steps/UpdateInvoicePaymentStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/UpdateInvoicePaymentStep.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/CheckRefundEligibilityStep.js":[function(require,module,exports){
'use strict';

var _sdkErrors = require('../../common/sdkErrors');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = require('manticore-log')('flow.step.checkRefundEligiblity'),
    l10n = require('../../common/l10n'),
    FlowStep = require('./FlowStep'),
    moment = require('moment'),
    RetailSDKUtil = require('../../common/RetailSDKUtil.js');

var CheckRefundEligibilityFlowStep = function (_FlowStep) {
    _inherits(CheckRefundEligibilityFlowStep, _FlowStep);

    function CheckRefundEligibilityFlowStep(context) {
        _classCallCheck(this, CheckRefundEligibilityFlowStep);

        var _this = _possibleConstructorReturn(this, _FlowStep.call(this));

        _this.context = context;
        return _this;
    }

    CheckRefundEligibilityFlowStep.prototype.execute = function execute(flow) {
        if (!this.context.card) {
            return flow.next();
        }

        if (flow.data.error) {
            Log.warn('Skip Issuing refund. Reason: One/more of previous steps logged an error');
            return flow.next();
        }

        var merchant = this.context.merchant;
        var rq = this._buildRequest(flow);
        merchant.request({
            service: 'retail',
            op: 'pay/' + flow.data.transactionNumber + '/validateCard',
            format: 'json',
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(rq)
        }, function (error, refundResponse) {
            if (!error && refundResponse.body && refundResponse.body.status !== 'ELIGIBLE') {
                error = (0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.refundCardMismatch);
            }

            flow.nextOrAbort(error);
        });
    };

    CheckRefundEligibilityFlowStep.prototype._buildRequest = function _buildRequest(flow) {
        var request = {
            invoiceId: this.context.invoice.payPalId,
            dateTime: moment().format('YYYY-MM-DDTHH:mm:ssZZ'),
            card: RetailSDKUtil.hereAPICardDataFromCard(this.context.card)
        };

        return request;
    };

    return CheckRefundEligibilityFlowStep;
}(FlowStep);

module.exports = CheckRefundEligibilityFlowStep;

},{"../../common/RetailSDKUtil.js":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/RetailSDKUtil.js","../../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../../common/sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","./FlowStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FlowStep.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","moment":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/moment/moment.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FinalizePaymentStep.js":[function(require,module,exports){
'use strict';

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _sdkErrors = require('../../common/sdkErrors');

var _FlowStep2 = require('./FlowStep');

var _FlowStep3 = _interopRequireDefault(_FlowStep2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = (0, _manticoreLog2.default)('flow.step.finalizePayment');

var FinalizePaymentStep = function (_FlowStep) {
    _inherits(FinalizePaymentStep, _FlowStep);

    function FinalizePaymentStep(context) {
        _classCallCheck(this, FinalizePaymentStep);

        var _this = _possibleConstructorReturn(this, _FlowStep.call(this));

        _this.context = context;
        _this.isContaclessMSDTransaction = context.card.isContactlessMSD;
        return _this;
    }

    FinalizePaymentStep.prototype.execute = function execute(flow) {
        var _this2 = this;

        if (flow.data.error) {
            Log.warn('Skipping Finalize payment. Reason: One/more of previous steps logged an error');
            return flow.next();
        }

        if (!flow.data.signature) {
            if (!flow.data.cardResponse || this.isContaclessMSDTransaction) {
                Log.debug('Skipping Finalize payment');
                return flow.next();
            }
        }
        var merch = this.context.merchant;
        var rq = this.buildRequest(flow);

        Log.debug('MFT request:\n' + JSON.stringify(rq, null, 4));
        merch.request({
            service: 'retail',
            op: 'payment/' + (flow.data.tx.transactionNumber || flow.data.tx.transactionHandle),
            format: 'json',
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(rq)
        }, function (error, finalizeRz) {
            Log.debug('MFT response:\n' + JSON.stringify(finalizeRz, null, '\t') + '\n');
            if (!finalizeRz || error) {
                Log.error('MFT Error: ' + JSON.stringify(error) + ', Invoice Total: ' + _this2.context.invoice.currency + (_this2.context.invoice.total + '\n ' + JSON.stringify(finalizeRz)));
                error = error || (0, _sdkErrors.getError)(new Error(), _sdkErrors.network.requestFailed);
                return flow.abortFlow(error);
            }

            flow.data.tx.updateFromFinalize(finalizeRz.body);
            Log.info('MFT response received for invoice total: ' + _this2.context.invoice.currency + ' ' + _this2.context.invoice.total + ',' + ('formFactor: ' + _this2.context.card.formFactor + ', ' + flow.data.tx.toString()));

            flow.next();
        });
    };

    FinalizePaymentStep.prototype.buildRequest = function buildRequest(flow) {
        // TODO get the signature if available...
        var rq = {
            invoiceId: this.context.invoice.payPalId
        };
        //For contactless msd transactions, we should not be sending the emv data. Otherwise, the backend would throw an invoice already paid error.
        if (flow.data.cardResponse && !this.isContaclessMSDTransaction) {
            rq.emvData = flow.data.cardResponse.apdu.data.toString('hex');
            rq.responseCode = flow.data.tx.responseCode;
        }
        if (flow.data.signature) {
            rq.signature = flow.data.signature.toString('utf-8');
        }
        return rq;
    };

    return FinalizePaymentStep;
}(_FlowStep3.default);

module.exports = FinalizePaymentStep;

},{"../../common/sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","./FlowStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FlowStep.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FlowStep.js":[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FlowStep = function () {
    function FlowStep() {
        _classCallCheck(this, FlowStep);
    }

    FlowStep.prototype.execute = function execute() {
        throw new Error('FlowStep must define execute method.');
    };

    _createClass(FlowStep, [{
        key: 'flowStep',
        get: function get() {
            var self = this;
            var stepFn = function stepFn(flow) {
                self.execute(flow);
            };
            stepFn.fnName = this.constructor.name;
            return stepFn;
        }
    }]);

    return FlowStep;
}();

module.exports = FlowStep;

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/IssueRefundStep.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = require('manticore-log')('flow.step.issueRefund'),
    l10n = require('../../common/l10n'),
    FlowStep = require('./FlowStep'),
    TransactionRecord = require('../../transaction/TransactionRecord');

var IssueRefundStep = function (_FlowStep) {
    _inherits(IssueRefundStep, _FlowStep);

    function IssueRefundStep(context) {
        _classCallCheck(this, IssueRefundStep);

        var _this = _possibleConstructorReturn(this, _FlowStep.call(this));

        _this.context = context;
        return _this;
    }

    IssueRefundStep.prototype.execute = function execute(flow) {
        var _this2 = this;

        if (flow.data.error) {
            Log.warn('Skip Issuing refund. Reason: One/more of previous steps logged an error');
            return flow.next();
        }

        if (!flow.data.transactionNumber) {
            Log.error('No transaction transactionNumber found. Aborting.');
            return flow.abortFlow();
        }

        Log.info('Issuing refund for transaction number: ' + flow.data.transactionNumber + ', amount: ' + this.context.refundAmount);
        var merchant = this.context.merchant;
        var rq = this._buildRequest(flow, merchant);
        merchant.request({
            service: 'payments',
            op: 'sale/' + flow.data.transactionNumber + '/refund',
            format: 'json',
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(rq)
        }, function (error, refundRz) {
            _this2._processResult(flow, error, refundRz);
        });
    };

    IssueRefundStep.prototype._buildRequest = function _buildRequest(flow, merchant) {
        var rb = {
            is_non_platform_transaction: 'YES'
        };

        if (this.context.refundAmount) {
            rb.amount = {
                total: this.context.refundAmount,
                currency: merchant.currency
            };
        }
        return rb;
    };

    IssueRefundStep.prototype._processResult = function _processResult(flow, error, refundRz) {

        if (refundRz && refundRz.body) {
            flow.data.tx = new TransactionRecord(refundRz.body);
        }

        if (error) {
            error.message = l10n('Tx.RefundFailed');
        }
        flow.nextOrAbort(error);
    };

    return IssueRefundStep;
}(FlowStep);

module.exports = IssueRefundStep;

},{"../../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../../transaction/TransactionRecord":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/TransactionRecord.js","./FlowStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FlowStep.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/MerchantTakePaymentStep.js":[function(require,module,exports){
'use strict';

var _sdkErrors = require('../../common/sdkErrors');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = require('manticore-log')('flow.step.merchantTakePayment'),
    l10n = require('../../common/l10n'),
    FlowStep = require('./FlowStep'),
    TransactionRecord = require('../../transaction/TransactionRecord'),
    PaymentDevice = require('retail-payment-device').PaymentDevice,
    FormFactor = PaymentDevice.FormFactor,
    AuthCode = PaymentDevice.authCode,
    RetailSDKUtil = require('../../common/RetailSDKUtil.js');

var MerchantTakePaymentStep = function (_FlowStep) {
    _inherits(MerchantTakePaymentStep, _FlowStep);

    function MerchantTakePaymentStep(context, voidFunc) {
        _classCallCheck(this, MerchantTakePaymentStep);

        var _this = _possibleConstructorReturn(this, _FlowStep.call(this));

        _this.context = context;
        _this.instrument = context.card;
        _this.voidFunc = voidFunc;
        return _this;
    }

    MerchantTakePaymentStep.prototype.execute = function execute(flow) {
        var _this2 = this;

        var merch = this.context.merchant;
        var rq = this.buildRequest(flow);
        Log.debug(function () {
            return 'MTP request :\n' + JSON.stringify(rq, null, 4);
        });
        merch.request({
            service: 'retail',
            op: 'payment',
            format: 'json',
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(rq)
        }, function (mtpError, mtpRz) {
            flow.data.tx = mtpRz && mtpRz.body ? new TransactionRecord(mtpRz.body) : {};
            var mtpRzAuthCode = mtpRz && mtpRz.body && mtpRz.body.authCode && mtpRz.body.authCode !== 'null' ? mtpRz.body.authCode : null,
                isEmv = rq && rq.card && rq.card.emvData && (_this2.instrument.formFactor === FormFactor.Chip || _this2.instrument.formFactor === FormFactor.EmvCertifiedContactless);

            Log.debug(function () {
                return 'MTP response: ' + JSON.stringify(mtpRz, null, 4);
            });
            if (mtpError) {
                Log.error('MPT Error: ' + JSON.stringify(mtpError) + ', isEmv: ' + isEmv + ', formFactor: ' + _this2.instrument.formFactor + ',' + ('Invoice Total: ' + _this2.context.invoice.currency + ' ' + _this2.context.invoice.total + ',') + ('rz.statusCode: ' + mtpRz.statusCode + ', rz.body: ' + JSON.stringify(mtpRz.body)));
            } else {
                Log.info('MTP response received for invoice total: ' + _this2.context.invoice.currency + ' ' + _this2.context.invoice.total + ',' + ('formFactor: ' + _this2.instrument.formFactor + ', AuthCode: ' + (mtpRz && mtpRz.body && mtpRz.body.authCode) + ',') + ('' + flow.data.tx.toString()));
            }

            _this2._processResult(isEmv, mtpRzAuthCode, flow, mtpError);
        });
    };

    MerchantTakePaymentStep.prototype._processResult = function _processResult(isEmv, rzAuthCode, flow, mtpError) {
        var _this3 = this;

        var cbStepComplete = function cbStepComplete(error, rz) {
            flow.data.cardResponse = rz;

            // If we encountered an error while waiting on an MTP response and it eventually succeeded then we need to void.
            if (flow.data.error) {
                Log.info('Voiding tx as flow was aborted when MTP request was in flight with error: ' + JSON.stringify(flow.data.error));
                return _this3.voidFunc && _this3.voidFunc(flow.data);
            }

            flow.nextOrAbort(mtpError || error);
        };

        if (isEmv) {
            // For EMV, even if we don't get an auth code from the server, we need to make one so the card
            // can function correctly. So if we got an error, we can assume failure.
            // TODO really, we want to assume success?
            if (rzAuthCode) {
                // Before we go to the next step in the flow for EMV, we need to tell the card what we got from MTP
                flow.data.tx.authCode = rzAuthCode;
            } else {
                flow.data.tx.authCode = AuthCode.TransactionSuccess;
                if (mtpError) {
                    flow.data.tx.authCode = mtpError.code === _sdkErrors.network.networkOffline.code ? AuthCode.NoNetwork : AuthCode.TransactionFailure;
                }
            }
            this._pushAuthCode(flow.data.tx.authCode, cbStepComplete);
        } else {
            cbStepComplete(null, null);
        }
    };

    MerchantTakePaymentStep.prototype._pushAuthCode = function _pushAuthCode(authCode, cb) {
        var _this4 = this;

        // Before we go to the next step in the flow for EMV, we need to tell the card what we got from MTP
        Log.debug('Pushing authCode : ' + authCode + ' to ' + this.instrument.reader.id);
        this.instrument.reader.completeTransaction(authCode, function (error, rz) {
            if (error) {
                Log.error('Error response on pushing auth code to terminal');
                return cb(error, rz);
            }
            Log.info('Pushed auth code (' + authCode + ') to reader ' + _this4.instrument.reader.id + '. Response template: ' + (rz.apdu ? rz.apdu.template : ''));
            cb(null, rz);
        });
    };

    MerchantTakePaymentStep.prototype.buildRequest = function buildRequest(flow) {
        var card = RetailSDKUtil.hereAPICardDataFromCard(this.instrument);

        if (this.instrument.formFactor !== FormFactor.MagneticCardSwipe) {
            card.pinPresent = !!flow.data.pinPresent;
        }

        card.signatureRequired = this.instrument.isSignatureRequired;

        return {
            invoiceId: this.context.invoice.payPalId,
            paymentType: 'card',
            dateTime: this.instrument.timestamp || 'MISSING',
            card: card
        };
    };

    return MerchantTakePaymentStep;
}(FlowStep);

module.exports = MerchantTakePaymentStep;

},{"../../common/RetailSDKUtil.js":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/RetailSDKUtil.js","../../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../../common/sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","../../transaction/TransactionRecord":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/TransactionRecord.js","./FlowStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FlowStep.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/ReadCardStep.js":[function(require,module,exports){
'use strict';

var _retailPaymentDevice = require('retail-payment-device');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = require('manticore-log')('flow.step.readCard'),
    l10n = require('../../common/l10n'),
    FlowStep = require('./FlowStep'),
    Utils = require('manticore-util'),
    messageHelper = require('../messageHelper.js');

/**
 * The read card flow kicks off the EMV transaction with the terminal and waits for
 * "authorization required"
 */

var ReadCardStep = function (_FlowStep) {
    _inherits(ReadCardStep, _FlowStep);

    function ReadCardStep(context) {
        _classCallCheck(this, ReadCardStep);

        var _this = _possibleConstructorReturn(this, _FlowStep.call(this));

        _this.context = context;
        return _this;
    }

    ReadCardStep.prototype.execute = function execute(flow) {
        var _this2 = this;

        var card = this.context.card;
        if (!card || card.formFactor !== _retailPaymentDevice.PaymentDevice.FormFactor.Chip) {
            return flow.next();
        }

        this.pinEventListener = function (result) {
            return _this2._pinEventListener(flow, result);
        };
        this.readCardErrorHandler = function (error) {
            return _this2._readCardErrorHandler(flow, error);
        };
        this.cardDataReadListener = function (error, result) {
            return _this2._cardDataReadListener(flow, error, result);
        };
        this.decisionRequiredListener = function (error, result) {
            return _this2._decisionRequiredListener(flow, error, result);
        };
        this.offlineApprovalListener = function (error, result) {
            return _this2._offlineApprovalListener(flow, error, result);
        };

        card.reader.on(_retailPaymentDevice.PaymentDevice.Event.pinEvent, this.pinEventListener);
        card.reader.once(_retailPaymentDevice.PaymentDevice.Event.error, this.readCardErrorHandler);
        card.reader.once(_retailPaymentDevice.PaymentDevice.Event.cardDataRead, this.cardDataReadListener);
        card.reader.once(_retailPaymentDevice.PaymentDevice.Event.decisionRequired, this.decisionRequiredListener);
        card.reader.once(_retailPaymentDevice.PaymentDevice.Event.approval, this.offlineApprovalListener);
        card.reader.startContactTransaction(this.context);
    };

    ReadCardStep.prototype._readCardErrorHandler = function _readCardErrorHandler(flow, err) {
        Log.error('Read card flow Error: \'' + err.code + '\' Device: ' + this.context.card.reader.id);
        this.removeListenersAndContinueOrAbort(flow, err);
    };

    ReadCardStep.prototype._offlineApprovalListener = function _offlineApprovalListener(flow, err, result) {
        var _this3 = this;

        messageHelper.showProcessingMessage(this.context, flow.data, function () {
            _this3._cardDataReadListener(flow, null, result);
        });
    };

    ReadCardStep.prototype._pinEventListener = function _pinEventListener(flow, result) {
        if (result.correct) {
            flow.data.pinPresent = true;
            Log.debug(function () {
                return 'Correct Pin';
            });
        } else if (result.digits === 0) {
            Log.debug(function () {
                return 'Pin Required';
            });
            messageHelper.showEnterPinMessage(this.context, flow.data, function () {});
            Log.debug(function () {
                return 'Pin Required message displayed.';
            });
        } else if (result.failureReason) {
            Log.debug(function () {
                return 'Pin fail- ' + result.failureReason;
            });
            //ToDo- Add retry count logic
        }
    };

    ReadCardStep.prototype._decisionRequiredListener = function _decisionRequiredListener(flow, err, result) {
        var _this4 = this;

        if (err) {
            Log.error('Failed to start ICC transaction: ' + err);
            this.removeListenersAndContinueOrAbort(flow, err);
        }

        messageHelper.showSelectApplicationPrompt(this.context, flow.data, result.apps, function (applicationId, applicationName) {
            Log.debug(function () {
                return 'Selected application ' + applicationName;
            });
            messageHelper.showProcessingMessage(_this4.context, flow.data, function () {
                _this4.context.card.reader.terminal.selectApplication(applicationId, function (selectError, selectResponse) {
                    if (selectError) {
                        Log.error('Failed to select payment application with error ' + selectError);
                        _this4.removeListenersAndContinueOrAbort(flow, selectError);
                    } else {
                        _this4._cardDataReadListener(flow, null, selectResponse);
                    }
                });
            });
        });
    };

    ReadCardStep.prototype._cardDataReadListener = function _cardDataReadListener(flow, err, result) {
        var _this5 = this;

        Log.debug(function () {
            return 'ICC ' + result;
        });
        if (err) {
            Log.error('Failed to start ICC transaction: ' + err);
            return this.removeListenersAndContinueOrAbort(flow, err);
        }

        Utils.extend(this.context.card, this.context.card.reader.parseCardData(this.context.card, result));
        if (flow.data.pinPresent) {
            messageHelper.showProcessingWithPinMessage(this.context, flow.data, function () {
                _this5.removeListenersAndContinueOrAbort(flow);
            });
        } else {
            this.removeListenersAndContinueOrAbort(flow);
        }
    };

    ReadCardStep.prototype.removeListenersAndContinueOrAbort = function removeListenersAndContinueOrAbort(flow, error) {
        this.removeListeners();
        flow.nextOrAbort(error);
    };

    ReadCardStep.prototype.removeListeners = function removeListeners() {
        var card = this.context.card;
        card.reader.removeListener(_retailPaymentDevice.PaymentDevice.Event.pinEvent, this.pinEventListener);
        card.reader.removeListener(_retailPaymentDevice.PaymentDevice.Event.error, this.readCardErrorHandler);
        card.reader.removeListener(_retailPaymentDevice.PaymentDevice.Event.cardDataRead, this.cardDataReadListener);
        card.reader.removeListener(_retailPaymentDevice.PaymentDevice.Event.decisionRequired, this.decisionRequiredListener);
        card.reader.removeListener(_retailPaymentDevice.PaymentDevice.Event.approval, this.offlineApprovalListener);
    };

    return ReadCardStep;
}(FlowStep);

module.exports = ReadCardStep;

},{"../../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../messageHelper.js":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/messageHelper.js","./FlowStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FlowStep.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","manticore-util":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/ReceiptStep.js":[function(require,module,exports){
'use strict';

var _TransactionContext = require('../../transaction/TransactionContext');

var _TransactionContext2 = _interopRequireDefault(_TransactionContext);

var _retailPaymentDevice = require('retail-payment-device');

var _ReceiptViewContent = require('../../transaction/ReceiptViewContent');

var _manticore = require('manticore');

var _manticore2 = _interopRequireDefault(_manticore);

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _l10n = require('../../common/l10n');

var _l10n2 = _interopRequireDefault(_l10n);

var _paypalInvoicing = require('paypal-invoicing');

var _Merchant = require('../../common/Merchant');

var _Merchant2 = _interopRequireDefault(_Merchant);

var _FlowStep2 = require('./FlowStep');

var _FlowStep3 = _interopRequireDefault(_FlowStep2);

var _transactionEvent = require('../../transaction/transactionEvent');

var _transactionEvent2 = _interopRequireDefault(_transactionEvent);

var _RetailSDKUtil = require('../../common/RetailSDKUtil');

var _RetailSDKUtil2 = _interopRequireDefault(_RetailSDKUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = (0, _manticoreLog2.default)('flow.step.receipt');

var ReceiptStep = function (_FlowStep) {
  _inherits(ReceiptStep, _FlowStep);

  function ReceiptStep(context) {
    _classCallCheck(this, ReceiptStep);

    var _this = _possibleConstructorReturn(this, _FlowStep.call(this));

    _this.context = context;
    return _this;
  }

  ReceiptStep.prototype.execute = function execute(flow) {
    var _this2 = this;

    var invoice = this.context.invoice,
        tx = flow.data.tx,
        error = flow.data.error,
        currency = _paypalInvoicing.Currency.getCurrency(invoice.currency),
        amount = currency.format(this.context.refundAmount || invoice.total),
        viewContent = new _ReceiptViewContent.ReceiptViewContent(amount, this.context.isRefund(), error, tx && tx.payer && tx.payer.maskedEmail, tx && tx.payer && tx.payer.maskedPhone, this.context.additionalReceiptOptions);

    if (flow.data.alert) {
      flow.data.alert.dismiss();
      delete flow.data.alert;
    }

    _manticore2.default.offerReceipt({
      invoice: invoice,
      error: flow.data.error,
      viewContent: viewContent
    }, function (err, option) {
      if (option) {
        if (option.name === 'emailOrSms') {
          _this2._sendReceipt(flow, option.value, invoice, tx);
        } else {
          Log.debug(function () {
            return 'Custom receipt option selected ' + option.value + ':' + option.name;
          });
          _this2.context.emit(_transactionEvent2.default.additionalReceiptOptionSelected, option.value, option.name);
          flow.next();
        }
      } else {
        Log.debug(function () {
          return 'Email/SMS receipt forwarding not required. Skipping receipt step. Native response: ' + option;
        });
        flow.next();
      }
    });
  };

  ReceiptStep.prototype._sendReceipt = function _sendReceipt(flow, emailOrSms, invoice, tx) {
    Log.debug(function () {
      return 'Forward receipt to ' + emailOrSms;
    });
    var alert = _manticore2.default.alert({
      showActivity: true,
      title: (0, _l10n2.default)('Rcpt.Sending')
    }, function () {
      // TODO add cancel button support.
    });
    var rq = {
      invoiceId: invoice.payPalId,
      transactionType: this._transactionType(flow)
    };
    if (emailOrSms.indexOf('@') > 0) {
      rq.email = emailOrSms;
    } else {
      rq.phoneNumber = emailOrSms;
    }
    if (tx && tx.payer && tx.payer.customerId) {
      rq.customerId = tx.payer.customerId;
    }
    if (tx && tx.payer && tx.payer.receiptPreferenceToken) {
      rq.receiptPreferenceToken = tx.payer.receiptPreferenceToken;
    }
    var op = void 0,
        transactionNumber = tx && (tx.transactionHandle || tx.transactionNumber) || flow.data.transactionNumber;
    if (transactionNumber) {
      op = 'payment/' + transactionNumber + '/sendReceipt';
    } else {
      op = 'payment/sendReceipt';
    }

    Log.debug(function () {
      return 'SendReceipt ' + JSON.stringify(rq);
    });
    _Merchant2.default.active.request({
      service: 'retail',
      op: op,
      format: 'json',
      method: 'POST',
      debug: true,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(rq)
    }, function (error, receiptResponse) {
      error && Log.error('Send receipt failed with ' + JSON.stringify(error));
      alert.dismiss();
      flow.next();
    });
  };

  ReceiptStep.prototype._transactionType = function _transactionType(flow) {
    if (flow.data.error) {
      if (_RetailSDKUtil2.default.transactionCancelledError(flow.data.error)) {
        return 'VOID';
      } else {
        return 'DECLINE';
      }
    } else {
      if (this.context.type === _TransactionContext2.default.Type.Refund) {
        return 'REFUND';
      } else if (this.context.type === _TransactionContext2.default.Type.PartialRefund) {
        return 'PARTIAL';
      } else {
        return 'SALE';
      }
    }
  };

  return ReceiptStep;
}(_FlowStep3.default);

module.exports = ReceiptStep;

},{"../../common/Merchant":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Merchant.js","../../common/RetailSDKUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/RetailSDKUtil.js","../../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../../transaction/ReceiptViewContent":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/ReceiptViewContent.js","../../transaction/TransactionContext":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/TransactionContext.js","../../transaction/transactionEvent":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/transactionEvent.js","./FlowStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FlowStep.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","paypal-invoicing":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/RemoveCardStep.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = require('manticore-log')('flow.step.removeCard'),
    FlowStep = require('./FlowStep'),
    messageHelper = require('../messageHelper.js'),
    PaymentDevice = require('retail-payment-device').PaymentDevice,
    EmvDevice = require('retail-payment-device').EmvDevice;

/**
 * Wait for the card to be removed from the reader before continuing.
 */

var RemoveCardStep = function (_FlowStep) {
    _inherits(RemoveCardStep, _FlowStep);

    function RemoveCardStep(context) {
        _classCallCheck(this, RemoveCardStep);

        var _this = _possibleConstructorReturn(this, _FlowStep.call(this));

        _this.context = context;
        return _this;
    }

    RemoveCardStep.prototype.execute = function execute(flow) {
        if (!this.context.card || this.context.card.formFactor !== PaymentDevice.FormFactor.Chip || this.context.card.reader.cardStatus === EmvDevice.CardStatus.None) {
            flow.next();
        } else {
            this.context.card.reader.once(PaymentDevice.Event.cardRemoved, function () {
                flow.data.alert.dismiss();
                delete flow.data.alert;
                flow.next();
            });

            messageHelper.showRemoveCardMessage(this.context, flow.data, function (alert) {
                flow.data.alert = alert;
            });
        }
    };

    return RemoveCardStep;
}(FlowStep);

module.exports = RemoveCardStep;

},{"../messageHelper.js":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/messageHelper.js","./FlowStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FlowStep.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/SignatureStep.js":[function(require,module,exports){
'use strict';

var _SignatureReceiver = require('../../transaction/SignatureReceiver');

var _SignatureReceiver2 = _interopRequireDefault(_SignatureReceiver);

var _transactionEvent = require('../../transaction/transactionEvent');

var _transactionEvent2 = _interopRequireDefault(_transactionEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var manticore = require('manticore'),
    Log = require('manticore-log')('flow.step.signature'),
    FlowStep = require('./FlowStep'),
    l10n = require('../../common/l10n'),
    PaymentDevice = require('retail-payment-device').PaymentDevice,
    messageHelper = require('../messageHelper'),
    Message = PaymentDevice.Message,
    FormFactor = PaymentDevice.FormFactor;

var SignatureStep = function (_FlowStep) {
    _inherits(SignatureStep, _FlowStep);

    function SignatureStep(context) {
        _classCallCheck(this, SignatureStep);

        var _this = _possibleConstructorReturn(this, _FlowStep.call(this));

        _this.context = context;
        return _this;
    }

    SignatureStep.prototype.execute = function execute(flow) {
        var _this2 = this;

        if (this.context.card.isSignatureRequired === false) {
            Log.debug('Skipping signature step. Reason: Signature not required for this transaction');
            return flow.next();
        }

        this.context.emit(_transactionEvent2.default.willPresentSignature);
        if (flow.data.error) {
            Log.debug('Skipping signature step. Reason: One/more of previous steps logged an error');
            return flow.next();
        }

        var signatureReceiver = new _SignatureReceiver2.default(this.context, function (err, b64Signature) {
            flow.removeListener('aborted', _this2.dismissSignature);
            flow.data.signature = b64Signature;
            flow.nextOrAbort(err);
        });

        this.dismissSignature = function () {
            signatureReceiver.dismiss();
        };
        flow.once('aborted', this.dismissSignature);
        var formattedValues = messageHelper.formattedInvoiceTotal(this.context.invoice),
            messageId = SignatureStep.getReaderDisplayMessage(this.context.card);

        this.context.card.reader.display(messageId, formattedValues, function () {
            flow.data.alert && flow.data.alert.dismiss();
            if (_this2.context._signatureCollector) {
                _this2.context._signatureCollector(signatureReceiver);
            } else {
                signatureReceiver.acquireSignature();
            }
        });
    };

    SignatureStep.getReaderDisplayMessage = function getReaderDisplayMessage(card) {
        if (card.formFactor === FormFactor.Chip) {
            return Message.SignatureForInsert;
        }

        if (card.formFactor === FormFactor.EmvCertifiedContactless && !card.isContactlessMSD) {
            return Message.SignatureForTap;
        }
        return Message.SignatureForNonEmv;
    };

    return SignatureStep;
}(FlowStep);

module.exports = SignatureStep;

},{"../../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../../transaction/SignatureReceiver":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/SignatureReceiver.js","../../transaction/transactionEvent":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/transactionEvent.js","../messageHelper":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/messageHelper.js","./FlowStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FlowStep.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/UpdateInvoicePaymentStep.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _FlowStep2 = require('./FlowStep');

var _FlowStep3 = _interopRequireDefault(_FlowStep2);

var _paypalInvoicing = require('paypal-invoicing');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UpdateInvoicePaymentStep = function (_FlowStep) {
  _inherits(UpdateInvoicePaymentStep, _FlowStep);

  function UpdateInvoicePaymentStep(context) {
    _classCallCheck(this, UpdateInvoicePaymentStep);

    var _this = _possibleConstructorReturn(this, _FlowStep.call(this));

    _this.context = context;
    return _this;
  }

  UpdateInvoicePaymentStep.prototype.execute = function execute(flow) {
    if (!flow.error) {
      var invoice = this.context.invoice;
      var stubPayment = new _paypalInvoicing.InvoicePayment();
      stubPayment.type = _paypalInvoicing.InvoiceEnums.PaymentType.EXTERNAL;
      stubPayment.transactionID = flow.data.tx.transactionNumber;
      stubPayment.transactionType = 'SALE';
      stubPayment.date = (0, _moment2.default)();
      stubPayment.method = _paypalInvoicing.InvoiceEnums.PaymentMethod.CREDIT_CARD;
      stubPayment.amount = invoice.total;
      stubPayment.currency = invoice.currency;
      if (invoice.payments) {
        invoice.payments.push(stubPayment);
      } else {
        invoice.payments = [stubPayment];
      }
      invoice.status = _paypalInvoicing.InvoiceEnums.Status.PAID;
    }
    flow.next();
  };

  return UpdateInvoicePaymentStep;
}(_FlowStep3.default);

exports.default = UpdateInvoicePaymentStep;

},{"./FlowStep":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/steps/FlowStep.js","moment":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/moment/moment.js","paypal-invoicing":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/index.js":[function(require,module,exports){
(function (global){
'use strict';

if (!global._babelPolyfill) {
    require('core-js/es6/symbol');
    require('core-js/es6/set');
    require('core-js/fn/string/includes');
    require('core-js/fn/object/is');
    require('core-js/fn/array/of');
    require('core-js/fn/array/from');
    require('core-js/fn/array/find');
    require('core-js/fn/array/find-index');
    require('core-js/fn/symbol/iterator');
}

var Log = require('manticore-log')('root');

// TODO configure logging

var SDK = require('./sdk'),
    m = require('manticore');

global.Promise = require('yaku');
global.regeneratorRuntime = require('babel-regenerator-runtime');
if (!global.setTimeout) {
    global.setTimeout = function _setTimeout(fn, time) {
        return m.setTimeout(fn, time);
    };
}

try {
    Log.debug('Beginning SDK initialization.');
    m.export(require('retail-payment-device'));
    m.export(require('./paymentDevice/index'));
    m.export(require('./transaction/index'));
    m.export(require('paypal-invoicing'));
    m.export(require('manticore-paypalerror'));

    m.ready(SDK);
    Log.debug('SDK initialization complete.');
} catch (error) {
    Log.error('Failed to complete initialization: ' + error.message + '\n' + error.stack);
}

/** Signature sample
 manticore.setTimeout(function () {
        var l10n = require('./common/l10n');
        manticore.collectSignature({
            done: l10n('Done'),
            footer: l10n('Sig.Footer'),
            title: l10n('Sig.Title', { amount: '$7.77' }),
            signHere: l10n('Sig.Here')
        }, function (error, signature) {
            Log.debug(signature);
        });
    }, 1500);
 */
/** Ajax sample
 manticore.setTimeout(function () {
        Log.debug('Calling ajax');
        manticore.http({
            url: 'https://pph-mobileconfig.ebaystratus.com/ios-sdk-features-1.2.json',
            format: 'json'
        }, function (e, r) {
            try {
                Log.debug('Ajax done.');
                Log.debug(JSON.stringify(r, null, '\t'));
            } catch (x) {
                Log.error(`${x.message}: ${x.stack}`);
            }
        })
    }, 1000);
 */

/** Alert sample
 manticore.setTimeout(function () {
        manticore.alert({
            title: 'Hello World',
            message: 'Cruel world.',
            cancel: 'Cancel'
        }, function (alert, index) {
            alert.dismiss();
            Log.debug('Alert finished.');
        });
    }, 1500);
 */

/** Receipt sample
 var i = new SDK.Invoice('USD');
 i.addItem(new SDK.InvoiceItem("Foo", "1.00", "1.99", "1"));
 manticore.offerReceipt({
        invoice: i
    }, () => {
        console.log(arguments);
    });
*/

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./paymentDevice/index":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/index.js","./sdk":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/sdk.js","./transaction/index":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/index.js","babel-regenerator-runtime":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/babel-regenerator-runtime/runtime.js","core-js/es6/set":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/es6/set.js","core-js/es6/symbol":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/es6/symbol.js","core-js/fn/array/find":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/array/find.js","core-js/fn/array/find-index":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/array/find-index.js","core-js/fn/array/from":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/array/from.js","core-js/fn/array/of":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/array/of.js","core-js/fn/object/is":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/object/is.js","core-js/fn/string/includes":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/string/includes.js","core-js/fn/symbol/iterator":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/symbol/iterator.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","manticore-paypalerror":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-paypalerror/build/index.js","paypal-invoicing":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js","yaku":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/yaku/lib/yaku.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/DeviceUpdate.js":[function(require,module,exports){
'use strict';

var _sdkErrors = require('../common/sdkErrors');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var manticore = require('manticore'),
    EventEmitter = require('events').EventEmitter,
    l10n = require('../common/l10n');

/**
 * A device update object is passed to your application via the PaymentDevice#updateRequired event and is capable
 * of applying an update to a device.
 * @class
 * @property {bool} isRequired Whether the update is required before taking further transactions using the device
 */

var DeviceUpdate = function (_EventEmitter) {
    _inherits(DeviceUpdate, _EventEmitter);

    /**
     * Nobody can make me but Javascript
     * @private
     * @constructor
     * @param {PaymentDevice} device
     */
    function DeviceUpdate(device) {
        _classCallCheck(this, DeviceUpdate);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        _this.isRequired = true;
        _this.device = device;
        return _this;
    }

    /**
     * Display a prompt to the merchant offering the opportunity to upgrade the payment device, and optionally
     * update the device. Call the callback with completion status when the upgrade is complete or cancelled.
     * @param {DeviceUpdate~completed} callback Called upon success or failure of the update attempt.
     */


    DeviceUpdate.prototype.offer = function offer(callback) {
        var _this2 = this;

        if (this.device.pendingUpdate && this.device.pendingUpdate !== this) {
            // If someone else is in charge of the update, let them handle it
            // This can happen if new info comes from the server in the intervening time.
            return this.device.pendingUpdate.offer(callback);
        }

        //The validation callback allows DeviceUpdate handle the responsibility of success
        //And the responsibility to check for implementation specific validations is moved to the implementation
        var validateCallback = function validateCallback(error) {
            if (error) {
                callback(error, false);
            } else {
                manticore.alert({
                    title: l10n(_this2.isRequired ? 'SwUpgrade.Required.Title' : 'SwUpgrade.Optional.Title'),
                    message: l10n(_this2.isRequired ? 'SwUpgrade.Required.Msg' : 'SwUpgrade.Optional.Msg'),
                    cancel: l10n('SwUpgrade.Buttons.Cancel'),
                    buttons: [l10n('SwUpgrade.Buttons.Ok')]
                }, function (alertView, index) {
                    alertView.dismiss();
                    if (index === 0) {
                        return _this2.begin(true, callback);
                    }
                    callback((0, _sdkErrors.getError)(new Error(), _sdkErrors.sdk.userCancelled), false);
                });
            }
        };
        this.validateUpdateEligibility(validateCallback);
    };

    /**
     * Begin the software update.
     * @param {bool} displayUI Whether to display blocking UI during the software update.
     * @param {DeviceUpdate~completed} callback Called upon success or failure of the update attempt.
     */


    DeviceUpdate.prototype.begin = function begin(displayUI, callback) {
        throw new Error('Must be implemented in derived class.');
    };

    /**
     * Check device-specific conditions for update such as battery level.
     */


    DeviceUpdate.prototype.validateUpdateEligibility = function validateUpdateEligibility(callback) {
        //Te default implementation assumes no error
        callback();
    };

    return DeviceUpdate;
}(EventEmitter);

/**
 * Called when either the software update completed, failed, or was canceled. (To detect the user having chosen
 * not to update, check that the error is null but deviceUpgraded is false.
 * @callback DeviceUpdate~completed
 * @param {error} error The error that caused the update to fail, if any
 * @param {bool} deviceUpgraded True if the device has been successfully updated.
 */

/**
 * Payment device connected via USB needs to be unplugged and plugged back to the USB port for the software
 * update to complete
 * @event DeviceUpdate#reconnectReader
 * @param {int} waitTime The duration within which the device needs to be reconnected
 */

module.exports = DeviceUpdate;

},{"../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../common/sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/MagtekRawUsbReaderDevice.js":[function(require,module,exports){
(function (Buffer){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = require('manticore-log')('paymentDevice.magtekRawUsbReaderDevice'),
    FormFactor = require('retail-payment-device').PaymentDevice.FormFactor,
    MagneticCard = require('retail-payment-device').MagneticCard,
    MagneticReaderDevice = require('retail-payment-device').MagneticReaderDevice;

/**
 * Specialization of card reader that does its own interpretation of USB data
 */

var MagtekRawUsbReaderDevice = function (_MagneticReaderDevice) {
    _inherits(MagtekRawUsbReaderDevice, _MagneticReaderDevice);

    function MagtekRawUsbReaderDevice(uniqueName, native) {
        _classCallCheck(this, MagtekRawUsbReaderDevice);

        var _this = _possibleConstructorReturn(this, _MagneticReaderDevice.call(this, uniqueName, native));

        _this.manufacturer = 'Magtek';
        return _this;
    }

    MagtekRawUsbReaderDevice.prototype.received = function received(event) {

        try {
            var buf = new Buffer(event, 'base64');
            if (buf.length < 565) {
                Log.error('Invalid MagTek data length: ' + buf.length);
                return null;
            }

            var card = new MagneticCard();
            card.formFactor = FormFactor.MagneticCardSwipe;
            card.reader = this;
            getTracks(card, buf);
            getMagneprint(card, buf);

            if (this.productId === 0x0E || buf.length === 565) {
                magtekVersion1(card, buf);
            } else if (this.productId === 0x11 || buf.length === 887) {
                magtekVersion2(card, buf);
            }

            if (!this.serialNumber && card.ksn) {
                // Magtek serial is first 14 of ksn. For some reason this doesn't match serial
                // reported in the packet.
                this.serialNumber = card.ksn.substring(0, 14);
            }

            _MagneticReaderDevice.prototype.received.call(this, card);
        } catch (x) {
            Log.error('Failed to parse Magtek card event: ' + x.message + '\n' + x.stack);
        }
    };

    return MagtekRawUsbReaderDevice;
}(MagneticReaderDevice);

function getMagneprint(swipe, buf) {
    swipe.magneprint = {
        status: buf.slice(344, 347).toString('hex'),
        length: buf[348]
    };
    if (swipe.magneprint.length) {
        swipe.magneprint.data = buf.slice(349, 349 + swipe.magneprint.length).toString('hex');
    }
}

function getTracks(swipe, buf) {
    var track1ok = (buf[0] & 0x1) === 0,
        track2ok = (buf[1] & 0x1) === 0,
        track3ok = (buf[2] & 0x1) === 0,
        track1length = buf[3],
        track2length = buf[4],
        track3length = buf[5];

    if (track1ok && track1length) {
        swipe.track1 = buf.slice(7, 7 + track1length).toString('hex');
    }
    if (track2ok && track2length) {
        swipe.track2 = buf.slice(119, 119 + track2length).toString('hex');
    }
    if (track3ok && track3length) {
        swipe.track3 = buf.slice(231, 231 + track3length).toString('hex');
    }
}

function magtekVersion1(swipe, buf) {
    // http://www.magtek.com/documentation/public/99875338-3.01.pdf
    swipe.counter = buf.slice(493, 500).toString('hex');
    swipe.crypto = {
        enabled: (buf[501] & 0x1) === 0x1,
        keyInjected: (buf[501] & 0x2) === 0x2
    };
    if (buf[501] & 0x4) {
        swipe.crypto.keysExhausted = true;
        Log.error('DUKPT keys exhausted on Magtek reader.');
    }
    swipe.ksn = buf.slice(555, 565).toString('hex');
}

function magtekVersion2(swipe, buf) {
    // http://www.magtek.com/documentation/public/99875474-10.01.pdf, except it's not up
    swipe.counter = buf.slice(856, 858).toString('hex');
    swipe.crypto = {
        enabled: (buf[494] & 0x4) === 0x4,
        keyInjected: (buf[494] & 0x2) === 0x2
    };
    if (buf[494] & 0x1) {
        swipe.crypto.keysExhausted = true;
        Log.error('DUKPT keys exhausted on Magtek reader.');
    }
    swipe.ksn = buf.slice(495, 505).toString('hex');
    swipe.counter = buf.slice(856, 858).toString('hex');

    var maskedLen = buf[505];
    if (maskedLen) {
        swipe.track1masked = buf.slice(508, 508 + maskedLen).toString('ascii');
    }
    maskedLen = buf[506];
    if (maskedLen) {
        swipe.track2masked = buf.slice(620, 620 + maskedLen).toString('ascii');
    }
    maskedLen = buf[507];
    if (maskedLen) {
        swipe.track3masked = buf.slice(732, 732 + maskedLen).toString('ascii');
    }
}
module.exports = MagtekRawUsbReaderDevice;

}).call(this,require("buffer").Buffer)
},{"buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/MiuraDevice.js":[function(require,module,exports){
(function (Buffer){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _manticore = require('manticore');

var _manticore2 = _interopRequireDefault(_manticore);

var _TransactionContext = require('../transaction/TransactionContext');

var _TransactionContext2 = _interopRequireDefault(_TransactionContext);

var _RetailSDKUtil = require('../common/RetailSDKUtil');

var _RetailSDKUtil2 = _interopRequireDefault(_RetailSDKUtil);

var _paypalInvoicing = require('paypal-invoicing');

var _retailPaymentDevice = require('retail-payment-device');

var _miuraEmv = require('miura-emv');

var _miuraDeviceState = require('./miura/miuraDeviceState');

var _miuraDeviceState2 = _interopRequireDefault(_miuraDeviceState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tlv = require('tlvlib'),
    TlvTags = Tlv.Tags,
    Message = _retailPaymentDevice.PaymentDevice.Message,
    ConnectionFlow = require('./miura/ConnectionFlow'),
    Merchant = require('../common/Merchant'),
    Log = require('manticore-log')('paymentDevice.miuraDevice'),
    l10n = require('../common/l10n'),
    FormFactor = _retailPaymentDevice.PaymentDevice.FormFactor;

var swipeLastFourRegexMatcher = void 0;

/**
 * Represents an EMV payment terminal manufactured by Miura for PayPal
 * @class
 * @protected
 */

var MiuraDevice = function (_EmvDevice) {
    _inherits(MiuraDevice, _EmvDevice);

    /**
    * Construct a new PaymentDevice given a native function capable of sending data to the device
    */
    function MiuraDevice(uniqueId, nativeReader, isUsb) {
        _classCallCheck(this, MiuraDevice);

        Log.debug('Starting Miura device.');

        var _this = _possibleConstructorReturn(this, _EmvDevice.call(this, uniqueId, nativeReader));

        _this.manufacturer = 'Miura';
        _this.terminal = new _miuraEmv.Terminal(function (buf, cb) {
            return _this.native.send(buf, cb);
        }, _this);
        _this.isUsb = _this.terminal.isUsb = isUsb;

        // Reflect some terminal events
        _this.terminal.on(_miuraEmv.Terminal.Event.deviceEvent, function (m) {
            return _this._deviceEvent(m);
        });
        _this.terminal.on(_miuraEmv.Terminal.Event.cardPresented, function (m) {
            m.reader = _this;
            _this.emit(_retailPaymentDevice.PaymentDevice.Event.cardPresented, m);
        });
        _this.terminal.on(_miuraEmv.Terminal.Event.cardRemoved, function () {
            return _this.emit(_retailPaymentDevice.PaymentDevice.Event.cardRemoved);
        });
        _this.terminal.on(_miuraEmv.Terminal.Event.error, function (err, ff) {
            return _this.emit(_retailPaymentDevice.PaymentDevice.Event.error, err, ff, _this);
        });
        _this.model = 'M010'; // ConnectionFlow will figure this out, but here's our assumption
        return _this;
    }

    MiuraDevice.prototype.extractReaderLogs = function extractReaderLogs(callback) {
        Log.debug('Extracting log file from reader.');
        this.terminal.Config.getLogFile(function (err, buff) {
            Log[err ? 'error' : 'debug'](function () {
                return 'Miura log getFile complete. err: ' + err + ' Logs: ' + buff;
            });
            callback(err);
        });
    };

    MiuraDevice.prototype.beginDeviceConnect = function beginDeviceConnect(callback) {
        var _this2 = this;

        if (this.native.isConnected()) {
            this.removeState(_miuraDeviceState2.default.hardResetting);
            Log.debug(function () {
                return 'Connect called, but ' + _this2.id + ' is already connected.';
            });
            return callback();
        }
        Log.debug(function () {
            return 'Connecting to Miura device ' + _this2.id;
        });
        this.native.connect(function (error) {
            if (error) {
                return callback(error);
            }
            _this2.removeState(_miuraDeviceState2.default.hardResetting);
            _this2.terminal.didConnect();
            if (!_this2.rawConnect) {
                new ConnectionFlow(_this2).start(callback);
            } else {
                Log.debug('Bypassing normal connection sequence.');
                callback();
            }
        });
    };

    MiuraDevice.prototype.disconnectUsb = function disconnectUsb(callback) {
        if (this.terminal.isUsb) {
            this.terminal.disconnectUsb(callback);
        } else {
            callback && callback();
        }
    };

    MiuraDevice.prototype.beginDeviceDisconnect = function beginDeviceDisconnect(callback) {
        var _this3 = this;

        if (!this.isConnected()) {
            return callback(null);
        }

        if (this.isUsb) {
            this.display(Message.NotConnected, null, function () {
                _this3.native.disconnect(callback);
            }, true);
        } else {
            this.native.disconnect(callback);
        }
    };

    MiuraDevice.prototype.hardReset = function hardReset(callback) {
        var _this4 = this;

        this.terminal.hardReset(function (err) {
            if (err) {
                Log.error('hard-reset command to ' + _this4.id + ' failed with error: ' + err);
            } else {
                _this4.addState(_miuraDeviceState2.default.hardResetting);
            }
            callback(err);
        });
    };

    MiuraDevice.prototype.activate = function activate(context, opt) {
        var _this5 = this;

        _EmvDevice.prototype.activate.call(this, context);
        this.terminal.registerForCardEvents(true, function (e) {
            if (e) {
                Log.error('Failed to register for Miura card events: ' + e.message);
                return;
            }
            _this5.terminal.registerForKeyboardEvents(true, function (e) {
                if (e) {
                    Log.error('Failed to register for Miura keyboard events: ' + e.message);
                }

                if (opt.formFactors.has(FormFactor.EmvCertifiedContactless)) {
                    _this5._startContactlessTx(context);
                    return;
                }

                var messageId = void 0;
                if (opt.formFactors.has(FormFactor.MagneticCardSwipe) && opt.formFactors.has(FormFactor.Chip)) {
                    messageId = Message.ReadyForInsertAndSwipePayment;
                } else if (opt.formFactors.has(FormFactor.MagneticCardSwipe)) {
                    messageId = Message.ReadyForSwipePayment;
                } else if (opt.formFactors.has(FormFactor.Chip)) {
                    messageId = Message.ReadyForInsertPayment;
                }

                if (!messageId) {
                    return;
                }

                var invoice = context.invoice;
                _this5.display(messageId, { amount: _paypalInvoicing.Currency.format(invoice.currency, invoice.total) }, function (err) {
                    if (err) {
                        Log.error('Unable to push message ' + messageId + ' to terminal');
                    }
                });
            });
        });
    };

    MiuraDevice.prototype._startContactlessTx = function _startContactlessTx(context) {
        var _this6 = this;

        var invoice = context.invoice;
        this.transactionActive = true;
        var transactionType = context.type === _TransactionContext2.default.Type.Sale ? 0 : 20;
        this.terminal.startContactlessTransaction(0, transactionType, _paypalInvoicing.Currency.toCents(invoice.currency, invoice.total), _paypalInvoicing.Currency.getCurrency(invoice.currency).iso4217, function (err, clResult) {
            _this6.transactionActive = false;
            if (err && (context.type === _TransactionContext2.default.Type.Sale || context.type === _TransactionContext2.default.Type.Refund && err.code !== _retailPaymentDevice.deviceError.nfcNotAllowed.code)) {
                // Essentially, in case of refunds, treat the decline as a success and move on.
                return _this6.emit(_retailPaymentDevice.PaymentDevice.Event.error, err, FormFactor.EmvCertifiedContactless, _this6);
            }
            //Card presented
            var card = new _miuraEmv.CardStatus(clResult).getPresentedCard(_this6);
            _this6.transactionActive = true;
            _this6.emit(_retailPaymentDevice.PaymentDevice.Event.cardPresented, card);
        });
    };

    MiuraDevice.prototype.deactivate = function deactivate(context, shouldDisconnect, cb) {
        var _this7 = this;

        Log.info(function () {
            return 'Deactivating ' + _this7.id + '. shouldDisconnect: ' + shouldDisconnect + ' abortCommandNeeded: ' + _this7.transactionActive;
        });
        if (!this.isConnected()) {
            cb && cb();
        } else if (this.transactionActive) {
            this.terminal.abortTransaction(function () {
                return _EmvDevice.prototype.deactivate.call(_this7, context, shouldDisconnect, cb);
            });
        } else {
            _EmvDevice.prototype.deactivate.call(this, context, shouldDisconnect, function () {
                _this7.emit(_retailPaymentDevice.PaymentDevice.Event.cancelled, null, _this7);
                cb();
            });
        }
    };

    MiuraDevice.prototype.abortTransaction = function abortTransaction(cb) {
        if (this.transactionActive) {
            this.terminal.abortTransaction(function () {
                cb && cb();
            });
        } else {
            cb && cb();
        }
    };

    MiuraDevice.prototype.completeTransaction = function completeTransaction(authCode, cb) {
        var _this8 = this;

        if (!this.isConnected()) {
            cb && cb((0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.deviceNotConnected));
        } else {
            this.terminal.continueTransaction(authCode, function (err, rz) {
                _this8.transactionActive = false;
                cb(err, rz);
            });
        }
    };

    MiuraDevice.prototype.clearTransaction = function clearTransaction(cb) {
        if (!this.isConnected() || !this.terminal) {
            cb && cb();
        } else {
            this.terminal.softReset(cb);
        }
    };

    MiuraDevice.prototype.received = function received(data) {
        this.terminal.received(data);
    };

    MiuraDevice.prototype.getBatteryInfo = function getBatteryInfo(callback) {
        if (this.hasState(_miuraDeviceState2.default.softwareUpdate)) {
            callback && callback(_retailPaymentDevice.deviceError.cannotAcceptMessage);
            return;
        }

        // Do not check if Device is connected as re-establishing a connection after software reset depends on pinging for
        // battery level at all times
        this.terminal.getBatteryLevel(function (err, status) {
            Log[err ? 'error' : 'debug'](function () {
                return 'Received battery info ' + status + '. Error: ' + (err ? err.message : null);
            });
            if (callback) {
                callback(err, status);
            }
        });
    };

    MiuraDevice.prototype.displayWithSystemIcons = function displayWithSystemIcons(messageId, values, callback) {
        this.display(messageId, values, callback, true);
    };

    MiuraDevice.prototype.display = function display(messageId, values, callback, displaySystemIcons) {
        if (!this.isConnected()) {
            callback && callback((0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.deviceNotConnected));
        } else {
            this.terminal.display(messageId, values, callback, displaySystemIcons);
        }
    };

    MiuraDevice.prototype.promptForSecureAccountNumber = function promptForSecureAccountNumber(options, callback) {
        this.terminal.promptForSecureAccountNumber(options, callback);
    };

    MiuraDevice.prototype.updateRequired = function updateRequired(update) {
        var _this9 = this;

        this.displayWithSystemIcons(Message.SoftwareUpdateRequired, {}, function () {
            _EmvDevice.prototype.updateRequired.call(_this9, update);
        });
    };

    MiuraDevice.prototype.startContactTransaction = function startContactTransaction(context) {
        var _this10 = this;

        var tt = _miuraEmv.Terminal.TransactionType.SALE;
        // TODO not sure SALE is the right type for an auth from the terminal's perspective?
        if (context.type === _TransactionContext2.default.Type.Refund) {
            tt = _miuraEmv.Terminal.TransactionType.REFUND;
        }

        this.terminal.startICCTransaction(0, tt, _paypalInvoicing.Currency.toCents(context.invoice.currency, context.invoice.total).toString(), _paypalInvoicing.Currency.getCurrency(context.invoice.currency).iso4217, function (err, clResult) {
            if (err) {
                Log.error('Failed to start ICC transaction. Error: ' + err);
                return _this10.emit(_retailPaymentDevice.PaymentDevice.Event.error, err, FormFactor.Chip, clResult);
            }

            if (clResult instanceof _retailPaymentDevice.DecisionRequired) {
                return _this10.emit(_retailPaymentDevice.PaymentDevice.Event.decisionRequired, err, clResult);
            }

            if (clResult.apdu.template === 0xE3) {
                return _this10.emit(_retailPaymentDevice.PaymentDevice.Event.approval, err, clResult);
            }

            if (clResult.apdu.template === 0xE4) {
                _this10.transactionActive = true;
                return _this10.emit(_retailPaymentDevice.PaymentDevice.Event.cardDataRead, err, clResult);
            }

            Log.warn('Contact tx Response from device was not handled ' + clResult);
            _this10.emit(_retailPaymentDevice.PaymentDevice.Event.error, (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.badEmvData), FormFactor.Chip, clResult);
        });
    };

    /**
     * Parse the card data for information related to the card and current tx
     * @returns {{lastFourDigits: *, cardIssuer: *, isSignatureRequired: *}}
     * @private
     */


    MiuraDevice.prototype.parseCardData = function parseCardData(card, responsePacket) {
        var cardData = {};
        try {
            cardData = {
                lastFourDigits: MiuraDevice._lastFourDigits(card, responsePacket),
                cardIssuer: MiuraDevice._getCardIssuer(card, responsePacket),
                isSignatureRequired: MiuraDevice._isSignatureCvmRequired(card, responsePacket),
                cardholderName: MiuraDevice._getCardHolderName(card, responsePacket),
                emvData: responsePacket
            };
        } catch (e) {
            Log.error('Unable to parse card metadata: ' + e + ' from : ' + responsePacket);
        }
        return cardData;
    };

    MiuraDevice._lastFourDigits = function _lastFourDigits(card, responsePacket) {
        var _this11 = this;

        var match = void 0,
            emvData = responsePacket.apdu.data.toString('hex');
        if (card.formFactor === FormFactor.MagneticCardSwipe) {
            if (!swipeLastFourRegexMatcher) {
                swipeLastFourRegexMatcher = /2a(?!.*2a)(.*)(?=3d)/;
            }
            match = swipeLastFourRegexMatcher.exec(emvData);
            if (match && match[1]) {
                var lastFourContainingString = new Buffer(match[1], 'hex').toString('utf8');
                if (lastFourContainingString.length >= 4) {
                    var _ret = function () {
                        var lastFour = lastFourContainingString.substring(0, 4);
                        Log.debug(function () {
                            return 'Got last four digits of card as ' + lastFour;
                        });
                        return {
                            v: lastFour
                        };
                    }();

                    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
                }
            }
        }

        if (card.formFactor === FormFactor.Chip || card.formFactor === FormFactor.EmvCertifiedContactless) {
            var _ret2 = function () {
                var lastFour = _this11._getLastFourFormEMVChipAndEMVContactlessBlob(responsePacket);
                if (lastFour) {
                    Log.debug(function () {
                        return 'Got last four digits of card as ' + lastFour;
                    });
                    return {
                        v: lastFour
                    };
                }
            }();

            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
        }

        Log.warn('Unable to parse last four digits (formFactor: ' + card.formFactor + ') from emvData: ' + emvData);
    };

    MiuraDevice._getLastFourFormEMVChipAndEMVContactlessBlob = function _getLastFourFormEMVChipAndEMVContactlessBlob(responsePacket) {
        //Masked PAN is present in various different tags.. We need to parse one by one until we get what we need..

        var lastFourTLV = responsePacket.tlvs.find(_miuraEmv.Tags.MiuraMaskedPan) || responsePacket.tlvs.find(_miuraEmv.Tags.MiuraMaskedICCTrack2) || responsePacket.tlvs.find(_miuraEmv.Tags.MiuraMaskedTrack2) || responsePacket.tlvs.find(_miuraEmv.Tags.MiuraMaskedContactlessTrack2);

        //If we still don't find the TLV corresponding to masked pan then give up...
        if (!lastFourTLV) {
            Log.warn('Unable to find the any TLV corresponding to masked pan');
            return;
        }

        var val = lastFourTLV.bytes.toString('hex');

        if (!val) {
            Log.warn('lastFourTLV: ' + lastFourTLV);
            return;
        }

        //With this blob we get the masked pan as [first 6 digits]ffffff[last 4 digits]ff..
        var indexMatcher = 'ffff';
        var index = val.indexOf(indexMatcher);
        var lastFourStr = val.substring(index + indexMatcher.length);

        //Lets getrid of all f's until we hit valid numeric code..
        while (lastFourStr.length > 0 && lastFourStr.charAt(0) === 'f') {
            lastFourStr = lastFourStr.substring(1);
        }

        return lastFourStr.substring(0, 4);
    };

    MiuraDevice._getCardHolderName = function _getCardHolderName(card, responsePacket) {
        if (card.formFactor === FormFactor.MagneticCardSwipe) {
            return null; // TODO
        }

        if (card.formFactor === FormFactor.Chip || card.formFactor === FormFactor.EmvCertifiedContactless) {
            var cardHolderName = responsePacket.tlvs.find(TlvTags.CardholderName);
            return cardHolderName ? cardHolderName.parse() : null;
        }
    };

    MiuraDevice._getCardIssuer = function _getCardIssuer(card, responsePacket) {
        if (card.formFactor === FormFactor.MagneticCardSwipe) {
            var emvData = responsePacket.apdu.data.toString('hex'),
                start = emvData.toString().lastIndexOf('3b'),
                end = emvData.lastIndexOf('2a');

            if (start > end) {
                start = emvData.indexOf('3b');
            }

            if (end < 0) {
                return null;
            }

            emvData = emvData.substring(start + 2, end);
            var cardNumber = new Buffer(emvData, 'hex').toString('utf8');
            return _retailPaymentDevice.CardDataUtil.getCardIssuerFromCardNumber(cardNumber);
        }

        if (card.formFactor === FormFactor.Chip || card.formFactor === FormFactor.EmvCertifiedContactless) {
            var appLabel = responsePacket.tlvs.find(TlvTags.ApplicationLabel),
                appLabelVal = appLabel ? appLabel.parse() : null;
            return _retailPaymentDevice.CardDataUtil.getCardIssuerFromEmvAppLabel(appLabelVal);
        }
    };

    MiuraDevice._isSignatureCvmRequired = function _isSignatureCvmRequired(card, responsePacket) {
        /*jshint maxcomplexity:11 */
        var cvmStatus = responsePacket.tlvs.find(_miuraEmv.Tags.MiuraCardholderVerificationStatus),
            val;
        Log.debug(function () {
            return 'Signature data from card: ' + (cvmStatus ? cvmStatus.parse() : null) + '(cvmStatus)';
        });
        if (!cvmStatus || !(val = cvmStatus.parse())) {
            return true;
        }
        val = val[0];
        if (card.formFactor === FormFactor.Chip) {
            if (val === 1 || val === 2 || val === 4 || val === 0x1F) {
                return false;
            }
        } else {
            if (val === 0 || val === 2 || val === 3) {
                return false;
            }
        }
        return true;
    };

    MiuraDevice.prototype.retrieveVersionInfo = function retrieveVersionInfo(cb) {
        var _this12 = this;

        this.terminal.softReset(function (e, rz) {
            if (e) {
                return cb(e);
            }

            var serialNumberTag = rz.tlvs && rz.tlvs.find(Tlv.Tags.InterfaceDeviceSerialNumber);
            if (!serialNumberTag) {
                return cb((0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.dataRetrievalFailed.withDevMessage('Failed to get serial number from ' + _this12.id)));
            }

            _this12.serialNumber = serialNumberTag.parse();
            var firstThree = _this12.serialNumber.substring(0, 3);
            if (firstThree === '130' || firstThree === '030') {
                _this12.model = 'M000';
            }

            for (var _iterator = rz.tlvs.values, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var tlv = _ref;

                if (tlv.tagNumber === _miuraEmv.Tags.MiuraSoftwareInformation.number) {
                    _this12._readConfigPair(tlv);
                }
            }

            _this12.pre76 = _this12.os && (_this12.os.majorVer < 7 || _this12.os.majorVer === 7 && _this12.os.minorVer <= 5);
            Log.info(_this12.id + ' Serial #: ' + _this12.serialNumber + ' OS: ' + (_this12.os && _this12.os.id + ', ' + _this12.os.ver) + ' MPI: ' + (_this12.os && _this12.mpi.id + ', ' + _this12.mpi.ver) + ' pre76: ' + _this12.pre76);
            cb(null);
        });
    };

    MiuraDevice.prototype._readConfigPair = function _readConfigPair(tlv) {
        var key,
            val = true;
        for (var _iterator2 = tlv.parse().values, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
            } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
            }

            var v = _ref2;

            if (v.tagNumber === _miuraEmv.Tags.MiuraIdentifier.number) {
                key = v.parse();
            } else if (v.tagNumber === _miuraEmv.Tags.MiuraVersionInformation.number) {
                val = v.parse();
            }
        }
        if (key.indexOf('-MPI') >= 0) {
            this.mpi = MiuraDevice._parseVersionInfo(key, val);
        } else if (key.indexOf('OS') >= 0) {
            this.os = MiuraDevice._parseVersionInfo(key, val);
        }
    };

    MiuraDevice._parseVersionInfo = function _parseVersionInfo(key, ver) {
        var parts = ver && ver.match(/(\d+)-(\d+)/),
            majorVersion = parts && parseInt(parts[1]),
            minorVersion = parts && parseInt(parts[2]);

        return {
            id: key,
            ver: ver,
            majorVer: majorVersion,
            minorVer: minorVersion
        };
    };

    MiuraDevice.prototype._deviceEvent = function _deviceEvent(m) {
        this.emit('deviceEvent', m);
        // do internal translations
        if (m instanceof _miuraEmv.Terminal.EventType.TerminalStatus) {
            if (m.changeType === _miuraEmv.Terminal.EventType.TerminalStatus.Constants.PinEntryStateChange) {
                var pinev = new _retailPaymentDevice.PinEvent();
                pinev.digits = m.pinDigits;
                pinev.complete = m.pinComplete;
                pinev.correct = m.pinCorrect;
                pinev.isLastAttempt = m.lastPinAttempt;
                pinev.failureReason = m.pinFailureReason;
                this.emit('pinEvent', pinev);
            }

            if (m.changeType === _miuraEmv.Terminal.EventType.TerminalStatus.Constants.SeePhone) {
                _manticore2.default.alert({ audio: { file: 'beep', playCount: 2 } }, function () {});
            }
        }

        //'X' button was tapped
        if (m.keyCode === 0x1B) {
            Log.debug('X button on terminal was tapped. Will try to cancel an ongoing payment');
            this.emit(_retailPaymentDevice.PaymentDevice.Event.cancelRequested);
        }
    };

    MiuraDevice.prototype.errorOrFailure = function errorOrFailure(error, response) {
        if (!error && !response.apdu.isSuccess) {
            return (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.failureResponse.withDevMessage('Miura response indicates failure: 0x' + response.apdu.sw1.toString(16) + ' 0x' + response.apdu.sw2.toString(16)));
        }
        return error;
    };

    /**
    * Returns true if the device is in a state to accept commands
    */


    MiuraDevice.prototype.canPushCommands = function canPushCommands() {
        var _this13 = this;

        if (!this.isConnected()) {
            Log.debug(function () {
                return 'Cannot push command to ' + _this13.id + ' as it is not connected';
            });
            return false;
        }

        if (this.hasState(_miuraDeviceState2.default.hardResetting)) {
            Log.debug(function () {
                return 'Cannot push command to ' + _this13.id + ' as it is in a hard reset state';
            });
            return false;
        }

        return true;
    };

    MiuraDevice.prototype.addState = function addState(state) {
        Log.debug('Adding state \'' + _RetailSDKUtil2.default.getEnumName(_miuraDeviceState2.default, state) + '\'');
        this.state |= state;
    };

    MiuraDevice.prototype.removeState = function removeState(state) {
        Log.debug('Removing device state \'' + _RetailSDKUtil2.default.getEnumName(_miuraDeviceState2.default, state) + '\'');
        this.state &= ~state;
    };

    MiuraDevice.prototype.hasState = function hasState(state) {
        return (this.state & state) === state;
    };

    _createClass(MiuraDevice, [{
        key: 'formFactors',
        get: function get() {
            return this.terminal.formFactors;
        }
    }, {
        key: 'cardStatus',
        get: function get() {
            return this.terminal.cardStatus;
        }
    }, {
        key: '_isKeyInjectionRequired',
        get: function get() {
            if (this.forceRki) {
                return true;
            }
            // TODO this may happen before the merchant is available, so we need to decide how to change ready events to handle this possibility
            // TODO this should be driven off a config somewhere (feature map)
            if (Merchant.active && Merchant.active.country === 'AU') {
                return !(this.p2pe.pin && this.p2pe.sred);
            } else {
                return !(this.p2pe.pin || this.p2pe.sred);
            }
        }
    }]);

    return MiuraDevice;
}(_retailPaymentDevice.EmvDevice);

module.exports = MiuraDevice;

}).call(this,require("buffer").Buffer)
},{"../common/Merchant":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Merchant.js","../common/RetailSDKUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/RetailSDKUtil.js","../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../transaction/TransactionContext":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/TransactionContext.js","./miura/ConnectionFlow":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/miura/ConnectionFlow.js","./miura/miuraDeviceState":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/miura/miuraDeviceState.js","buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","miura-emv":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/index.js","paypal-invoicing":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js","tlvlib":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/VirtualPaymentDevice.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MiuraDevice = require('../paymentDevice/MiuraDevice');

/**
 * Various operations on a VirtualPaymentDevice are asynchronous (e.g. send, connect).
 * You will be passed a DeviceOperationResultHandler which you should call when the operation completes
 * either successfully (accept()), or with an error (reject(reasonMessage))
 * @class
 */

var DeviceOperationResultHandler = function () {
  function DeviceOperationResultHandler() {
    _classCallCheck(this, DeviceOperationResultHandler);
  }

  /**
   * The operation has completed succesfully.
   */
  DeviceOperationResultHandler.prototype.accept = function accept() {
    throw new Error('Marker class should not be used.');
  };

  /**
   * The operation has failed for some reason.
   * @param {string} reasonMessage A human (ok, a developer human) readable description for the failure
   */


  DeviceOperationResultHandler.prototype.reject = function reject(reasonMessage) {
    throw new Error('Marker class should not be used.');
  };

  // NOTE: this is basically another "marker" class meant to get around the current limitation
  // of manticore-gen not being able to expose NATIVE callbacks to JS as properties on objects
  // or parameters to functions.


  return DeviceOperationResultHandler;
}();

/**
 * A virtual payment device allows you to replace the data transport layer of an existing supported
 * payment device. For example, if you want to connect a PayPal Here terminal to a DIFFERENT physical
 * machine than the customer UI. There are two important concepts to keep in mind. First, the virtual
 * device must be "attached" for the SDK to know about it. This allows you to manipulate the device
 * existence separately from whether or not it is actually connected and in use by the SDK. Second,
 * after attaching, the SDK will usually automatically make a connection attempt to get metadata and such,
 * and depending on various factors, determine whether to hold onto the connection or release it (such as
 * battery level or connection type).
 * @class
 */


var VirtualPaymentDevice = function () {
  /**
   * Construct a virtual payment device
   * @param {string} deviceType The type of the "real" device this represents. Currently only Miura is supported.
   * @param {string} deviceId A unique id for the device
   * @param {VirtualPaymentDevice~connectFunction} connectFunction The function that the SDK will call to attempt a connection
   * @param {VirtualPaymentDevice~sendFunction} sendFunction The function that the SDK will call to deliver data
   * to the device
   * @param {VirtualPaymentDevice~isConnectedFunction} isConnectedFunction The function that the SDK will call to determine
   * if the device is currently connected
   * @param {VirtualPaymentDevice~disconnectFunction} disconnectFunction The function that the SDK will call to
   * disconnect from the device
   */
  function VirtualPaymentDevice(deviceType, deviceId, connectFunction, sendFunction, isConnectedFunction, disconnectFunction) {
    _classCallCheck(this, VirtualPaymentDevice);

    if (deviceType === 'Miura') {
      this.device = new MiuraDevice(deviceId, this);
      this._nativeConnect = connectFunction;
      this._nativeSend = sendFunction;
      this.isConnected = isConnectedFunction;
      this._nativeDisconnect = disconnectFunction;
    } else {
      throw new Error('Unknown payment deviceType ' + deviceType + '. Currently only Miura is supported.');
    }
  }

  /**
   * Let the SDK attempt to use this device
   */


  VirtualPaymentDevice.prototype.attach = function attach() {
    MiuraDevice.discovered(this.device);
    this.device.connect();
  };

  /**
   * Make this device disappear from the SDK
   */


  VirtualPaymentDevice.prototype.detach = function detach() {
    this.device.removed();
  };

  /**
   * Translates from the SDKs expectations to the single signature of the native implementation
   * @private
   */


  VirtualPaymentDevice.prototype.send = function send(objOrData, callback) {
    if (typeof objOrData === 'string') {
      this._nativeSend(objOrData, 0, objOrData.length * 3 / 4, wrapCallback(callback));
    } else {
      this._nativeSend(objOrData.data, objOrData.offset, objOrData.len, wrapCallback(callback));
    }
  };

  /**
   * Translates from the SDKs expectations to the signature of the native implementation
   * @private
   */


  VirtualPaymentDevice.prototype.disconnect = function disconnect(callback) {
    this._nativeDisconnect(wrapCallback(callback));
  };

  /**
   * Translates from the SDKs expectations to the signature of the native implementation
   * @private
   */


  VirtualPaymentDevice.prototype.connect = function connect(callback) {
    this._nativeConnect(wrapCallback(callback));
  };

  /**
   * You must call this method when data has been received from the device
   * @param {string} base64Data The data that was received
   */


  VirtualPaymentDevice.prototype.received = function received(base64Data) {
    this.device.received(base64Data);
  };

  /**
   * You must call this method when the device has been disconnected either by explicit disconnect
   * or external event.
   * @param {string} reasonMessage The reason for the disconnect
   */


  VirtualPaymentDevice.prototype.onDisconnected = function onDisconnected(reasonMessage) {
    this.device.onDisconnected(new Error(reasonMessage));
  };

  return VirtualPaymentDevice;
}();

function wrapCallback(callback) {
  return {
    accept: function accept() {
      if (callback) {
        callback();
      }
    },
    reject: function reject(errorMessage) {
      if (callback) {
        callback(new Error(errorMessage));
      }
    }
  };
}

/**
 * You must implement this function to begin a connection to the device
 * @callback VirtualPaymentDevice~connectFunction
 * @param {DeviceOperationResultHandler} resultHandler Called upon completion of the connect attempt
 */

/**
 * You must implement this function to determine whether the device is connected
 * @callback VirtualPaymentDevice~isConnectedFunction
 * @returns {bool} true if the device is currently connected
 */

/**
 * You must implement this function
 * @callback VirtualPaymentDevice~disconnectFunction
 * @param {DeviceOperationResultHandler} resultHandler Called upon completion of the disconnect attempt
 */

/**
 * You must implement this function to deliver bytes to the device
 * @callback VirtualPaymentDevice~sendFunction
 * @param {string} base64Data The data to be sent to the device
 * @param {int} offset The starting point in the string to begin sending data
 * @param {int} length The number of bytes to send to the device
 * @param {DeviceOperationResultHandler} resultHandler Called upon completion of the send attempt
 */

module.exports = VirtualPaymentDevice;

},{"../paymentDevice/MiuraDevice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/MiuraDevice.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/index.js":[function(require,module,exports){
'use strict';

module.exports = {
    MiuraDevice: require('./MiuraDevice'),
    MagtekRawUsbReaderDevice: require('./MagtekRawUsbReaderDevice'),
    VirtualPaymentDevice: require('./VirtualPaymentDevice')
};

},{"./MagtekRawUsbReaderDevice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/MagtekRawUsbReaderDevice.js","./MiuraDevice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/MiuraDevice.js","./VirtualPaymentDevice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/VirtualPaymentDevice.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/miura/ConnectionFlow.js":[function(require,module,exports){
'use strict';

var _retailPaymentDevice = require('retail-payment-device');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var manticore = require('manticore'),
    Flow = require('../../common/flow'),
    MiuraTags = require('miura-emv').Tags,
    SwUpdate = require('./MiuraSoftwareUpdate'),
    Merchant = require('../../common/Merchant'),
    Log = require('manticore-log')('paymentDevice.miura.connectionFlow');

var ConnectionFlow = function () {
    function ConnectionFlow(device) {
        _classCallCheck(this, ConnectionFlow);

        this.device = device;
    }

    ConnectionFlow.prototype.start = function start(callback) {
        var _this = this;

        var flow = new Flow(this, this._retrieveVersionInfo, this._displayReaderConnectingMessage, this._tryQuickConnect, this._getDeviceCapabilities, this._getDeviceConfig, this._queryBackendForSWModules, this._getP2PEStatus, this._getBatteryLevel);

        flow.name = 'Miura Connection';
        flow.on('completed', function () {
            return _this._readerConnected(callback);
        });
        flow.on('aborted', function (data) {
            if (callback) {
                callback(data.error);
            }
        });
        flow.start();
    };

    ConnectionFlow.prototype._tryQuickConnect = function _tryQuickConnect(flow) {
        if (!this.device.fullConnectionExecutedOn) {
            return flow.next();
        }

        //Allow quick connect for 8 hours
        var msSinceLastFullConnection = Date.now() - this.device.fullConnectionExecutedOn.getTime();
        if (msSinceLastFullConnection < ConnectionFlow.fullConnectValidityDurationMs) {
            Log.info('Skipping the full connection flow. Device was previously fully connected ' + msSinceLastFullConnection + 'ms ago');
            return flow.completeFlow();
        } else {
            Log.info('Redo a full connection as the device was previously fully connected ' + msSinceLastFullConnection + 'ms ago');
            this.device.fullConnectionExecutedOn = null;
            flow.next();
        }
    };

    ConnectionFlow.prototype._retrieveVersionInfo = function _retrieveVersionInfo(flow) {
        this.device.retrieveVersionInfo(function (e) {
            flow.nextOrAbort(e);
        });
    };

    ConnectionFlow.prototype._displayReaderConnectingMessage = function _displayReaderConnectingMessage(flow) {
        this.device.display(_retailPaymentDevice.PaymentDevice.Message.Connecting, null, function () {
            return flow.next();
        });
    };

    ConnectionFlow.prototype._getDeviceCapabilities = function _getDeviceCapabilities(flow) {
        var _this2 = this;

        this.device.terminal.Config.getDeviceCapabilities(function (e, devCaps) {
            if (devCaps && devCaps.caps) {
                _this2.device.capabilities = devCaps.caps;
                Log.debug(function () {
                    return 'Device caps: ' + JSON.stringify(devCaps.caps, null, '\t');
                });
            }
            flow.nextOrAbort(e);
        });
    };

    ConnectionFlow.prototype._getDeviceConfig = function _getDeviceConfig(flow) {
        var _this3 = this;

        this.device.terminal.Config.getConfiguration(function (e, config) {
            if (!e && !config.response.apdu.isSuccess) {
                e = (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.dataRetrievalFailed.withDevMessage('Failed to get terminal configuration.'));
            } else if (config) {
                _this3.device.swInfo = config.caps;
                Log.debug(function () {
                    return 'Software Info: ' + JSON.stringify(_this3.device.swInfo, null, '\t');
                });
            }
            flow.nextOrAbort(e);
        });
    };

    ConnectionFlow.prototype._queryBackendForSWModules = function _queryBackendForSWModules(flow) {

        //Avoid rechecking for updates on same device during reconnects
        if (this.exSerial !== this.device.serialNumber || !this.serverSwInfo) {
            // We are just kicking off the fetch here, the result will be stored
            // on the flow. So fetchSWInfoFromServer is not really a "part" of the
            // flow.
            this.exSerial = this.device.serialNumber;
            this._fetchSWInfoFromServer(flow);
        }
        flow.next();
    };

    ConnectionFlow.prototype._getP2PEStatus = function _getP2PEStatus(flow) {
        var _this4 = this;

        this.device.terminal.Config.getP2PEStatus(function (e, p2peStatus) {
            if (e) {
                return flow.abortFlow(e);
            }
            var stat = p2peStatus.apdu.tlvs.find(MiuraTags.MiuraP2PEStatus);
            if (!stat) {
                var error = (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.dataRetrievalFailed.withDevMessage('Unable to get encryption status for reader.'));
                return flow.abortFlow(error);
            }
            stat = stat.bytes[0];
            if (stat & 0x80) {
                _this4.device.p2pe = {
                    error: _this4._p2peError(stat)
                };
            } else {
                _this4.device.p2pe = {
                    init: !!(stat & 1),
                    pin: !!(stat & 2),
                    sred: !!(stat & 4)
                };
            }
            flow.data.finishedP2PE = true;
            if (flow.data.pendedUpdateInstruction) {
                _this4._checkP2PEWithUpdate(flow.data.pendedUpdateInstruction);
            }
            // Otherwise we'll check this when we get the p2pe info
            flow.next();
        });
    };

    ConnectionFlow.prototype._getBatteryLevel = function _getBatteryLevel(flow) {
        var _this5 = this;

        this.device.getBatteryInfo(function (e, rz) {
            if (!e) {
                _this5.device.fullConnectionExecutedOn = new Date();
                Log.debug(function () {
                    return 'Setting fullConnectionExecutedOn to ' + _this5.device.fullConnectionExecutedOn;
                });
                _this5.device.batteryStatus = rz;
            }
            flow.nextOrAbort(e);
        });
    };

    ConnectionFlow.prototype._fetchSWInfoFromServer = function _fetchSWInfoFromServer(f) {
        var _this6 = this;

        if (!Merchant.active) {
            Log.debug(function () {
                return _this6.device.id + ' Will perform software update check after Merchant initialize';
            });
            Merchant.events.once('initialized', function (e) {
                if (e) {
                    return Log.warn('Will not check for SW Update for ' + _this6.device.id + ' as merchant initialize failed with error: ' + e);
                }
                Log.debug('Checking software update post Merchant initialization');
                _this6._fetchSWInfoFromServer(f);
            });
            return;
        }

        // Kick off request for software info
        var body = JSON.stringify(this._generateUpdateRequest(this.device)),
            url = this._getSoftwareUpdateUrl(Merchant.active.environment, 'm010');
        Log.debug(function () {
            return 'Checking for SW Update for ' + _this6.device.id + '\n' + body;
        });
        manticore.http({
            url: url,
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: body,
            format: 'json'
        }, function (err, instr) {
            _this6.serverSwInfo = instr;
            if (err || !instr && !instr.body) {
                Log.warn('Could not get update instructions for ' + _this6.device.id + ' from ' + url + '\nRequest body:' + body);
                if (instr && instr.body) {
                    Log.warn(JSON.stringify(instr.body, null, '\t'));
                }
                return;
            }
            if (!f.data.finishedP2PE) {
                Log.debug('Pending update instruction until P2PE is complete.');
                f.data.pendedUpdateInstruction = instr.body && instr.body.phases;
                return;
            }
            if (instr.statusCode === 304) {
                return Log.debug(_this6.device.id + ' Software update not needed');
            }

            // TODO this is a bit squirrely because instr.body.phases could be invalid even if status code is !304
            _this6._checkP2PEWithUpdate(instr.body.phases);
        });
    };

    ConnectionFlow.prototype._checkP2PEWithUpdate = function _checkP2PEWithUpdate(modules) {
        Log.debug('Checking P2PE with update instructions');
        if (SwUpdate.needsUpdate(this.device, modules)) {
            this.device.updates = modules;
            SwUpdate.fetchFiles(this.device, function (e) {
                if (!e) {
                    Log.debug('Fetched all software update files.');
                }
            });
            this.updateRequired = true;
            this._notifyReaderUpdateRequired();
        }
    };

    ConnectionFlow.prototype._notifyReaderUpdateRequired = function _notifyReaderUpdateRequired() {
        Log.debug('notifying reader status');
        var d = this.device;
        if (d.updates || d._isKeyInjectionRequired) {
            Log.info(d.id + ' needs update. Updates(Count: ' + (d.updates ? d.updates.length : 0) + ') ' + JSON.stringify(d.updates) + ' KeyInjectionRequired: ' + d._isKeyInjectionRequired);
            d.updateRequired(new SwUpdate(this.device));
        }
    };

    ConnectionFlow.prototype._readerConnected = function _readerConnected(callback) {
        Log.debug('Completed connection sequence.');
        var d = this.device;
        return d.displayWithSystemIcons(_retailPaymentDevice.PaymentDevice.Message.Ready, null, function () {
            return callback && callback();
        });
    };

    ConnectionFlow.prototype._generateUpdateRequest = function _generateUpdateRequest(d) {
        var components = [{ name: 'Miura_OS', version: d.forceOsUpdate ? '0.0' : d.os.ver }, { name: 'Miura_MPI', version: d.forceMpiUpdate ? '0.0' : d.mpi.ver }];

        for (var k in d.swInfo) {
            var ver = d.forceConfigUpdate ? '0.0' : d.swInfo[k];
            components.push({ name: k, version: ver });
        }
        return components;
    };

    ConnectionFlow.prototype._p2peError = function _p2peError(v) {
        switch (v) {
            case 0x81:
                return 'Root Certificate Error';
            case 0x82:
                return 'Product Certificate Error';
            case 0x83:
                return 'Terminal Certificate Error';
            case 0x84:
                return 'Key Signing Key Error';
            case 0x85:
                return 'Internal Error, Contact PayPal';
            default:
                return 'Unknown Error (' + v + ')';
        }
    };

    ConnectionFlow.prototype._getSoftwareUpdateUrl = function _getSoftwareUpdateUrl(env, deviceModel) {

        var host = void 0,
            additionalParams = void 0,
            protocol = 'https';
        if (env === 'live') {
            host = 'api.paypal.com';
        } else if (env === 'sandbox') {
            host = 'api.sandbox.paypal.com';
        } else {
            host = 'pphstageexternal-vip.ext.external.paypalc3.com/proxy/retaildevicenodeweb9061/443';
            //host = 'localhost:8000';
            protocol = 'http';
            additionalParams = '&variant=dev';
        }

        return protocol + '://' + host + '/retail/hereretaildevice/US/miura/' + deviceModel + '/configuration?_c=' + Date.now() + (additionalParams || '');
    };

    return ConnectionFlow;
}();

ConnectionFlow.fullConnectValidityDurationMs = 8 * 60 * 60 * 1000; // 8 hours

module.exports = ConnectionFlow;

},{"../../common/Merchant":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Merchant.js","../../common/flow":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/flow.js","./MiuraSoftwareUpdate":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/miura/MiuraSoftwareUpdate.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","miura-emv":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/miura/MiuraSoftwareUpdate.js":[function(require,module,exports){
(function (Buffer){
'use strict';

var _retailPaymentDevice = require('retail-payment-device');

var _sdkErrors = require('../../common/sdkErrors');

var _miuraDeviceState = require('./miuraDeviceState');

var _miuraDeviceState2 = _interopRequireDefault(_miuraDeviceState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Message = _retailPaymentDevice.PaymentDevice.Message;

var manticore = require('manticore'),
    Log = require('manticore-log')('paymentDevice.miura.miuraSoftwareUpdate'),
    l10n = require('../../common/l10n'),
    Flow = require('../../common/flow'),
    RetailSDKUtil = require('../../common/RetailSDKUtil'),
    Merchant = require('../../common/Merchant'),
    DeviceUpdate = require('../DeviceUpdate'),
    md5 = require('md5'),
    async = require('async');

var isFetching = {};

// MUST BE DIVISIBLE BY 4!!!
var FILE_CHUNK_SIZE = 0x20000;
var IKSN_BUFFER = new Buffer('IKSN: ');
var TERMINAL_STREAM_TIMEOUT = 255;
var TERMINAL_CONNECTION_RETRY_LIMIT = 20;
var TERMINAL_CONNECTION_RETRY_TIMEOUT = 20000;
var TERMINAL_CONNECTION_DEFAULT_RETRY_TIMEOUT = 2500;
var MANTICORE_DEFAULT_SET_TIMEOUT = 5000;

if (FILE_CHUNK_SIZE % 4) {
    throw new Error('FILE_CHUNK_SIZE MUST BE DIVISIBLE BY 4!!!');
}

var MiuraSoftwareUpdate = function (_DeviceUpdate) {
    _inherits(MiuraSoftwareUpdate, _DeviceUpdate);

    function MiuraSoftwareUpdate(device) {
        _classCallCheck(this, MiuraSoftwareUpdate);

        return _possibleConstructorReturn(this, _DeviceUpdate.call(this, device));
    }

    MiuraSoftwareUpdate.prototype.setupFlows = function setupFlows() {
        var _this2 = this;

        this.files = {};
        var steps = this.computeSteps();
        this.flow = new Flow(this, steps);
        this.flow.name = 'Software Update';
        this.flow.on('completed', function () {
            _this2._closeAlert();
            _this2.device.pendingUpdate.isRequired = false;
            _this2.emit('completed');
            _this2.emit('ended', null, true);
            if (!_this2.device.isReady) {
                // TODO are we sure one update is enough?
                _this2.device.onConnected();
            }
        });
        this.flow.on('aborted', function (d) {
            Log.error('Software update failed with Error: ' + d.error);
            _this2.device.displayWithSystemIcons(Message.SoftwareUpdateFailed, null, function () {
                _this2._alert = manticore.alert({
                    title: l10n('SwUpgrade.Failed.Title'),
                    message: l10n('SwUpgrade.Failed.Msg'),
                    buttons: [l10n('SwUpgrade.Buttons.Retry'), l10n('SwUpgrade.Buttons.Cancel')]
                }, function (a, ix) {
                    if (ix === 0) {
                        return _this2.begin(_this2._showUi);
                    }
                    _this2._closeAlert();
                    _this2.emit('failed', d.error);
                    _this2.emit('ended', d.error, false);
                });
            });
        });
        this.flow.on('ended', function () {
            Log.debug('Ending flow');
            _this2.device.removeState(_miuraDeviceState2.default.softwareUpdate);
            _this2.device.startPollForBattery();
        });
    };

    MiuraSoftwareUpdate.prototype._closeAlert = function _closeAlert() {
        if (this._alert) {
            this._alert.dismiss();
            delete this._alert;
        }
    };

    MiuraSoftwareUpdate.prototype.computeSteps = function computeSteps() {
        var steps = [function stopPollingForBattery(flow) {
            this.device.stopPollForBattery();
            flow.next();
        }];
        if (this.device._isKeyInjectionRequired) {
            Log.debug('Should perform RKI.');
            steps.push(this.p2peFlow);
        }
        if (this.device.updates) {
            Log.debug('Should perform module updates.');
            steps.push(this.updateFlow);
        }

        return steps;
    };

    MiuraSoftwareUpdate.prototype.validateUpdateEligibility = function validateUpdateEligibility(callback) {
        var _this3 = this;

        var _canUpdate = !this.isBatteryUpdateCritical();
        if (_canUpdate) {
            callback();
        } else {
            this.device.display(Message.RechargeNow, null, function () {
                _this3._alert = manticore.alert({
                    title: l10n('SwUpgrade.Failed.Title'),
                    message: l10n('SwUpgrade.Failed.BatteryLow'),
                    cancel: l10n('Ok')
                }, function (alertView, index) {
                    alertView.dismiss();
                    callback((0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.lowOnBattery));
                });
            });
        }
    };

    MiuraSoftwareUpdate.prototype.isBatteryUpdateCritical = function isBatteryUpdateCritical() {
        return this.device.batteryStatus && this.device.batteryStatus.isLevelUpdateCritical;
    };

    MiuraSoftwareUpdate.prototype.begin = function begin(showUi, callback) {
        var _this4 = this;

        Log.debug('Beginning software update.');
        this.device.addState(_miuraDeviceState2.default.softwareUpdate);
        if (showUi) {
            this._showUi = true;
            this._alert = manticore.alert({
                title: l10n('SwUpgrade.Updating.Title'),
                message: l10n('SwUpgrade.Updating.Msg'),
                showActivity: true
            }, function (av, ix) {});
        }
        this.setupFlows();
        this.flow.start();
        this.once('ended', function (e, upgraded) {
            Log[e ? 'error' : 'info']('Software update completed on ' + _this4.device.id + '. Was updated: ' + upgraded + '. ' + (e ? 'Error: ' + e : ''));
            callback(e, upgraded);
        });
    };

    MiuraSoftwareUpdate.prototype.p2peFlow = function p2peFlow(flow) {
        var subflow = new Flow(this, this.showP2PEMessage, this.initializeP2PE, this.getP2PEMaterial, this.showP2PEFetchMessage, this.fetchKeys, this.copyKeys, this.importKeys, this.showKeysDone, this.checkFurtherFlow);
        subflow.name = 'P2PE Setup';
        subflow.on('completed', function () {
            return flow.next();
        });
        subflow.on('aborted', function (d) {
            return flow.abortFlow(d.error);
        });
        subflow.start();
    };

    MiuraSoftwareUpdate.prototype.updateFlow = function updateFlow(flow) {
        var subflow = new Flow(this, this.gatherFiles, this.updateOS, this.waitForRestart, this.updateMPI, this.waitForRestart, this.updateConfig, this.waitForRestart);
        subflow.name = 'Software Update';
        subflow.on('completed', function () {
            return flow.next();
        });
        subflow.on('aborted', function (d) {
            return flow.abortFlow(d.error);
        });
        subflow.start();
    };

    MiuraSoftwareUpdate.prototype.gatherFiles = function gatherFiles(flow) {
        flow.data.updates = {};
        for (var _iterator = this.device.updates, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var u = _ref;

            flow.data.updates[u.name] = u;
        }
        MiuraSoftwareUpdate.fetchFiles(this.device, function (e) {
            Log.debug('Ready for software update.');
            flow.nextOrAbort(e);
        });
    };

    /**
     * This is a bit crazy... BUT, after p2pe is done, we may know more about the other updates
     * required. So in this step we'll see if there is a furtner update, and then update the flow
     * in-place with the new steps. This may cause our estimates to be off, but not sure what else
     * to do if we want to get the process started ASAP yet make sure all updates are applied
     * when available.
     * @param flow
     */


    MiuraSoftwareUpdate.prototype.checkFurtherFlow = function checkFurtherFlow(flow) {
        flow.next();
    };

    MiuraSoftwareUpdate.prototype.sizeFiles = function sizeFiles(steps, callback) {
        var _this5 = this;

        var size = 0;
        async.each(steps, function (step, cbFileFetched) {
            var url = step.url,
                name = step.name;
            _this5.getFetchedFile(url, name, function (err, file) {
                if (file) {
                    size += file.length;
                }

                cbFileFetched();
            });
        }, function () {
            return callback(size);
        });
    };

    MiuraSoftwareUpdate.prototype.writeFiles = function writeFiles(steps, stageId, callback) {
        var _this6 = this;

        if (steps.length === 0) {
            Log.error('Attempting to write 0 files to device.');
            return callback();
        }
        Log.info('Writing ' + steps.length + ' software update files to ' + this.device.id);
        var ix = 0,
            totalSize = 0,
            done = 0,
            lastWasRetry = false,
            writer = function writer() {
            var url = steps[ix].url,
                name = steps[ix].name;
            _this6.getFetchedFile(url, name, function (err, file) {
                var finalName = name;
                if (!finalName) {
                    finalName = url.split('/');
                    finalName = finalName[finalName.length - 1];
                }
                _this6.device.terminal.Config.selectFile(finalName, true, function (selError, selRz) {
                    selError = _this6.device.errorOrFailure(selError, selRz);
                    if (selError) {
                        Log.error('selectFile command returned an error : ' + selError);
                        miuraLogs(true);
                        return callback(selError);
                    }
                    miuraLogs(false);
                    chunkItOut({
                        this: _this6,
                        device: _this6.device,
                        file: file,
                        name: finalName,
                        total: totalSize,
                        done: done,
                        stageId: stageId
                    }, function (writeError, writeResult) {
                        writeError = _this6.device.errorOrFailure(writeError, writeResult);
                        if (!writeError) {
                            lastWasRetry = false;
                            done += file.length;
                            if (++ix >= steps.length) {
                                miuraLogs(true);
                                callback();
                            } else {
                                writer();
                            }
                        } else {
                            Log.error('Failed to write ' + steps[ix].url + ' to ' + finalName + ': ' + writeError.message + '. ' + (lastWasRetry ? 'Will not retry' : 'Will retry'));
                            if (lastWasRetry) {
                                miuraLogs(true);
                                return callback(writeError);
                            } else {
                                writer();
                            }
                        }
                    });
                });
            });
        };
        this.sizeFiles(steps, function (_sz) {
            totalSize = _sz;
            writer();
        });
    };

    MiuraSoftwareUpdate.prototype.updateOS = function updateOS(flow) {
        var osUpdates = flow.data.updates.Miura_OS;
        if (!osUpdates && !this.device.forceOsUpdate) {
            Log.debug('OS update not needed.');
            return flow.next();
        }
        this.updateModules(flow, osUpdates.steps, 'OS');
    };

    MiuraSoftwareUpdate.prototype.updateMPI = function updateMPI(flow) {
        var mpiUpdate = flow.data.updates.Miura_MPI;
        if (!mpiUpdate && !this.device.forceMpiUpdate) {
            Log.debug('MPI update not needed.');
            return flow.next();
        }
        this.updateModules(flow, mpiUpdate.steps, 'MPI');
    };

    MiuraSoftwareUpdate.prototype.updateConfig = function updateConfig(flow) {
        var cfgUpdates = flow.data.updates.Miura_CONFIG;
        if (!cfgUpdates || !cfgUpdates.steps) {
            Log.debug('Config update not needed.');
            return flow.next();
        }

        var filesToCopy = [];
        for (var _iterator2 = cfgUpdates.steps, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
            } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
            }

            var sub = _ref2;

            filesToCopy.push(sub);
        }
        if (filesToCopy.length === 0) {
            return flow.next();
        }

        // USB bug requires reader to be manually unplugged and replugged after config file push
        if (this.device.isUsb && this.device.mpi && (this.device.mpi.majorVer < 1 || this.device.mpi.majorVer === 1 && this.device.mpi.minorVer <= 34)) {
            Log.info('Reader version that requires device plug/unplug detected. ' + this.device.mpi.ver + '. ShowUI : ' + this._showUi);
            this.promptForUnplug = true;
        }

        this.updateModules(flow, filesToCopy, 'Config');
    };

    /**
     * Prompt user to Unplug and replug the reader
     */


    MiuraSoftwareUpdate.prototype.waitForUsbUnplugAndPlug = function waitForUsbUnplugAndPlug(cb) {
        var _this7 = this;

        if (!this._showUi) {
            Log.info(this.device.id + ' Waiting 20 seconds for USB unplug/replug...');
            this.emit('reconnectReader', TERMINAL_CONNECTION_RETRY_TIMEOUT);
            return manticore.setTimeout(cb, TERMINAL_CONNECTION_RETRY_TIMEOUT);
        }

        this._alert = manticore.alert({
            title: l10n('SwUpgrade.Updating.Title'),
            message: l10n('SwUpgrade.Usb.UsbUnplug'),
            buttons: [l10n('Ok')]
        }, function () {
            _this7._alert = manticore.alert({
                title: l10n('SwUpgrade.Updating.Title'),
                message: l10n('SwUpgrade.Usb.UsbWait')
            }, function () {});
            manticore.setTimeout(function () {
                _this7._alert = manticore.alert({
                    title: l10n('SwUpgrade.Updating.Title'),
                    message: l10n('SwUpgrade.Usb.UsbPlug')
                }, function () {});
                cb();
            }, MANTICORE_DEFAULT_SET_TIMEOUT);
        });
    };

    MiuraSoftwareUpdate.prototype.updateModules = function updateModules(flow, steps, stageId) {
        var _this8 = this;

        this._alert = manticore.alert({
            title: l10n('SwUpgrade.Updating.Title'),
            message: l10n('SwUpgrade.Updating' + stageId, { progress: '0' }),
            showActivity: true
        }, function (av, ix) {});
        this.device.display(Message.SoftwareUpdateProgress, {
            stage: stageId,
            progress: '0'
        }, function () {
            _this8.writeFiles(steps, stageId, function (writeError) {
                if (writeError) {
                    return flow.abortFlow(writeError);
                }
                _this8.resetReader(flow);
            });
        });
    };

    MiuraSoftwareUpdate.prototype.resetReader = function resetReader(flow) {
        var _this9 = this;

        this._alert = manticore.alert({
            title: l10n('SwUpgrade.Updating.Title'),
            message: l10n('SwUpgrade.Restarting'),
            showActivity: true
        }, function (av, ix) {});
        this.device.hardReset(function () {
            flow.data.awaitReset = true;
            _this9.device.disconnect(function () {
                Log.debug('Reader disconnected');
                flow.next();
            });
        });
    };

    MiuraSoftwareUpdate.prototype.waitForRestart = function waitForRestart(flow) {
        var _this10 = this;

        if (!flow.data.awaitReset) {
            return flow.next();
        }

        var waitConnect = function waitConnect() {
            Log.debug('Waiting for reconnect.');
            _this10._alert = manticore.alert({
                title: l10n('SwUpgrade.Updating.Title'),
                message: l10n('SwUpgrade.Reconnecting'),
                showActivity: true
            }, function (av, ix) {});
            manticore.setTimeout(function () {
                _this10.waitForConnect(TERMINAL_CONNECTION_RETRY_LIMIT, function (e) {
                    _this10.device.retrieveVersionInfo(function () {
                        flow.nextOrAbort(e);
                    });
                }, TERMINAL_CONNECTION_RETRY_TIMEOUT);
            }, MANTICORE_DEFAULT_SET_TIMEOUT);
            delete flow.data.awaitReset;
        };

        if (!this.promptForUnplug) {
            return waitConnect();
        }

        manticore.setTimeout(function () {
            _this10.waitForUsbUnplugAndPlug(function () {
                delete _this10.promptForUnplug;
                waitConnect();
            });
        }, MANTICORE_DEFAULT_SET_TIMEOUT);
    };

    MiuraSoftwareUpdate.prototype.waitForConnect = function waitForConnect(tryCount, cb, waitTime) {
        Log.debug('waitForConnect with retry count ' + tryCount);
        this.device.needsRestart = true;
        this.retryConnection(tryCount, cb, waitTime);
    };

    MiuraSoftwareUpdate.prototype.retryConnection = function retryConnection(tryCount, cb, waitTime) {
        var _this11 = this;

        if (!this.device.needsRestart) {
            return;
        }
        miuraLogs(false);
        manticore.setTimeout(function () {
            Log.debug('Attempting connection with retryCount ' + tryCount);
            var oldRaw = _this11.device.rawConnect;
            _this11.device.rawConnect = true;
            if (_this11.device.needsRestart) {
                _this11.device.connect(function (e) {
                    _this11.device.rawConnect = oldRaw;
                    if (e) {
                        Log.warn('Reconnect failed with error ' + e + ' retry count: ' + tryCount);
                        if (--tryCount <= 0) {
                            miuraLogs(true);
                            Log.debug('Giving up!');
                            cb && cb(e);
                        } else {
                            _this11.retryConnection(tryCount, cb, waitTime);
                        }
                    } else {
                        Log.info(_this11.device.id + ' was successfully connected after restart');
                        _this11._alert = manticore.alert({
                            title: l10n('SwUpgrade.Updating.Title'),
                            message: l10n('SwUpgrade.Connected'),
                            showActivity: true
                        }, function (av, ix) {});
                        miuraLogs(true);
                        delete _this11.device.needsRestart;
                        cb && cb();
                    }
                });
            }
        }, waitTime ? waitTime : TERMINAL_CONNECTION_DEFAULT_RETRY_TIMEOUT);
    };

    MiuraSoftwareUpdate.prototype.showP2PEMessage = function showP2PEMessage(flow) {
        this._alert = manticore.alert({
            title: l10n('SwUpgrade.Updating.Title'),
            message: l10n('SwUpgrade.Initializing'),
            showActivity: true
        }, function (av, ix) {});
        this.device.display(Message.SoftwareUpdateProgress, { stage: 'EncryptInit' }, function () {
            return flow.next();
        });
    };

    MiuraSoftwareUpdate.prototype.showP2PEFetchMessage = function showP2PEFetchMessage(flow) {
        this._alert = manticore.alert({
            title: l10n('SwUpgrade.Updating.Title'),
            message: l10n('SwUpgrade.ValidatingSecurityKeys'),
            showActivity: true
        }, function (av, ix) {});
        this.device.display(Message.SoftwareUpdateProgress, { stage: 'EncryptGet' }, function () {
            return flow.next();
        });
    };

    MiuraSoftwareUpdate.prototype.showKeysDone = function showKeysDone(flow) {
        this._alert = manticore.alert({
            title: l10n('SwUpgrade.Updating.Title'),
            message: l10n('SwUpgrade.SecurityKeysInstalled'),
            showActivity: true
        }, function (av, ix) {});
        delete this.device.forceRki;
        this.device.display(Message.SoftwareUpdateProgress, { stage: 'EncryptDone' }, function () {
            return flow.next();
        });
    };

    MiuraSoftwareUpdate.prototype.initializeP2PE = function initializeP2PE(flow) {
        if (this.device.p2pe.init) {
            Log.debug('P2PE already initialized.');
            flow.data.skippedInit = true;
            return flow.next();
        }

        this.device.terminal.Config.initializeP2PE(function (err, rz) {
            if (!err && !rz.apdu.isSuccess) {
                err = (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.initializationFailed.withDevMessage('Failed to initialize device encryption keys.'));
            }
            flow.nextOrAbort(err);
        });
    };

    MiuraSoftwareUpdate.prototype.getFileStep = function getFileStep(key, name) {
        var _this12 = this;

        return function (subflow) {
            _this12.device.terminal.Config.getFile(name, function (err, fileContent) {
                if (err) {
                    return subflow.abortFlow(err);
                }
                _this12.files[key] = fileContent.toString();
                subflow.next();
            });
        };
    };

    MiuraSoftwareUpdate.prototype.getP2PEMaterial = function getP2PEMaterial(flow) {
        var _this13 = this;

        var fileFlow = new Flow(this, this.getFileStep('initialKSN', 'suggested-iksn.txt'), this.getFileStep('signedProductSigningCert', 'prod-sign.crt'), this.getFileStep('signedTerminalCert', 'terminal.crt'), this.getFileStep('signedKeyLoadingCert', 'temp-keyload.crt'));
        fileFlow.name = 'Get P2PE File';
        fileFlow.on('completed', function () {
            miuraLogs(true);
            flow.next();
        });
        fileFlow.on('aborted', function (d) {
            miuraLogs(true);
            if (flow.data.skippedInit) {
                delete flow.data.skippedInit;
                _this13.device.p2pe.init = false;
                Log.warn('P2PE initialization was faulty, retrying.');
                return flow.back();
            }
            flow.abortFlow(d.error);
        });
        miuraLogs(false);
        fileFlow.start();
    };

    MiuraSoftwareUpdate.prototype.fetchKeys = function fetchKeys(flow) {
        var self = this;
        this.files.initialKSN = this.files.initialKSN.replace(/\n/g, '').replace('IKSN: ', '');
        Merchant.active.request({
            service: 'retail',
            op: 'cardReaderDevice/MIURA/' + this.device.model + '/keys',
            format: 'json',
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(this.files)
        }, function (error, keyResponse) {
            if (error) {
                return flow.abortFlow(error);
            }
            self.filesToWrite = [];
            flow.data.fileWriteIndex = 0;
            for (var k in keyResponse.body) {
                self.filesToWrite.push(keyResponse.body[k]);
            }
            flow.next();
        });
    };

    MiuraSoftwareUpdate.prototype.copyKeys = function copyKeys(flow) {
        var _this14 = this;

        var self = this;
        if (this.filesToWrite.length > flow.data.fileWriteIndex) {
            var f = this.filesToWrite[flow.data.fileWriteIndex];
            this.device.terminal.Config.selectFile(f.filename, true, function (e, rz) {
                if (e) {
                    return flow.abortFlow(e);
                }
                var data = new Buffer(f.content, f.type === 'BASE64' ? 'base64' : 'utf8');
                if (f.filename.indexOf('-iksn-') > 0 && (data.length < IKSN_BUFFER.length || !data.slice(0, IKSN_BUFFER.length).equals(IKSN_BUFFER))) {
                    // The content must start with IKSN:
                    data = Buffer.concat([IKSN_BUFFER, data], IKSN_BUFFER.length + data.length);
                }

                var dataMD5 = md5(data);
                Log.debug(function () {
                    return 'Sending file: ' + data.toString('hex') + ' \nMD5: ' + dataMD5;
                });
                _this14.device.terminal.Config.streamBinary(data, 0, 0xFF, dataMD5, function (writeError, writeResult) {
                    if (writeError) {
                        return flow.abortFlow(writeError);
                    }
                    if (!writeResult.apdu.isSuccess) {
                        return flow.abortFlow((0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.initializationFailed.withDevMessage('Failed to update encryption keys.')));
                    }
                    flow.data.fileWriteIndex++;
                    self.copyKeys(flow);
                });
            });
        } else {
            flow.next();
        }
    };

    MiuraSoftwareUpdate.prototype.importKeys = function importKeys(flow) {
        this.device.terminal.Config.importP2PE(function (err, rz) {
            if (!err && !rz.apdu.isSuccess) {
                err = new Error((0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.fileImportFailed.withDevMessage('Failed to import encryption keys.')));
            }
            flow.nextOrAbort(err);
        });
    };

    MiuraSoftwareUpdate.prototype.getFetchedFile = function getFetchedFile(url, name, cb) {
        manticore.getItem(name + ':' + url, RetailSDKUtil.StorageType.Blob, function (e, file) {
            if (file) {
                return cb(null, file);
            }
            cb((0, _retailPaymentDevice.getError)(new Error(), _sdkErrors.sdk.fileNotFound.withDevMessage('File with name ' + name + ' and url: ' + url + ' was not found on the device')));
        });
    };

    MiuraSoftwareUpdate.fetchFiles = function fetchFiles(device, callback) {
        var filesToFetch = [],
            finalError,
            fetchCtr = 0;
        MiuraSoftwareUpdate.needsUpdate(device, device.updates, true, filesToFetch);
        for (var _iterator3 = filesToFetch, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
            var _ref3;

            if (_isArray3) {
                if (_i3 >= _iterator3.length) break;
                _ref3 = _iterator3[_i3++];
            } else {
                _i3 = _iterator3.next();
                if (_i3.done) break;
                _ref3 = _i3.value;
            }

            var f = _ref3;

            fetchCtr++;
            getOne(f[0], f[1], function (err, rz) {
                finalError = finalError || err;
                if (--fetchCtr === 0) {
                    Log.debug('Software update files have been fetched.');
                    if (callback) {
                        callback(finalError, filesToFetch);
                    }
                }
            });
        }
        if (fetchCtr === 0) {
            callback(null, filesToFetch);
        } else {
            Log.debug('Fetching ' + fetchCtr + ' update files');
        }
    };

    MiuraSoftwareUpdate.needsUpdate = function needsUpdate(device, modules, silent, requiredUrlArray) {
        var hasUpdate = false;
        for (var _iterator4 = modules, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
            var _ref4;

            if (_isArray4) {
                if (_i4 >= _iterator4.length) break;
                _ref4 = _iterator4[_i4++];
            } else {
                _i4 = _iterator4.next();
                if (_i4.done) break;
                _ref4 = _i4.value;
            }

            var _module = _ref4;

            if (_module.name === 'Miura_OS') {
                hasUpdate = true;
                if (!silent) {
                    Log.info(device.id + ' OS will be updated from ' + device.os.id + '-' + device.os.ver + ' to ' + _module.version);
                }
                pushModules(requiredUrlArray, _module.steps);
            } else if (_module.name === 'Miura_MPI') {
                hasUpdate = true;
                if (!silent) {
                    Log.info(device.id + ' MPI will be updated from ' + device.mpi.id + '-' + device.mpi.ver + ' to ' + _module.version);
                }
                pushModules(requiredUrlArray, _module.steps);
            } else if (_module.name === 'Miura_CONFIG') {
                hasUpdate = true;
                if (!silent) {
                    Log.info(device.id + ' CFG will be updated');
                }
                pushModules(requiredUrlArray, _module.steps);
            }
        }
        if (!silent && !hasUpdate) {
            Log.debug(device.id + ' does not need an upgrade.');
        }
        return hasUpdate;
    };

    return MiuraSoftwareUpdate;
}(DeviceUpdate);

function pushModules(requiredUrlArray, steps) {
    if (requiredUrlArray) {
        for (var _iterator5 = steps, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
            var _ref5;

            if (_isArray5) {
                if (_i5 >= _iterator5.length) break;
                _ref5 = _iterator5[_i5++];
            } else {
                _i5 = _iterator5.next();
                if (_i5.done) break;
                _ref5 = _i5.value;
            }

            var m = _ref5;

            requiredUrlArray.push([m.url, m.name]);
        }
    }
}

var lastMiuraLogState, switchedOff;

/**
 * Shut off the Miura debug logs except our own component,
 * then reset them to where they were when done.
 * @param on
 */
function miuraLogs(on) {
    var exl = require('manticore-log')('paymentDevice.miuraDevice');
    if (on && switchedOff) {
        switchedOff = false;
        if (lastMiuraLogState) {
            exl.Config.level = lastMiuraLogState;
        } else {
            delete exl.Config.level;
        }
        delete Log.Config.level;
        Log.debug('Re-enabled logs.');
    } else if (!on && !switchedOff) {
        Log.debug('Squelching Miura debug logs.');
        lastMiuraLogState = exl.Config.level;
        switchedOff = true;
        exl.Config.level = 'INFO';
        Log.Config.level = 'DEBUG';
    }
}

function getOne(file, name, cb, retryCount) {
    var key = name + ':' + file;
    manticore.getItem(key, RetailSDKUtil.StorageType.Blob, function (error, item) {
        if (item) {
            return manticore.setTimeout(function () {
                cb(null, item);
            }, 0);
        }
        Log.debug(function () {
            return 'Fetching terminal update file ' + file;
        });
        // If a fetch is already in progress, and we're not it, don't do it twice.
        if (!retryCount) {
            if (isFetching[key]) {
                Log.debug(function () {
                    return 'Waiting for existing fetch of ' + file;
                });
                return isFetching[key].push(cb);
            }
            isFetching[key] = [cb];
        }
        manticore.http({
            url: file,
            format: 'binary'
        }, function (err, rz) {
            Log.debug('Done with ' + file + ': ' + (err ? 'error' : 'ok'));
            if (!err && file.indexOf('MPI-Dynamic.cfg') > 0) {
                fixMpiDynamic(rz);
            }
            if (!err) {
                manticore.setItem(key, RetailSDKUtil.StorageType.Blob, rz.body, null);
            } else if (retryCount < 2) {
                retryCount = retryCount || 0;
                Log.debug(function () {
                    return 'Fetch failed for ' + file + '. Starting retry #{retryCount+1}';
                });
                return getOne(file, name, cb, (retryCount || 0) + 1);
            }
            for (var _iterator6 = isFetching[key], _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
                var _ref6;

                if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    _i6 = _iterator6.next();
                    if (_i6.done) break;
                    _ref6 = _i6.value;
                }

                var callback = _ref6;

                callback(err, rz);
            }
            delete isFetching[key];
        });
    });
}

function chunkItOut(options, callback, base64Offset, startTime, isRetry) {
    if (!startTime) {
        startTime = new Date().getTime();
    }
    base64Offset = base64Offset || 0;
    var binaryOffset = base64Offset * 3 / 4;
    if (options.file.length - base64Offset > FILE_CHUNK_SIZE) {
        var chunk = options.file.substring(base64Offset, base64Offset + FILE_CHUNK_SIZE);

        Log.debug(function () {
            return 'Pushing chunk of file: ' + options.name + ' ' + FILE_CHUNK_SIZE * 3 / 4 + '@' + binaryOffset + ' of ' + options.file.length * 3 / 4;
        });
        options.device.terminal.Config.streamBinary(chunk, binaryOffset, TERMINAL_STREAM_TIMEOUT, false, function (writeError, writeRz) {
            if (writeError || !writeRz.apdu.isSuccess) {
                if (isRetry) {
                    Log.error('Aborting file send early.');
                    if (writeRz) {
                        Log.warn(writeRz.toString());
                    }
                    return callback(writeError, writeRz);
                } else {
                    Log.warn('Failed to push a chunk of file ' + options.name + '. Will retry. Response: ' + writeRz);
                    // Give it a half a second to recover and try the same segment again
                    return manticore.setTimeout(function () {
                        return chunkItOut(options, callback, base64Offset, binaryOffset, startTime, true);
                    }, 500);
                }
            }
            var progress = parseInt((options.done + base64Offset + FILE_CHUNK_SIZE) * 100 / options.total);
            options.this._alert = manticore.alert({
                title: l10n('SwUpgrade.Updating.Title'),
                message: l10n('SwUpgrade.Updating' + options.stageId, { progress: progress }),
                showActivity: true
            }, function (av, ix) {});
            options.device.display(Message.SoftwareUpdateProgress, {
                stage: options.stageId,
                progress: progress
            }, function () {
                return chunkItOut(options, callback, base64Offset + FILE_CHUNK_SIZE, startTime);
            });
        });
    } else {
        var _chunk = options.file.substring(base64Offset);
        Log.debug(function () {
            return 'Completing transfer of ' + options.name;
        });
        options.device.terminal.Config.streamBinary(_chunk, binaryOffset, TERMINAL_STREAM_TIMEOUT, false, callback);
    }
}

module.exports = MiuraSoftwareUpdate;

/**
 * While USB is not the default, make sure MPI-Dynamic has it
 * @param rz
 */
function fixMpiDynamic(rz) {
    var mpidynamic = new Buffer(rz.body, 'base64').toString();
    if (!mpidynamic.indexOf('[USB]')) {
        mpidynamic = '[USB]\n\tdefault = serial\n' + mpidynamic;
        rz.body = new Buffer(mpidynamic).toString('base64');
    }
}

}).call(this,require("buffer").Buffer)
},{"../../common/Merchant":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Merchant.js","../../common/RetailSDKUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/RetailSDKUtil.js","../../common/flow":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/flow.js","../../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../../common/sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","../DeviceUpdate":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/DeviceUpdate.js","./miuraDeviceState":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/miura/miuraDeviceState.js","async":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/async/lib/async.js","buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","md5":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/md5/md5.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/paymentDevice/miura/miuraDeviceState.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;
/**
 * Indicates the current state of the device
 */
var deviceState = {
  unknown: 0,
  softwareUpdate: 1,
  hardResetting: 2
};

exports.default = deviceState;

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/sdk.js":[function(require,module,exports){
'use strict';

// PLEASE NOTE! This is a bit of a funny class on the native side. It exposes top level
// events and methods (maybe properties someday too) but it is not directly exposed
// to partners. Instead, they are presented with a "singleton" type interface typically called
// PayPalRetailSDK. Then the methods/events/properties of THIS object are proxied via that singleton
// to the instance that the engine startup process makes.
// SOOOO.... this means a few unpleasant things that were deemed ok for now:
//      1. If you change comments here, you will need to manually update PayPalRetailSDK in each platform
//      2. If you change or add events or methods here you will need to update each platform
//      3. Because of 1 and 2, ask yourself - does my event/property REALLY belong at the top level?

var _TransactionContext = require('./transaction/TransactionContext');

var _TransactionContext2 = _interopRequireDefault(_TransactionContext);

var _sdkErrors = require('./common/sdkErrors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = require('manticore-log')('sdk'),
    RawLogs = require('manticore-log'),
    EventEmitter = require('events').EventEmitter,
    PaymentDevice = require('retail-payment-device').PaymentDevice,
    manticore = require('manticore'),
    Cal = require('./common/cal'),

// TODO move TC to transaction and not flows...
Merchant = require('./common/Merchant'),
    SdkFeatures = require('./common/Features');

/**
 * The PayPal Here SDK object is the main entry point for all SDK operations. Because we provide
 * native-specific versions of the highest level interface, this class is essentially used
 * as a helper for binding top level events (such as a new card reader) to the native partner objects.
 * @protected
 * @class
 */

var SDK = function (_EventEmitter) {
    _inherits(SDK, _EventEmitter);

    function SDK() {
        _classCallCheck(this, SDK);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        PaymentDevice.Events.on(SDK.Event.deviceDiscovered, function (d) {
            return _this.emit(SDK.Event.deviceDiscovered, d);
        });
        SdkFeatures.loadRemoteFeatureMap();
        _this.setupCalLogging();
        return _this;
    }

    SDK.prototype.setupCalLogging = function setupCalLogging() {
        Cal.newGroup(Date.now());
        var flushLogs = function flushLogs() {
            var pauseAndFlush = function pauseAndFlush() {
                return manticore.setTimeout(flushLogs, 10 * 1000);
            };
            if (Merchant.active) {
                Cal.flush(function (err, count) {
                    if (count || err) {
                        Log.debug(function () {
                            return 'Flushed ' + (count || 0) + ' cal log messages. ' + (err ? 'Error: ' + err : '');
                        });
                    }
                    pauseAndFlush();
                });
            } else {
                pauseAndFlush();
            }
        };

        Cal.attach(flushLogs);
    };

    SDK.prototype.initializeMerchant = function initializeMerchant(token, callback) {
        var _this2 = this;

        // TODO blow up if they're already initialized? Logout?
        new Merchant().initialize(token, function (e, m) {
            if (!e && m) {
                _this2.emit('merchantInitialized', m);
            }
            callback(e, m);
        });
    };

    SDK.prototype.error = function error(message) {
        return new Error(message);
    };

    /*
     * Create a transaction context for an invoice
     * @param {Invoice} invoice
     * @returns {TransactionContext} context
     */


    SDK.prototype.createTransaction = function createTransaction(invoice) {
        if (!Merchant.active) {
            throw (0, _sdkErrors.getError)(new Error(), _sdkErrors.merchant.notInitialized.withDevMessage('You must have an active merchant to create a transaction. Call InitializeMerchant first, and wait for it to complete.'));
        }
        return new _TransactionContext2.default(invoice, Merchant.active);
    };

    /**
     * Log a message via the Javascript logging framework (called by native to get all the side benefits of JS logging, like CAL)
     * @param {string} level
     * @param {string} component
     * @param {string} message
     * @param {object} extraData
     */


    SDK.prototype.logViaJs = function logViaJs(level, component, message, extraData) {
        try {
            RawLogs(component)[level](message);
        } catch (x) {
            Log.debug('Failed to log native message: ' + level + ' ' + component + ' ' + message);
        }
    };

    /**
     * Information that represents the executing platform
     * @param {string} deviceId An identifier of the device
     * @param {string} osInfo Operating system name and version
     * @param {string} appName Name of the executing application
     */


    SDK.prototype.setExecutingEnvironment = function setExecutingEnvironment(deviceId, osInfo, appName) {
        this.envInfo = (deviceId + '.' + osInfo + '.' + appName).replace(/\s+/g, '');
        Cal.setRequestSourceId(this.envInfo);
        Log.info('Setting RetailSDK executing environment to: ' + this.envInfo);
    };

    /*
     * Register a PaymentDevice and notify listeners of the new device.
     * @param {PaymentDevice} pd
     */


    SDK.prototype.discoveredPaymentDevice = function discoveredPaymentDevice(pd) {
        PaymentDevice.discovered(pd);
    };

    /*
     * Perform cleanup before shutting down the host application
     */


    SDK.prototype.shutdown = function shutdown() {
        for (var _iterator = PaymentDevice.devices, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var pd = _ref;

            pd.disconnectUsb && pd.disconnectUsb(function () {});
        }
    };

    return SDK;
}(EventEmitter);

SDK.Event = {
    deviceDiscovered: 'deviceDiscovered'
};

/**
 * A PaymentDevice has been discovered. For further events, such as device readiness, removal or the
 * need for a software upgrade, your application should subscribe to the relevant events on the device
 * parameter. Please note that this doesn't always mean the device is present. In certain cases (e.g. Bluetooth)
 * we may know about the device independently of whether it's currently connected or available.
 * @event SDK#deviceDiscovered
 * @param {PaymentDevice} device The device that has been discovered.
 */

var sdk = module.exports = new SDK();

},{"./common/Features":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Features.js","./common/Merchant":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Merchant.js","./common/cal":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/cal.js","./common/sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","./transaction/TransactionContext":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/TransactionContext.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/Payer.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = require('manticore-util');

/**
 * Information about the payer of a transaction, including saved receipt information if
 * available
 * @class
 * @property {string} customerId An identifier for this customer that is specific to your merchant account
 * @property {string} receiptPreferenceToken A token used to send receipts and save/use previously used email address or phone number
 * @property {string} maskedEmail An email address previously used for this payment instrument, with portions masked for privacy
 * @property {string} maskedPhone A masked phone number previously used for this payment instrument
 */

var Payer = function Payer(response) {
    _classCallCheck(this, Payer);

    if (response) {
        util.assignSome(this, response, ['customerId', 'receiptPreferenceToken', 'maskedEmail', 'maskedPhone']);
    }
};

module.exports = Payer;

},{"manticore-util":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/ReceiptViewContent.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.ReceiptViewContent = exports.ReceiptSMSEntryViewContent = exports.ReceiptEmailEntryViewContent = exports.ReceiptOptionsViewContent = undefined;

var _l10n = require('../common/l10n');

var _l10n2 = _interopRequireDefault(_l10n);

var _RetailSDKUtil = require('../common/RetailSDKUtil');

var _RetailSDKUtil2 = _interopRequireDefault(_RetailSDKUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The content to be presented natively in the receipt options screen.
 * @class
 * @property {string} title
 * @property {string} message
 * @property {string} titleIconFilename
 * @property {string} maskedEmail
 * @property {string} maskedPhone
 * @property {string} disclaimer
 * @property {string} emailButtonTitle
 * @property {string} smsButtonTitle
 * @property {string} noThanksButtonTitle
 * @property {[string]} additionalReceiptOptions
 */
var ReceiptOptionsViewContent = exports.ReceiptOptionsViewContent = function ReceiptOptionsViewContent(amount, isRefund, error, maskedEmail, maskedPhone, additionalReceiptOptions) {
  _classCallCheck(this, ReceiptOptionsViewContent);

  if (isRefund) {
    this.message = error ? (0, _l10n2.default)('Tx.RefundFailed') : (0, _l10n2.default)('Tx.RefundSuccessful');
  } else {
    if (_RetailSDKUtil2.default.transactionCancelledError(error)) {
      this.message = (0, _l10n2.default)('Tx.CancelledByUser');
    } else if (error) {
      this.message = (0, _l10n2.default)('Tx.TransactionFailed');
    } else {
      this.message = (0, _l10n2.default)('Tx.TransactionSuccessful');
    }
  }

  this.title = (0, _l10n2.default)('Rcpt.Title', { amount: amount });
  this.titleIconFilename = error ? 'ic_x_declined' : 'check_icon_green', this.maskedEmail = maskedEmail;
  this.maskedPhone = maskedPhone;
  this.disclaimer = (0, _l10n2.default)('Rcpt.Disclaimer');
  this.emailButtonTitle = (0, _l10n2.default)('Rcpt.EmailButtonTitle');
  this.smsButtonTitle = (0, _l10n2.default)('Rcpt.SMSButtonTitle');
  this.noThanksButtonTitle = (0, _l10n2.default)('Rcpt.NoThanksButtonTitle');
  this.additionalReceiptOptions = additionalReceiptOptions;
  this.prompt = (0, _l10n2.default)('Rcpt.Prompt');
};

/**
 * The content to be presented natively in the receipt email entry screen.
 * @class
 * @property {string} title
 * @property {string} placeholder
 * @property {string} disclaimer
 * @property {string} sendButtonTitle
 */


var ReceiptEmailEntryViewContent = exports.ReceiptEmailEntryViewContent = function ReceiptEmailEntryViewContent() {
  _classCallCheck(this, ReceiptEmailEntryViewContent);

  this.title = (0, _l10n2.default)('Rcpt.Email.Title');
  this.placeholder = (0, _l10n2.default)('Rcpt.Email.Placeholder');
  this.disclaimer = (0, _l10n2.default)('Rcpt.Email.Disclaimer');
  this.sendButtonTitle = (0, _l10n2.default)('Rcpt.Email.SendButtonTitle');
};

/**
 * The content to be presented natively in the receipt sms entry screen.
 * @class
 * @property {string} title
 * @property {string} placeholder
 * @property {string} disclaimer
 * @property {string} sendButtonTitle
 */


var ReceiptSMSEntryViewContent = exports.ReceiptSMSEntryViewContent = function ReceiptSMSEntryViewContent() {
  _classCallCheck(this, ReceiptSMSEntryViewContent);

  this.title = (0, _l10n2.default)('Rcpt.SMS.Title');
  this.placeholder = (0, _l10n2.default)('Rcpt.SMS.Placeholder');
  this.disclaimer = (0, _l10n2.default)('Rcpt.SMS.Disclaimer');
  this.sendButtonTitle = (0, _l10n2.default)('Rcpt.SMS.SendButtonTitle');
};

/**
 * All the content to be displayed in the native receipt flow
 * @class
 * @property {ReceiptOptionsViewContent} receiptOptionsViewContent
 * @property {ReceiptEmailEntryViewContent} receiptEmailEntryViewContent
 * @property {ReceiptSMSEntryViewContent} receiptSMSEntryViewContent
 */


var ReceiptViewContent = exports.ReceiptViewContent = function ReceiptViewContent(amount, isRefund, error, maskedEmail, maskedPhone, additionalReceiptOptions) {
  _classCallCheck(this, ReceiptViewContent);

  this.receiptOptionsViewContent = new ReceiptOptionsViewContent(amount, isRefund, error, maskedEmail, maskedPhone, additionalReceiptOptions);
  this.receiptEmailEntryViewContent = new ReceiptEmailEntryViewContent();
  this.receiptSMSEntryViewContent = new ReceiptSMSEntryViewContent();
};

},{"../common/RetailSDKUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/RetailSDKUtil.js","../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/SignatureReceiver.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _manticore = require('manticore');

var _manticore2 = _interopRequireDefault(_manticore);

var _retailPaymentDevice = require('retail-payment-device');

var _l10n = require('../common/l10n');

var _l10n2 = _interopRequireDefault(_l10n);

var _messageHelper = require('../flows/messageHelper');

var _messageHelper2 = _interopRequireDefault(_messageHelper);

var _events = require('events');

var _transactionEvent = require('../transaction/transactionEvent');

var _transactionEvent2 = _interopRequireDefault(_transactionEvent);

var _sdkErrors = require('../common/sdkErrors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CardIssuer = _retailPaymentDevice.PaymentDevice.CardIssuer;

/**
 * When signature is collected by external code, it will be passed a SignatureReceiver object
 * @class
 * @property {TransactionContext} context @readonly
 */

var SignatureReceiver = function (_EventEmitter) {
  _inherits(SignatureReceiver, _EventEmitter);

  /**
   * @private
   */
  function SignatureReceiver(context, cb) {
    _classCallCheck(this, SignatureReceiver);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.context = context;
    _this.cb = cb;
    return _this;
  }

  /**
   * Continue processing the transaction with the supplied signature.
   * @param {string} base64SignatureJpeg The signature as a base64 encoded JPEG image. Try to keep it under 100k
   */


  SignatureReceiver.prototype.continueWithSignature = function continueWithSignature(base64SignatureJpeg) {
    this.context.emit(_transactionEvent2.default.didCompleteSignature, null);
    this.cb(null, base64SignatureJpeg);
  };

  /**
   * Acquire signature using the normal PayPal Retail SDK mechanism (i.e. on screen signing)
   */


  SignatureReceiver.prototype.acquireSignature = function acquireSignature() {
    var _this2 = this;

    var formattedValues = _messageHelper2.default.formattedInvoiceTotal(this.context.invoice),
        titleSubstitutions = {
      amount: formattedValues.amount,
      cardIssuer: this.context.card.cardIssuer && this.context.card.cardIssuer !== CardIssuer.Unknown ? _retailPaymentDevice.CardDataUtil.getCardIssuerDisplayName(this.context.card.cardIssuer) : '',
      lastFour: this.context.card.lastFourDigits
    };

    this.sigHandle = _manticore2.default.collectSignature({
      done: (0, _l10n2.default)('Done'),
      footer: (0, _l10n2.default)('Sig.Footer'),
      title: (0, _l10n2.default)('Sig.Title', titleSubstitutions),
      signHere: (0, _l10n2.default)('Sig.Here'),
      cancel: this.context.allowInProgressPaymentCancel ? (0, _l10n2.default)('Cancel') : null
    }, function (error, signature, cancel) {
      if (error) {
        return _this2.cb(error);
      }

      if (cancel) {
        //TODO Use flow.data.alert
        _this2.alert = _manticore2.default.alert({
          title: (0, _l10n2.default)('Tx.Alert.Cancel.Title'),
          message: (0, _l10n2.default)('Tx.Alert.Cancel.Msg'),
          buttons: [(0, _l10n2.default)('Yes')],
          cancel: (0, _l10n2.default)('No')
        }, function (a, ix) {
          a.dismiss();
          if (ix === 0) {
            _this2.cancel();
          }
        });
        return;
      }

      _this2.continueWithSignature(signature);
    });
  };

  /**
   * Cancel the transaction because of a signature failure.
   */


  SignatureReceiver.prototype.cancel = function cancel() {
    var error = (0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.customerCancel);
    this.context.emit(_transactionEvent2.default.didCompleteSignature, error);
    this.cb(error);
    this.dismiss();
  };

  /**
   * Dismiss any open alert windows and emit 'cancelled' in order to notify custom signature collectors to dismiss their
   * signature collection display
   * @private
   */


  SignatureReceiver.prototype.dismiss = function dismiss() {
    this.emit(SignatureReceiver.event.cancelled);
    this.sigHandle && this.sigHandle.dismiss();
    this.alert && this.alert.dismiss();
  };

  /**
   * Called when the transaction is cancelled while waiting to collect the signature
   * @event SignatureReceiver#cancelled
   */


  return SignatureReceiver;
}(_events.EventEmitter);

exports.default = SignatureReceiver;


SignatureReceiver.event = {
  cancelled: 'cancelled'
};

},{"../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../common/sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","../flows/messageHelper":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/messageHelper.js","../transaction/transactionEvent":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/transactionEvent.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/TransactionContext.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _manticore = require('manticore');

var _manticore2 = _interopRequireDefault(_manticore);

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _l10n = require('../common/l10n');

var _l10n2 = _interopRequireDefault(_l10n);

var _RetailSDKUtil = require('../common/RetailSDKUtil');

var _RetailSDKUtil2 = _interopRequireDefault(_RetailSDKUtil);

var _paypalInvoicing = require('paypal-invoicing');

var _sdkErrors = require('../common/sdkErrors');

var _retailPaymentDevice = require('retail-payment-device');

var _events = require('events');

var _PaymentErrorHandler = require('../flows/PaymentErrorHandler');

var _PaymentErrorHandler2 = _interopRequireDefault(_PaymentErrorHandler);

var _Merchant = require('../common/Merchant');

var _Merchant2 = _interopRequireDefault(_Merchant);

var _messageHelper = require('../flows/messageHelper');

var _messageHelper2 = _interopRequireDefault(_messageHelper);

var _TransactionDeviceManager = require('./TransactionDeviceManager');

var _TransactionDeviceManager2 = _interopRequireDefault(_TransactionDeviceManager);

var _flow = require('../common/flow');

var _flow2 = _interopRequireDefault(_flow);

var _async = require('async');

var _async2 = _interopRequireDefault(_async);

var _transactionValidator = require('./transactionValidator');

var _transactionEvent = require('./transactionEvent');

var _transactionEvent2 = _interopRequireDefault(_transactionEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = (0, _manticoreLog2.default)('transaction.transactionContext');
var FormFactor = _retailPaymentDevice.PaymentDevice.FormFactor;
var ErrorAction = _PaymentErrorHandler2.default.action;

/**
 * The TransactionContext class is returned by RetailSDK.createTransaction and allows
 * you to control many aspects of the payment or refund flow and observe events that
 * occur during the flows. Simply creating a TransactionContext will not kick off any behaviors,
 * so that you have a chance to configure the transaction context as you wish (choose payment
 * devices, specify transaction options, etc). When you're ready to proceed with the payment flow,
 * call begin()
 * @class
 * @property {Invoice} invoice The invoice being processed for this transaction
 * @property {TransactionContext.Type} type The type of transaction being attempted
 *  (defaults to Sale if the invoice is not already paid, Refund if it is already paid)
 * @property {bool} isSignatureRequired Given the current state of the invoice and transaction,
 *  is a signature required to secure payment? @readonly
 * @property {Card} card card that was presented by the consumer for this transaction @readonly
 * @property {[PaymentDevice]} paymentDevices If you set the paymentDevices property, this context
 *  will only use the devices you specify to accept
 * payment. This can be useful for cases where a single terminal is managing multiple payment
 *  devices with transactions proceeding in parallel. (This feature is still experimental for
 *  certain payment factors, as any UI will still be single-instance.)
 * @property {string} totalDisplayFooter While building your invoice, the running total
 *  will be displayed on PaymentDevices capable of displaying messages. If you set
 *  totalDisplayFooter, that will be displayed (centered) after the total
 *  amount. Note that once the payment flow starts, EMV certification requires that the display
 *  just show the total and iconography corresponding to expected payment types. Your message
 *  will not be on that screen.
 *  @property {[string]} additionalReceiptOptions If you would like to display additional receipt options
 *  such as print, etc., you can provide them here. These options would be presented on the receipt screen below
 *  the Email and Text options.
 */

var TransactionContext = function (_EventEmitter) {
  _inherits(TransactionContext, _EventEmitter);

  /**
   * Only JS constructs this
   * @private
   * @param {Invoice} invoice The invoice for this transaction
   * @param {Merchant} merchant The merchant to use for this transaction
   */
  function TransactionContext(invoice, merchant) {
    _classCallCheck(this, TransactionContext);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    Log.debug(function () {
      return 'Starting new transaction flow for ' + invoice.currency + ' ' + invoice.total + ' and ' + _retailPaymentDevice.PaymentDevice.devices.length + ' connected devices';
    }); // eslint-disable-line max-len
    _this.invoice = invoice;
    _this.merchant = merchant;
    _this.dm = new _TransactionDeviceManager2.default(_this);

    if (invoice.status === _paypalInvoicing.InvoiceEnums.Status.PAID || invoice.status === _paypalInvoicing.InvoiceEnums.Status.MARKED_AS_PAID || invoice.status === _paypalInvoicing.InvoiceEnums.Status.PARTIALLY_REFUNDED) {
      _this.type = TransactionContext.Type.Refund;
    } else {
      _this.type = TransactionContext.Type.Sale;
    }
    _this.cardListener = function (card) {
      Log.debug(function () {
        return 'TransactionContext cardPresented using form factor: \'' + _RetailSDKUtil2.default.getEnumName(FormFactor, card.formFactor) + '\'';
      });
      _this.card = card;
      var error = (0, _transactionValidator.validateFormFactor)(card, _this.allowFallBackSwipe, _this.dm.formFactors);
      if (error) {
        return _this.errorListener(error, card.formFactor, card.reader);
      }

      if (card.chipCard && card.formFactor === FormFactor.MagneticCardSwipe) {
        Log.info('Allowing fallback swipe on the chip card');
        card.isMSRFallbackAllowed = true;
      }

      if (_this.listeners(_retailPaymentDevice.PaymentDevice.Event.cardPresented).length) {
        _this.emit(_transactionEvent2.default.cardPresented, card);
      } else {
        // Because there are no listeners, we assume you want to just proceed with the
        // transaction and be notified on completion.
        _this.continueWithCard(card);
      }
    };
    _this.txCancelledListener = function (pd) {
      Log.warn('Tx cancelled listener was invoked for device : ' + pd.id);
      pd.display(_retailPaymentDevice.PaymentDevice.Message.TransactionCancelled, { amount: _paypalInvoicing.Currency.format(_this.invoice.currency, _this.invoice.total) }, function () {
        _this.alert = _manticore2.default.alert({
          title: (0, _l10n2.default)('Tx.Alert.Cancelled.Title'),
          message: (0, _l10n2.default)('Tx.Alert.Cancelled.Msg'),
          cancel: (0, _l10n2.default)('Done')
        }, function () {
          _this.alert.dismiss();
          _this.end((0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.genericCancel));
        });
      });
    };
    _this.errorListener = function (error, ff, pd) {
      var level = 'error';
      if (error.code === _retailPaymentDevice.deviceError.contactlessPaymentAbortedByCardInsert.code || error.code === _retailPaymentDevice.deviceError.contactlessPaymentAbortedByCardSwipe.code) {
        level = 'debug';
      }
      Log[level]('Transaction failed with error code \'' + error.code + '\'');
      if (error.code === _retailPaymentDevice.deviceError.paymentCancelled.code) {
        _this.txCancelledListener(pd);
        return;
      }

      var errorHandler = new _PaymentErrorHandler2.default(_this);
      errorHandler.handle(error, ff, pd, function (action) {
        return _this._processErrorHandlerResponse(error, action, ff);
      });
    };
    return _this;
  }

  TransactionContext.prototype._processErrorHandlerResponse = function _processErrorHandlerResponse(error, action, ff) {
    var _this2 = this;

    Log.info('Response from error handler for handling the error: ' + error.code + ' and form factor: ' + ff + ' was \'' + action + '\' '); // eslint-disable-line max-len
    if (!action) {
      return;
    }

    if (action === ErrorAction.OfflineDecline) {
      var TxCancelFlow = require('./../flows/TransactionCancelFlow').default;
      this.flow = new TxCancelFlow(this.card, this, function (data) {
        _this2.end(data.error, data.tx);
      });
      return;
    }

    var formFactors = this.dm.formFactors;
    if (action === ErrorAction.abort) {
      var returnError = error || (0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.genericCancel);
      if (error.code === _retailPaymentDevice.deviceError.paymentCancelled.code) {
        returnError = (0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.customerCancel);
      }
      this.end(returnError);
      return;
    }

    if (action === ErrorAction.retryWithInsertOrSwipe) {
      formFactors.delete(FormFactor.EmvCertifiedContactless);
    } else if (action === ErrorAction.retryWithSwipe) {
      formFactors.delete(FormFactor.EmvCertifiedContactless);
      formFactors.delete(FormFactor.Chip);
    } else if (action === ErrorAction.retryWithInsert) {
      formFactors.delete(FormFactor.EmvCertifiedContactless);
      formFactors.delete(FormFactor.MagneticCardSwipe);
    }

    this.dm.activateMany([].concat(_toConsumableArray(this.dm.activeDevices)), formFactors);
  };

  /**
   * Begin the flow (activate payment devices, listen for relevant events from devices)
   * @param {bool} showPrompt true to show a prompt in-app to indicate that the
   *  customer/cashier should insert, swipe or tap a card (depending on the country,
   *  merchant account and payment hardware in use)
   * @returns {TransactionContext} Returns this object just to make chaining easier
   */


  TransactionContext.prototype.begin = function begin(showPrompt) {
    var _this3 = this;

    if (this.type !== TransactionContext.Type.Sale) {
      this.end((0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.invoiceStatusMismatch));
      return this;
    }

    this._validateInvoice(function (err) {
      if (err) {
        return _this3.end(err);
      }

      _this3._resetState();
      _this3._activateReaders(showPrompt);
    });

    return this;
  };

  /**
   * Begin the flow to issue a refund on the current invoice.
   * @param {bool} cardPresent true to ask for card data to check against the payment
   *  method orginally used on the invoice
   * @param {decimal} amount the amount to refund
   * @returns {TransactionContext} Returns this object just to make chaining easier
   */


  TransactionContext.prototype.beginRefund = function beginRefund(cardPresent, amount) {
    if (this.type !== TransactionContext.Type.Refund) {
      this.end((0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.invoiceStatusMismatch));
      return this;
    }

    this._resetState();
    this.refundAmount = amount;
    if (cardPresent) {
      this._activateReaders(true);
    }
    return this;
  };

  TransactionContext.prototype._validateInvoice = function _validateInvoice(cb) {
    var _this4 = this;

    if (!_Merchant2.default.active.cardSettings) {
      cb();
    }

    var deviceMessageId = void 0,
        alertOpts = void 0,
        values = void 0,
        error = void 0;
    if (_Merchant2.default.active.cardSettings.minimum && this.invoice.total.lessThan(_Merchant2.default.active.cardSettings.minimum)) {
      error = (0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.amountTooLow);
      deviceMessageId = _retailPaymentDevice.PaymentDevice.Message.AmountTooLow;
      values = _messageHelper2.default.formattedAmount(this.invoice.currency, _Merchant2.default.active.cardSettings.minimum);
      alertOpts = {
        title: (0, _l10n2.default)('Tx.Alert.AmountTooLow.Title'),
        message: (0, _l10n2.default)('Tx.Alert.AmountTooLow.Msg', values),
        cancel: (0, _l10n2.default)('Ok')
      };
    } else if (_Merchant2.default.active.cardSettings.maximum && this.invoice.total.greaterThan(_Merchant2.default.active.cardSettings.maximum)) {
      error = (0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.amountTooHigh);
      deviceMessageId = _retailPaymentDevice.PaymentDevice.Message.AmountTooHigh;
      values = _messageHelper2.default.formattedAmount(this.invoice.currency, _Merchant2.default.active.cardSettings.maximum);
      alertOpts = {
        title: (0, _l10n2.default)('Tx.Alert.AmountTooHigh.Title'),
        message: (0, _l10n2.default)('Tx.Alert.AmountTooHigh.Msg', values),
        cancel: (0, _l10n2.default)('Ok')
      };
    } else {
      return cb();
    }
    _async2.default.each(this.dm.devices, function (pd, cb) {
      return pd.display(deviceMessageId, values, cb);
    }, function () {
      _this4.alert = _manticore2.default.alert(alertOpts, function () {
        cb(error);
      });
    });
  };

  TransactionContext.prototype._activateReaders = function _activateReaders(showPrompt) {
    var _this5 = this;

    var devices = this.dm.devices;
    Log.debug(function () {
      var forms = [].concat(_toConsumableArray(new Set([].concat.apply([], devices.map(function (pd) {
        return pd.formFactors;
      })))));
      return 'New transaction on ' + devices.length + ' devices with ' + forms + ' available form factors';
    });
    this.dm.activateMany(devices, null, function (activeDevices) {
      if (activeDevices.size === 0 && devices.length > 0) {
        Log.warn('None of the connected devices are functional');
        _this5.emit(_transactionEvent2.default.completed, (0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.noFunctionalDevices), null);
        return;
      }

      Log.info('Activated ' + activeDevices.size + ' device(s) for invoice total ' + _this5.invoice.currency + ' ' + _this5.invoice.total + '. Acceptable form factors: [' + [].concat(_toConsumableArray(_this5.dm.formFactors)) + ']'); // eslint-disable-line max-len
      if (!_this5.paymentDevices) {
        _this5.dm.listenAndActivateNewDevices();
      }

      if (showPrompt) {
        _this5.promptForPaymentInstrument();
      }
    });
  };

  /**
   * Is the transaction a type of refund?
   * @returns {bool}
   */


  TransactionContext.prototype.isRefund = function isRefund() {
    return this.type === TransactionContext.Type.Refund || this.type === TransactionContext.Type.PartialRefund;
  };

  /**
   * Returns a list of form factors approved for the current transaction. This list is based
   * on device availability, invoice total and preferred list of form factors
   * @private
   */


  /**
   * Display an alert on the app prompting for payment
   * @param formFactors (optional) Set of form factors to include in the payment prompt.
   *  Default value will be the form factors approved on the connected devices
   * @private
   */
  TransactionContext.prototype.promptForPaymentInstrument = function promptForPaymentInstrument(formFactors) {
    var _this6 = this;

    var ff = formFactors || this.dm.formFactors;
    var alertId = void 0;
    var imageId = void 0;
    if (ff.has(FormFactor.EmvCertifiedContactless) && ff.has(FormFactor.MagneticCardSwipe) && ff.has(FormFactor.Chip)) {
      alertId = 'Ready';
      imageId = 'img_emv_insert_tap_swipe';
    } else if (ff.has(FormFactor.MagneticCardSwipe) && ff.has(FormFactor.Chip)) {
      alertId = 'ReadyForInsertOrSwipeOnly';
      imageId = 'img_emv_insert_swipe';
    } else if (ff.has(FormFactor.MagneticCardSwipe)) {
      alertId = 'ReadyForSwipeOnly';
      imageId = 'img_emv_swipe';
    } else if (ff.has(FormFactor.Chip)) {
      alertId = 'ReadyForInsertOnly';
      imageId = 'img_emv_insert';
    }

    if (!alertId) {
      return;
    }

    this.alert = _manticore2.default.alert({
      title: (0, _l10n2.default)('Tx.Alert.' + alertId + '.Title'),
      message: (0, _l10n2.default)('Tx.Alert.' + alertId + '.Msg'),
      cancel: (0, _l10n2.default)('Cancel'),
      imageIcon: imageId
    }, function () {
      _this6.alert.dismiss();
      _this6.cancel();
    });
  };

  /**
   * A transaction is not complete until the end function is called. This function
   * takes care of de-registering various event listeners and clears variables that
   * track transaction state.
   * @private
   */


  TransactionContext.prototype.end = function end(error, txRecord) {
    var _this7 = this;

    Log.info('Ending transaction and removing all listeners from ' + this.dm.activeDevices.size + ' devices'); // eslint-disable-line max-len
    if (this.alert) {
      this.alert.dismiss();
    }
    this.dm.stopSyncingInvoiceTotal(function () {
      _this7.dm.removeListeners(_this7.dm.activeDevices);
      _this7.dm.stopListeningForNewDevices();
      _this7._resetState();
      _async2.default.each(_this7.dm.devices, function (pd, cb) {
        return pd.displayWithSystemIcons(_retailPaymentDevice.PaymentDevice.Message.Ready, null, cb);
      }, function () {
        _this7.emit(_transactionEvent2.default.completed, error, txRecord);
      });
      // TODO Command device to stop pushing keyboard and card events?
    });
  };

  /**
   * Determines if an in-progress payment could be cancelled
   * @private
   */


  TransactionContext.prototype._resetState = function _resetState() {
    this.retryCountInvalidChip = 0;
    this.allowFallBackSwipe = false;
    if (this.card) {
      this.card.isMSRFallbackAllowed = false;
    }
  };

  /**
   * End a transaction attempt abandoning any progress. The completed event
   * will NOT be fired for this TransactionContext given that you have explicitly
   * cancelled the transaction.
   */


  TransactionContext.prototype.cancel = function cancel() {
    Log.debug('Cancelling current transaction');
    this.dm.deactivateMany([].concat(_toConsumableArray(this.dm.activeDevices)), function () {}); // This should trigger the transaction cancelled listener
  };

  /**
   * Continue processing a transaction - the behavior of which depends on the presented card.
   * If it's a magnetic card or an NFC tap, payment will be attempted and money will move
   * (if successful). If it's an EMV card insertion, we will start the EMV flow which includes
   * a few calls to the server, potentially asking the user to enter a PIN, etc.
   * @param {Card} card The card, typically received via cardPresented, but in certain
   * regions you can simply provide a card number, address verification (AVS) fields such
   * as postal code, expiration and CVV.
   */


  TransactionContext.prototype.continueWithCard = function continueWithCard(card) {
    var _this8 = this;

    if (card) {
      Log.debug(function () {
        return 'Card (type: ' + card.constructor.name + ') was presented. Form Factor: ' + card.formFactor;
      }); // eslint-disable-line max-len
    } else {
      Log.debug(function () {
        return 'No card presented.';
      });
    }

    this.dm.removeListeners(this.dm.activeDevices);
    // From this point onwards, the events will be handled by the flow controllers
    var cbFlowComplete = function cbFlowComplete(err, action, txRecord) {
      Log[err ? 'error' : 'info']('Transaction flow complete handler was invoked with action: \'' + action + '\' and error ' + err);
      if (action && action !== ErrorAction.abort) {
        _this8._processErrorHandlerResponse(err, action, card.formFactor);
      } else {
        _this8.end(err, txRecord);
      }
    };

    if (this.type === TransactionContext.Type.Sale) {
      this.card = card;

      if (card instanceof _retailPaymentDevice.MagneticCard) {
        card.isSignatureRequired = this._isMSRFallbackSignatureRequired(card) || this.invoice.total.greaterThanOrEqualTo(_Merchant2.default.active.signatureRequiredAbove);
      }

      var CCFlow = require('./../flows/CreditCardFlow').default;
      this.flow = new CCFlow(card, this, cbFlowComplete);
    } else {
      this.card = card;
      var refundFlow = require('./../flows/refundFlow').default;
      this.flow = new refundFlow(card, this, cbFlowComplete);
    }
  };

  TransactionContext.prototype._isMSRFallbackSignatureRequired = function _isMSRFallbackSignatureRequired(card) {
    // Always ask for signature in case of a fallback swipe.
    return card.isMSRFallbackAllowed && this.dm.formFactors.has(FormFactor.Chip);
  };

  /**
   * If you acquire signatures yourself, for example from a Topaz Pen Pad or with an external
   * camera, set this property to a handler that will be invoked when signature should be
   * collected. Once you've collected the signature, call the supplied signatureReceiver
   * with a base64 encoded JPG of the signature. Try to keep it under 100k.
   * @param {TransactionContext~signatureCollector} collector The function that will be
   *  called when a signature should be acquired
   */


  TransactionContext.prototype.setSignatureCollector = function setSignatureCollector(collector) {
    this._signatureCollector = collector;
  };

  _createClass(TransactionContext, [{
    key: 'totalDisplayFooter',
    get: function get() {
      return this._totalDisplayFooter;
    },
    set: function set(value) {
      this._totalDisplayFooter = value;
      this.emit(_transactionEvent2.default.invoiceDisplayFooterUpdated);
    }
  }, {
    key: 'formFactors',
    get: function get() {
      return [].concat(_toConsumableArray(this.dm.formFactors));
    }

    /**
     * Use this property to set the preferred list of form factors for the transaction.
     * The actual list of form factors that will be used for a transaction will be an
     * intersection of available form factors and preferred list
     * @private
     */
    ,
    set: function set(value) {
      this.dm.formFactors = new Set(value);
    }
  }, {
    key: 'allowInProgressPaymentCancel',
    get: function get() {
      return this.card && this.card.formFactor !== FormFactor.MagneticCardSwipe && !this.card.isContactlessMSD;
    }
  }]);

  return TransactionContext;
}(_events.EventEmitter);

/**
 * A transaction context is created for a certain operation - sale
 * (meaning auth+capture), auth or refund.
 * @enum {int}
 */


exports.default = TransactionContext;
TransactionContext.Type = {
  /**
   * An attempt to complete a transfer of funds between merchant and customer
   */
  Sale: 0,
  /**
   * An attempt to get authorization of funds for later capture
   */
  Auth: 1,
  /**
   * An attempt to return the entire amount of the remaining paid amount of an invoice
   */
  Refund: 2,
  /**
   * An attempt to return a partial amount of the remaining paid amount of an invoice
   */
  PartialRefund: 3
};

/**
 * Called when either payment completes or fails.
 * Note that other events may be fired in the meantime.
 * @event TransactionContext#completed
 * @param {error} error The error that caused the transaction to fail, if any
 * @param {TransactionRecord} record The transaction record for successful transactions
 *  and failed transactions that reached PayPal.
 */

/**
 * Depending on your region and the buyer payment type, this can mean a magnetic
 * card was swiped, an EMV card was inserted, or an NFC card/device was tapped.
 * @event TransactionContext#cardPresented
 * @param {Card} card Information about the card.
 */

/**
 * Called when PIN entry is in progress or complete
 * @protected
 * @event TransactionContext#pinEntry
 * @param {bool} complete The PIN entry is complete
 * @param {bool} correct The PIN entry is correct
 * @param {int} pinDigits The number of digits entered
 * @param {bool} lastAttempt Whether this is the last attempt before pin lockout
 */

/**
 * Called when the signature input interface will be displayed
 * @event TransactionContext#willPresentSignature
 */

/**
 * Called when the signature entry is completed
 * @event TransactionContext#didCompleteSignature
 * @param {error} error The error which caused the signature not to be acquired or saved,
 *  or null if it worked
 */

/**
 * @callback TransactionContext~signatureCollector
 * @param {SignatureReceiver} signatureReceiver Call continueWithSignature or
 *  cancel on this object once signature acquisition is complete.
 */

/**
 * Called when one of the additional receipt option is selected.
 * @event TransactionContext#additionalReceiptOptionSelected
 * @param {int} index The index of the selected receipt option.
 * @param {string} name The name of the selected receipt option.
 */

},{"../common/Merchant":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/Merchant.js","../common/RetailSDKUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/RetailSDKUtil.js","../common/flow":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/flow.js","../common/l10n":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/l10n.js","../common/sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","../flows/PaymentErrorHandler":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/PaymentErrorHandler.js","../flows/messageHelper":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/messageHelper.js","./../flows/CreditCardFlow":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/CreditCardFlow.js","./../flows/TransactionCancelFlow":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/TransactionCancelFlow.js","./../flows/refundFlow":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/flows/refundFlow.js","./TransactionDeviceManager":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/TransactionDeviceManager.js","./transactionEvent":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/transactionEvent.js","./transactionValidator":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/transactionValidator.js","async":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/async/lib/async.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","paypal-invoicing":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/TransactionDeviceManager.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _manticore = require('manticore');

var _manticore2 = _interopRequireDefault(_manticore);

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _retailPaymentDevice = require('retail-payment-device');

var _paypalInvoicing = require('paypal-invoicing');

var _events = require('events');

var _async = require('async');

var _async2 = _interopRequireDefault(_async);

var _transactionEvent = require('./transactionEvent');

var _transactionEvent2 = _interopRequireDefault(_transactionEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = (0, _manticoreLog2.default)('transaction.transactionDeviceManager');
var InvoiceEvent = _paypalInvoicing.Invoice.Event;
var FormFactor = _retailPaymentDevice.PaymentDevice.FormFactor;

/**
 * DeviceManager is responsible for maintaining the state of devices used in a transaction.
 * It tracks the state of each device, form factors and and provides methods to
 * activate/deactivate the devices
 */

var TransactionDeviceManager = function (_EventEmitter) {
  _inherits(TransactionDeviceManager, _EventEmitter);

  function TransactionDeviceManager(context) {
    _classCallCheck(this, TransactionDeviceManager);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.context = context;
    _this.activeDevices = new Set();
    _this._preferredFormFactors = new Set();
    _this.syncInvoiceTotal();
    return _this;
  }

  /**
   * Begin syncing invoice.total with the device display
   */


  TransactionDeviceManager.prototype.syncInvoiceTotal = function syncInvoiceTotal() {
    var _this2 = this;

    if (this._q) {
      return;
    }

    var invoice = this.context.invoice;
    this._q = {
      tasks: [],
      invoiceSyncInProgress: false,
      kill: function kill() {
        _this2._q.tasks = [];
      },
      process: function process() {
        if (!_this2._q || !_this2._q.tasks.length) {
          return;
        }
        var tasks = _this2._q.tasks.splice(0, _this2._q.tasks.length);
        var mostRecentTotal = tasks.pop();

        _this2._q.invoiceSyncInProgress = true;
        _async2.default.each(_this2.devices, function (pd, cb) {
          for (var _iterator = _this2.availabilityFilters, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var _ref2 = _ref;
            var availabilityPredicate = _ref2[1];

            if (!availabilityPredicate(pd)) {
              cb();
              return;
            }
          }
          pd.display(_retailPaymentDevice.PaymentDevice.Message.InvoiceTotal, {
            amount: _paypalInvoicing.Currency.format(invoice.currency, mostRecentTotal),
            footer: _this2.context.totalDisplayFooter
          }, cb);
        }, function () {
          _this2.emit('onTaskComplete');
          if (!_this2._q) {
            return;
          }
          _this2._q.invoiceSyncInProgress = false;
          if (_this2._q.tasks.length > 0) {
            _manticore2.default.setTimeout(_this2._q.process, 0);
          }
        });
      },
      push: function push(data) {
        _this2._q.tasks.push(data);
        if (!_this2._q.invoiceSyncInProgress) {
          _this2._q.process();
        }
      }
    };

    var listener = function listener() {
      return _this2._q.push(invoice.total);
    };
    listener.txContext = this.context;
    invoice.on(InvoiceEvent.TotalChanged, listener);
    this.context.on(_transactionEvent2.default.invoiceDisplayFooterUpdated, listener);
    this._q.push(invoice.total);
  };

  /**
   * Stops syncing the device display with the invoice total
   */


  TransactionDeviceManager.prototype.stopSyncingInvoiceTotal = function stopSyncingInvoiceTotal(cb) {
    var _this3 = this;

    var invoice = this.context.invoice;
    var events = [InvoiceEvent.TotalChanged, _transactionEvent2.default.invoiceDisplayFooterUpdated];

    for (var _iterator2 = events, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref3 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref3 = _i2.value;
      }

      var e = _ref3;

      for (var _iterator3 = invoice.listeners(e), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref4;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref4 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref4 = _i3.value;
        }

        var l = _ref4;

        if (Object.is(l.txContext, this.context)) {
          invoice.removeListener(e, l);
        }
      }
    }

    if (!this._q) {
      cb();
      return;
    }

    this._q.kill();
    if (!this._q.invoiceSyncInProgress) {
      this._q = null;
      cb();
      return;
    }

    this.once('onTaskComplete', function () {
      _this3._q = null;
      cb();
    });
  };

  /**
   * List of all devices that are available for the transaction.
   * (Not all available devices will be approved for the transaction.
   * The filter criteria to determine an approved device is defined in
   * `DeviceManager.availabilityFilter` )
   */


  TransactionDeviceManager.prototype._addListener = function _addListener(pd, event, listener) {
    listener.txContext = this.context;
    pd.on(event, listener);
  };

  /**
   * Activates the devices that are available for payment. The provided callback
   * will be invoked with the activated devices. The devices that failed activation
   * would be notified.
   * @param devices List of devices to activate
   * @param txFormFactors (Optional) Payment form factors that needs to be activated.
   *  Will be defaulted to `this.formFactors`
   * @param callback (Optional) Callback that will be invoked with the Set of devices
   *  that were activated
   */


  TransactionDeviceManager.prototype.activateMany = function activateMany(devices, txFormFactors, callback) {
    var _this4 = this;

    var activate = function activate(pd, _txFormFactors) {
      var formFactors = _txFormFactors || _this4.formFactors;
      Log.debug(function () {
        return 'Activating ' + pd.id + ' with form factors [' + [].concat(_toConsumableArray(formFactors)) + ']';
      });
      pd.activate(_this4.context, { formFactors: formFactors });
      _this4.activeDevices.add(pd);
      _this4._removeListeners(pd);
      _this4._addListener(pd, _retailPaymentDevice.PaymentDevice.Event.cardPresented, _this4.context.cardListener);
      _this4._addListener(pd, _retailPaymentDevice.PaymentDevice.Event.cancelled, function () {
        return _this4.context.txCancelledListener(pd);
      });
      _this4._addListener(pd, _retailPaymentDevice.PaymentDevice.Event.cancelRequested, function () {
        return _this4.context.cancel;
      });
      _this4._addListener(pd, _retailPaymentDevice.PaymentDevice.Event.error, _this4.context.errorListener);
    };

    this.stopSyncingInvoiceTotal(function () {
      _async2.default.each(devices, function (pd, cb) {
        for (var _iterator4 = _this4.availabilityFilters, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
          var _ref5;

          if (_isArray4) {
            if (_i4 >= _iterator4.length) break;
            _ref5 = _iterator4[_i4++];
          } else {
            _i4 = _iterator4.next();
            if (_i4.done) break;
            _ref5 = _i4.value;
          }

          var _ref6 = _ref5;
          var predicateName = _ref6[0];
          var availabilityPredicate = _ref6[1];

          if (!availabilityPredicate(pd)) {
            Log.warn('Device ' + pd.id + ' failed availability criteria ' + predicateName);
            if (predicateName === TransactionDeviceManager.FilterCriteria.BatteryStatus) {
              Log.warn('Battery level on ' + pd.id + ' is too low to begin a transaction ' + pd.batteryStatus); // eslint-disable-line max-len
              pd.display(_retailPaymentDevice.PaymentDevice.Message.RechargeNow, null, function () {
                return cb();
              });
            } else if (predicateName === TransactionDeviceManager.FilterCriteria.SoftwareUpdate) {
              pd.pendingUpdate.offer(function (err) {
                Log[err ? 'error' : 'info']('Software update completed. Error: ' + err); // eslint-disable-line max-len
                if (!err) {
                  activate(pd, txFormFactors);
                }
                cb();
              });
            } else {
              cb();
            }

            return;
          }
        }
        activate(pd, txFormFactors);
        cb();
      }, function () {
        if (callback) {
          callback(_this4.activeDevices);
        }
      });
    });
  };

  TransactionDeviceManager.prototype.deactivateMany = function deactivateMany(devices, callback) {
    var _this5 = this;

    _async2.default.each(devices, function (pd, cb) {
      pd.deactivate(_this5.context, false, cb);
    }, callback);
  };

  TransactionDeviceManager.prototype.listenAndActivateNewDevices = function listenAndActivateNewDevices() {
    var _this6 = this;

    this.onNewDevice = function (pd) {
      Log.debug('Discovered new device during transaction');
      var activeFormFactors = _this6.formFactors;
      for (var _iterator5 = pd.formFactors, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
        var _ref7;

        if (_isArray5) {
          if (_i5 >= _iterator5.length) break;
          _ref7 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done) break;
          _ref7 = _i5.value;
        }

        var f = _ref7;

        if (!activeFormFactors.has(f)) {
          _this6.context.emit(_transactionEvent2.default.formFactorAdded, f);
        }
      }
      _this6.activateMany([pd]);
    };
    require('../sdk').on('deviceDiscovered', this.onNewDevice);
  };

  TransactionDeviceManager.prototype.stopListeningForNewDevices = function stopListeningForNewDevices() {
    if (this.onNewDevice) {
      require('../sdk').removeListener('deviceDiscovered', this.onNewDevice);
      delete this.onNewDevice;
    }
  };

  /**
   * Removes transaction context listeners on the payment device
   * @param devices
   */


  TransactionDeviceManager.prototype.removeListeners = function removeListeners(devices) {
    for (var _iterator6 = devices, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
      var _ref8;

      if (_isArray6) {
        if (_i6 >= _iterator6.length) break;
        _ref8 = _iterator6[_i6++];
      } else {
        _i6 = _iterator6.next();
        if (_i6.done) break;
        _ref8 = _i6.value;
      }

      var pd = _ref8;

      this._removeListeners(pd);
    }
  };

  TransactionDeviceManager.prototype._removeListeners = function _removeListeners(pd) {
    var events = [_retailPaymentDevice.PaymentDevice.Event.cardPresented, _retailPaymentDevice.PaymentDevice.Event.cancelled, _retailPaymentDevice.PaymentDevice.Event.cancelRequested, _retailPaymentDevice.PaymentDevice.Event.error];

    for (var _iterator7 = events, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
      var _ref9;

      if (_isArray7) {
        if (_i7 >= _iterator7.length) break;
        _ref9 = _iterator7[_i7++];
      } else {
        _i7 = _iterator7.next();
        if (_i7.done) break;
        _ref9 = _i7.value;
      }

      var e = _ref9;

      for (var _iterator8 = pd.listeners(e), _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
        var _ref10;

        if (_isArray8) {
          if (_i8 >= _iterator8.length) break;
          _ref10 = _iterator8[_i8++];
        } else {
          _i8 = _iterator8.next();
          if (_i8.done) break;
          _ref10 = _i8.value;
        }

        var l = _ref10;

        if (Object.is(l.txContext, this.context)) {
          pd.removeListener(e, l);
        }
      }
    }
  };

  _createClass(TransactionDeviceManager, [{
    key: 'devices',
    get: function get() {
      return this.context.paymentDevices || _retailPaymentDevice.PaymentDevice.devices;
    }

    /**
     * Returns a set of form factors approved for the current transaction
     * @returns {*}
     */

  }, {
    key: 'formFactors',
    get: function get() {
      var _this7 = this;

      var availableDevices = this.devices.filter(function (pd) {
        for (var _iterator9 = _this7.availabilityFilters, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
          var _ref11;

          if (_isArray9) {
            if (_i9 >= _iterator9.length) break;
            _ref11 = _iterator9[_i9++];
          } else {
            _i9 = _iterator9.next();
            if (_i9.done) break;
            _ref11 = _i9.value;
          }

          var _ref12 = _ref11;
          var predicate = _ref12[1];

          if (!predicate(pd)) {
            return false;
          }
        }
        return true;
      });

      var availableFormFactors = new Set([].concat.apply([], availableDevices.map(function (pd) {
        return pd.formFactors;
      })));
      if (availableFormFactors.has(FormFactor.EmvCertifiedContactless)) {
        (function () {
          var nfcLimit = _this7.context.merchant.isCertificationMode ? '*' : _this7.context.merchant.featureMap.CONTACTLESS_LIMIT;
          if (nfcLimit !== '*' && _this7.context.invoice.total.greaterThan((0, _paypalInvoicing.$$)(nfcLimit) || 0)) {
            Log.debug(function () {
              return 'Cannot perform NFC. Invoice total ' + _this7.context.invoice.total + ' is above contactless limit of ' + (0, _paypalInvoicing.$$)(nfcLimit);
            }); // eslint-disable-line max-len
            availableFormFactors.delete(FormFactor.EmvCertifiedContactless);
          }
        })();
      }

      var preferred = [].concat(_toConsumableArray(this._preferredFormFactors));
      return preferred.length > 0 ? new Set(preferred.filter(function (ff) {
        return availableFormFactors.has(ff);
      })) : availableFormFactors;
    }

    /**
     * Form factors preferred for the current transaction
     */
    ,
    set: function set(value) {
      this._preferredFormFactors = value;
    }

    /**
     * Filter criteria(s) for device availability to process payment
     */

  }, {
    key: 'availabilityFilters',
    get: function get() {
      var _this8 = this;

      return [[TransactionDeviceManager.FilterCriteria.Ready, function (pd) {
        return pd.isReady;
      }], [TransactionDeviceManager.FilterCriteria.BatteryStatus, function (pd) {
        return !(pd.batteryStatus && pd.batteryStatus.isLevelCritical);
      }], [TransactionDeviceManager.FilterCriteria.SoftwareUpdate, function (pd) {
        return _this8.context.merchant.isCertificationMode || !(pd.pendingUpdate && pd.pendingUpdate.isRequired);
      }]];
    }
  }]);

  return TransactionDeviceManager;
}(_events.EventEmitter);

/**
 * Enumeration indicating possible device availability filter criterias
 * @type {{BatteryStatus: number, SoftwareUpdate: number}}
 */


exports.default = TransactionDeviceManager;
TransactionDeviceManager.FilterCriteria = {
  Ready: 'Ready',
  BatteryStatus: 'BatteryStatus',
  SoftwareUpdate: 'SoftwareUpdate'
};

},{"../sdk":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/sdk.js","./transactionEvent":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/transactionEvent.js","async":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/async/lib/async.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","paypal-invoicing":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/TransactionRecord.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = require('manticore-util'),
    Payer = require('./Payer');

/**
 * Information about a completed transaction
 * @class
 * @property {string} transactionNumber The PayPal transaction reference number
 * @property {string} transactionHandle An identifier available throughout the EMV transaction flow (allocated before the transaction is complete, unlike transactionNumber)
 * @property {string} responseCode The acquirer response code
 * @property {Payer} payer Information about the payer, if available
 * @property {string} correlationId The correlationId used for obtaining additional support from PayPal for this transaction attempt
 */

var TransactionRecord = function () {
    /**
     * @private
     */
    function TransactionRecord(response) {
        _classCallCheck(this, TransactionRecord);

        // AuthCode is not an externally accessible value, but we use it internally so we copy it over.
        util.assignSome(this, response, ['correlationId', 'transactionNumber', 'invoiceId', 'transactionHandle', 'responseCode', 'authCode', 'errorCode']);
        if (response.payerInfo) {
            this.payer = new Payer(response.payerInfo);
        }
        // In case of refunds, the transaction number is returned as an `id`
        if (response.id) {
            this.transactionNumber = response.id;
        }
        // For some reason, in a few of the MTP failures, the transaction handle is returned as `txnHandle` instead of `transactionHandle` :-(
        if (response.txnHandle && !this.transactionHandle) {
            this.transactionHandle = response.txnHandle;
        }
    }

    /**
     * @private
     */


    TransactionRecord.prototype.updateFromFinalize = function updateFromFinalize(finalize) {

        if (!this.transactionNumber) {
            this.transactionNumber = finalize.transactionNumber;
        }

        if (finalize.correlationId && this.correlationId) {
            this.correlationId += ',' + finalize.correlationId;
        } else if (finalize.correlationId) {
            this.correlationId = finalize.correlationId;
        }
        if (finalize.payerInfo) {
            this.payer = new Payer(finalize.payerInfo);
        }
    };

    TransactionRecord.prototype.toString = function toString() {
        return 'transactionNumber: ' + this.transactionNumber + ', transactionHandle: ' + this.transactionHandle + ', ' + ('responseCode: ' + this.responseCode + ', correlationId: ' + this.correlationId);
    };

    return TransactionRecord;
}();

module.exports = TransactionRecord;

TransactionRecord.Error = {
    ContactlessNotAcceptable: 600075,
    IncorrectOnlinePin: 6000164
};

},{"./Payer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/Payer.js","manticore-util":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/index.js":[function(require,module,exports){
'use strict';

module.exports = {
    Payer: require('./Payer'),
    TransactionRecord: require('./TransactionRecord')
};

},{"./Payer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/Payer.js","./TransactionRecord":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/TransactionRecord.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/transactionEvent.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
/**
 * List of events that could be emitted by the Transaction context
 */
var TransactionEvent = {
  /**
   * Transaction was completed
   */
  completed: 'completed',

  /**
   * A card was presented for payment
   */
  cardPresented: 'cardPresented',

  /**
   * Signature collection was completed
   */
  didCompleteSignature: 'didCompleteSignature',

  /**
   * Signature was required for this transaction and the assigned signature collector will be activated
   */
  willPresentSignature: 'willPresentSignature',

  /**
   * A footer was added to invoice total that will be display on the connected reader
   */
  invoiceDisplayFooterUpdated: 'invoiceDisplayFooterUpdated',

  /**
   * A device form factor not previously known was discovered
   */
  formFactorAdded: 'formFactorAdded',

  /**
   * A custom receipt option was selected by the customer.
   */
  additionalReceiptOptionSelected: 'additionalReceiptOptionSelected'
};

exports.default = TransactionEvent;

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/transaction/transactionValidator.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.validateFormFactor = validateFormFactor;

var _retailPaymentDevice = require('retail-payment-device');

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _sdkErrors = require('../common/sdkErrors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Log = (0, _manticoreLog2.default)('transaction.validator');
var FormFactor = _retailPaymentDevice.PaymentDevice.FormFactor;

/**
 * Verifies if the presented card is eligible to process payment/refund for the transaction. An error object would
 * be returned if the validation fails
 * @param card Card data as read from the reader
 * @param allowFBSwipe Should be 'true' for fall back swipes
 * @param approvedFormFactors a Set of form factors approved for the Transaction
 */
function validateFormFactor(card, allowFBSwipe, approvedFormFactors) {
  //Only allow fallback swipes for chip cards
  if (!allowFBSwipe && card.chipCard && card.formFactor === FormFactor.MagneticCardSwipe) {
    if (approvedFormFactors.has(FormFactor.Chip)) {
      // TODO Temporary provision that must be removed post certification
      return (0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.cannotSwipeChipCard);
    }
    Log.info('Allow fallback swipes on chip card as chip reader was not enabled');
  }

  //Do not accept card inserts if Chip form factor was not enabled
  if (card.formFactor === FormFactor.Chip && !approvedFormFactors.has(FormFactor.Chip)) {
    return (0, _sdkErrors.getError)(new Error(), _sdkErrors.transaction.mustSwipeCard);
  }
}

},{"../common/sdkErrors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/common/sdkErrors.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/assert/assert.js":[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/util/util.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/async/lib/async.js":[function(require,module,exports){
(function (process,global){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
(function () {

    var async = {};
    function noop() {}
    function identity(v) {
        return v;
    }
    function toBool(v) {
        return !!v;
    }
    function notId(v) {
        return !v;
    }

    // global on the server, window in the browser
    var previous_async;

    // Establish the root object, `window` (`self`) in the browser, `global`
    // on the server, or `this` in some virtual machines. We use `self`
    // instead of `window` for `WebWorker` support.
    var root = typeof self === 'object' && self.self === self && self ||
            typeof global === 'object' && global.global === global && global ||
            this;

    if (root != null) {
        previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        return function() {
            if (fn === null) throw new Error("Callback was already called.");
            fn.apply(this, arguments);
            fn = null;
        };
    }

    function _once(fn) {
        return function() {
            if (fn === null) return;
            fn.apply(this, arguments);
            fn = null;
        };
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    // Ported from underscore.js isObject
    var _isObject = function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
    };

    function _isArrayLike(arr) {
        return _isArray(arr) || (
            // has a positive integer length property
            typeof arr.length === "number" &&
            arr.length >= 0 &&
            arr.length % 1 === 0
        );
    }

    function _arrayEach(arr, iterator) {
        var index = -1,
            length = arr.length;

        while (++index < length) {
            iterator(arr[index], index, arr);
        }
    }

    function _map(arr, iterator) {
        var index = -1,
            length = arr.length,
            result = Array(length);

        while (++index < length) {
            result[index] = iterator(arr[index], index, arr);
        }
        return result;
    }

    function _range(count) {
        return _map(Array(count), function (v, i) { return i; });
    }

    function _reduce(arr, iterator, memo) {
        _arrayEach(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    }

    function _forEachOf(object, iterator) {
        _arrayEach(_keys(object), function (key) {
            iterator(object[key], key);
        });
    }

    function _indexOf(arr, item) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === item) return i;
        }
        return -1;
    }

    var _keys = Object.keys || function (obj) {
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    function _keyIterator(coll) {
        var i = -1;
        var len;
        var keys;
        if (_isArrayLike(coll)) {
            len = coll.length;
            return function next() {
                i++;
                return i < len ? i : null;
            };
        } else {
            keys = _keys(coll);
            len = keys.length;
            return function next() {
                i++;
                return i < len ? keys[i] : null;
            };
        }
    }

    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
    // This accumulates the arguments passed into an array, after a given index.
    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
    function _restParam(func, startIndex) {
        startIndex = startIndex == null ? func.length - 1 : +startIndex;
        return function() {
            var length = Math.max(arguments.length - startIndex, 0);
            var rest = Array(length);
            for (var index = 0; index < length; index++) {
                rest[index] = arguments[index + startIndex];
            }
            switch (startIndex) {
                case 0: return func.call(this, rest);
                case 1: return func.call(this, arguments[0], rest);
            }
            // Currently unused but handle cases outside of the switch statement:
            // var args = Array(startIndex + 1);
            // for (index = 0; index < startIndex; index++) {
            //     args[index] = arguments[index];
            // }
            // args[startIndex] = rest;
            // return func.apply(this, args);
        };
    }

    function _withoutIndex(iterator) {
        return function (value, index, callback) {
            return iterator(value, callback);
        };
    }

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////

    // capture the global reference to guard against fakeTimer mocks
    var _setImmediate = typeof setImmediate === 'function' && setImmediate;

    var _delay = _setImmediate ? function(fn) {
        // not a direct alias for IE10 compatibility
        _setImmediate(fn);
    } : function(fn) {
        setTimeout(fn, 0);
    };

    if (typeof process === 'object' && typeof process.nextTick === 'function') {
        async.nextTick = process.nextTick;
    } else {
        async.nextTick = _delay;
    }
    async.setImmediate = _setImmediate ? _delay : async.nextTick;


    async.forEach =
    async.each = function (arr, iterator, callback) {
        return async.eachOf(arr, _withoutIndex(iterator), callback);
    };

    async.forEachSeries =
    async.eachSeries = function (arr, iterator, callback) {
        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
    };


    async.forEachLimit =
    async.eachLimit = function (arr, limit, iterator, callback) {
        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
    };

    async.forEachOf =
    async.eachOf = function (object, iterator, callback) {
        callback = _once(callback || noop);
        object = object || [];

        var iter = _keyIterator(object);
        var key, completed = 0;

        while ((key = iter()) != null) {
            completed += 1;
            iterator(object[key], key, only_once(done));
        }

        if (completed === 0) callback(null);

        function done(err) {
            completed--;
            if (err) {
                callback(err);
            }
            // Check key is null in case iterator isn't exhausted
            // and done resolved synchronously.
            else if (key === null && completed <= 0) {
                callback(null);
            }
        }
    };

    async.forEachOfSeries =
    async.eachOfSeries = function (obj, iterator, callback) {
        callback = _once(callback || noop);
        obj = obj || [];
        var nextKey = _keyIterator(obj);
        var key = nextKey();
        function iterate() {
            var sync = true;
            if (key === null) {
                return callback(null);
            }
            iterator(obj[key], key, only_once(function (err) {
                if (err) {
                    callback(err);
                }
                else {
                    key = nextKey();
                    if (key === null) {
                        return callback(null);
                    } else {
                        if (sync) {
                            async.setImmediate(iterate);
                        } else {
                            iterate();
                        }
                    }
                }
            }));
            sync = false;
        }
        iterate();
    };



    async.forEachOfLimit =
    async.eachOfLimit = function (obj, limit, iterator, callback) {
        _eachOfLimit(limit)(obj, iterator, callback);
    };

    function _eachOfLimit(limit) {

        return function (obj, iterator, callback) {
            callback = _once(callback || noop);
            obj = obj || [];
            var nextKey = _keyIterator(obj);
            if (limit <= 0) {
                return callback(null);
            }
            var done = false;
            var running = 0;
            var errored = false;

            (function replenish () {
                if (done && running <= 0) {
                    return callback(null);
                }

                while (running < limit && !errored) {
                    var key = nextKey();
                    if (key === null) {
                        done = true;
                        if (running <= 0) {
                            callback(null);
                        }
                        return;
                    }
                    running += 1;
                    iterator(obj[key], key, only_once(function (err) {
                        running -= 1;
                        if (err) {
                            callback(err);
                            errored = true;
                        }
                        else {
                            replenish();
                        }
                    }));
                }
            })();
        };
    }


    function doParallel(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOf, obj, iterator, callback);
        };
    }
    function doParallelLimit(fn) {
        return function (obj, limit, iterator, callback) {
            return fn(_eachOfLimit(limit), obj, iterator, callback);
        };
    }
    function doSeries(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOfSeries, obj, iterator, callback);
        };
    }

    function _asyncMap(eachfn, arr, iterator, callback) {
        callback = _once(callback || noop);
        arr = arr || [];
        var results = _isArrayLike(arr) ? [] : {};
        eachfn(arr, function (value, index, callback) {
            iterator(value, function (err, v) {
                results[index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    }

    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = doParallelLimit(_asyncMap);

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.inject =
    async.foldl =
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachOfSeries(arr, function (x, i, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };

    async.foldr =
    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, identity).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };

    async.transform = function (arr, memo, iterator, callback) {
        if (arguments.length === 3) {
            callback = iterator;
            iterator = memo;
            memo = _isArray(arr) ? [] : {};
        }

        async.eachOf(arr, function(v, k, cb) {
            iterator(memo, v, k, cb);
        }, function(err) {
            callback(err, memo);
        });
    };

    function _filter(eachfn, arr, iterator, callback) {
        var results = [];
        eachfn(arr, function (x, index, callback) {
            iterator(x, function (v) {
                if (v) {
                    results.push({index: index, value: x});
                }
                callback();
            });
        }, function () {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    }

    async.select =
    async.filter = doParallel(_filter);

    async.selectLimit =
    async.filterLimit = doParallelLimit(_filter);

    async.selectSeries =
    async.filterSeries = doSeries(_filter);

    function _reject(eachfn, arr, iterator, callback) {
        _filter(eachfn, arr, function(value, cb) {
            iterator(value, function(v) {
                cb(!v);
            });
        }, callback);
    }
    async.reject = doParallel(_reject);
    async.rejectLimit = doParallelLimit(_reject);
    async.rejectSeries = doSeries(_reject);

    function _createTester(eachfn, check, getResult) {
        return function(arr, limit, iterator, cb) {
            function done() {
                if (cb) cb(getResult(false, void 0));
            }
            function iteratee(x, _, callback) {
                if (!cb) return callback();
                iterator(x, function (v) {
                    if (cb && check(v)) {
                        cb(getResult(true, x));
                        cb = iterator = false;
                    }
                    callback();
                });
            }
            if (arguments.length > 3) {
                eachfn(arr, limit, iteratee, done);
            } else {
                cb = iterator;
                iterator = limit;
                eachfn(arr, iteratee, done);
            }
        };
    }

    async.any =
    async.some = _createTester(async.eachOf, toBool, identity);

    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);

    async.all =
    async.every = _createTester(async.eachOf, notId, notId);

    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);

    function _findGetResult(v, x) {
        return x;
    }
    async.detect = _createTester(async.eachOf, identity, _findGetResult);
    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                callback(null, _map(results.sort(comparator), function (x) {
                    return x.value;
                }));
            }

        });

        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }
    };

    async.auto = function (tasks, concurrency, callback) {
        if (typeof arguments[1] === 'function') {
            // concurrency is optional, shift the args.
            callback = concurrency;
            concurrency = null;
        }
        callback = _once(callback || noop);
        var keys = _keys(tasks);
        var remainingTasks = keys.length;
        if (!remainingTasks) {
            return callback(null);
        }
        if (!concurrency) {
            concurrency = remainingTasks;
        }

        var results = {};
        var runningTasks = 0;

        var hasError = false;

        var listeners = [];
        function addListener(fn) {
            listeners.unshift(fn);
        }
        function removeListener(fn) {
            var idx = _indexOf(listeners, fn);
            if (idx >= 0) listeners.splice(idx, 1);
        }
        function taskComplete() {
            remainingTasks--;
            _arrayEach(listeners.slice(0), function (fn) {
                fn();
            });
        }

        addListener(function () {
            if (!remainingTasks) {
                callback(null, results);
            }
        });

        _arrayEach(keys, function (k) {
            if (hasError) return;
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = _restParam(function(err, args) {
                runningTasks--;
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _forEachOf(results, function(val, rkey) {
                        safeResults[rkey] = val;
                    });
                    safeResults[k] = args;
                    hasError = true;

                    callback(err, safeResults);
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            });
            var requires = task.slice(0, task.length - 1);
            // prevent dead-locks
            var len = requires.length;
            var dep;
            while (len--) {
                if (!(dep = tasks[requires[len]])) {
                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));
                }
                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
                    throw new Error('Has cyclic dependencies');
                }
            }
            function ready() {
                return runningTasks < concurrency && _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            }
            if (ready()) {
                runningTasks++;
                task[task.length - 1](taskCallback, results);
            }
            else {
                addListener(listener);
            }
            function listener() {
                if (ready()) {
                    runningTasks++;
                    removeListener(listener);
                    task[task.length - 1](taskCallback, results);
                }
            }
        });
    };



    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var DEFAULT_INTERVAL = 0;

        var attempts = [];

        var opts = {
            times: DEFAULT_TIMES,
            interval: DEFAULT_INTERVAL
        };

        function parseTimes(acc, t){
            if(typeof t === 'number'){
                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
            } else if(typeof t === 'object'){
                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
            } else {
                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
            }
        }

        var length = arguments.length;
        if (length < 1 || length > 3) {
            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
        } else if (length <= 2 && typeof times === 'function') {
            callback = task;
            task = times;
        }
        if (typeof times !== 'function') {
            parseTimes(opts, times);
        }
        opts.callback = callback;
        opts.task = task;

        function wrappedTask(wrappedCallback, wrappedResults) {
            function retryAttempt(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            }

            function retryInterval(interval){
                return function(seriesCallback){
                    setTimeout(function(){
                        seriesCallback(null);
                    }, interval);
                };
            }

            while (opts.times) {

                var finalAttempt = !(opts.times-=1);
                attempts.push(retryAttempt(opts.task, finalAttempt));
                if(!finalAttempt && opts.interval > 0){
                    attempts.push(retryInterval(opts.interval));
                }
            }

            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || opts.callback)(data.err, data.result);
            });
        }

        // If a callback is passed, run this as a controll flow
        return opts.callback ? wrappedTask() : wrappedTask;
    };

    async.waterfall = function (tasks, callback) {
        callback = _once(callback || noop);
        if (!_isArray(tasks)) {
            var err = new Error('First argument to waterfall must be an array of functions');
            return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        function wrapIterator(iterator) {
            return _restParam(function (err, args) {
                if (err) {
                    callback.apply(null, [err].concat(args));
                }
                else {
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    ensureAsync(iterator).apply(null, args);
                }
            });
        }
        wrapIterator(async.iterator(tasks))();
    };

    function _parallel(eachfn, tasks, callback) {
        callback = callback || noop;
        var results = _isArrayLike(tasks) ? [] : {};

        eachfn(tasks, function (task, key, callback) {
            task(_restParam(function (err, args) {
                if (args.length <= 1) {
                    args = args[0];
                }
                results[key] = args;
                callback(err);
            }));
        }, function (err) {
            callback(err, results);
        });
    }

    async.parallel = function (tasks, callback) {
        _parallel(async.eachOf, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel(_eachOfLimit(limit), tasks, callback);
    };

    async.series = function(tasks, callback) {
        _parallel(async.eachOfSeries, tasks, callback);
    };

    async.iterator = function (tasks) {
        function makeCallback(index) {
            function fn() {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            }
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        }
        return makeCallback(0);
    };

    async.apply = _restParam(function (fn, args) {
        return _restParam(function (callArgs) {
            return fn.apply(
                null, args.concat(callArgs)
            );
        });
    });

    function _concat(eachfn, arr, fn, callback) {
        var result = [];
        eachfn(arr, function (x, index, cb) {
            fn(x, function (err, y) {
                result = result.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, result);
        });
    }
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        callback = callback || noop;
        if (test()) {
            var next = _restParam(function(err, args) {
                if (err) {
                    callback(err);
                } else if (test.apply(this, args)) {
                    iterator(next);
                } else {
                    callback.apply(null, [null].concat(args));
                }
            });
            iterator(next);
        } else {
            callback(null);
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        var calls = 0;
        return async.whilst(function() {
            return ++calls <= 1 || test.apply(this, arguments);
        }, iterator, callback);
    };

    async.until = function (test, iterator, callback) {
        return async.whilst(function() {
            return !test.apply(this, arguments);
        }, iterator, callback);
    };

    async.doUntil = function (iterator, test, callback) {
        return async.doWhilst(iterator, function() {
            return !test.apply(this, arguments);
        }, callback);
    };

    async.during = function (test, iterator, callback) {
        callback = callback || noop;

        var next = _restParam(function(err, args) {
            if (err) {
                callback(err);
            } else {
                args.push(check);
                test.apply(this, args);
            }
        });

        var check = function(err, truth) {
            if (err) {
                callback(err);
            } else if (truth) {
                iterator(next);
            } else {
                callback(null);
            }
        };

        test(check);
    };

    async.doDuring = function (iterator, test, callback) {
        var calls = 0;
        async.during(function(next) {
            if (calls++ < 1) {
                next(null, true);
            } else {
                test.apply(this, arguments);
            }
        }, iterator, callback);
    };

    function _queue(worker, concurrency, payload) {
        if (concurrency == null) {
            concurrency = 1;
        }
        else if(concurrency === 0) {
            throw new Error('Concurrency must not be zero');
        }
        function _insert(q, data, pos, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    callback: callback || noop
                };

                if (pos) {
                    q.tasks.unshift(item);
                } else {
                    q.tasks.push(item);
                }

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
            });
            async.setImmediate(q.process);
        }
        function _next(q, tasks) {
            return function(){
                workers -= 1;

                var removed = false;
                var args = arguments;
                _arrayEach(tasks, function (task) {
                    _arrayEach(workersList, function (worker, index) {
                        if (worker === task && !removed) {
                            workersList.splice(index, 1);
                            removed = true;
                        }
                    });

                    task.callback.apply(task, args);
                });
                if (q.tasks.length + workers === 0) {
                    q.drain();
                }
                q.process();
            };
        }

        var workers = 0;
        var workersList = [];
        var q = {
            tasks: [],
            concurrency: concurrency,
            payload: payload,
            saturated: noop,
            empty: noop,
            drain: noop,
            started: false,
            paused: false,
            push: function (data, callback) {
                _insert(q, data, false, callback);
            },
            kill: function () {
                q.drain = noop;
                q.tasks = [];
            },
            unshift: function (data, callback) {
                _insert(q, data, true, callback);
            },
            process: function () {
                while(!q.paused && workers < q.concurrency && q.tasks.length){

                    var tasks = q.payload ?
                        q.tasks.splice(0, q.payload) :
                        q.tasks.splice(0, q.tasks.length);

                    var data = _map(tasks, function (task) {
                        return task.data;
                    });

                    if (q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    workersList.push(tasks[0]);
                    var cb = only_once(_next(q, tasks));
                    worker(data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            workersList: function () {
                return workersList;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                var resumeCount = Math.min(q.concurrency, q.tasks.length);
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= resumeCount; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    }

    async.queue = function (worker, concurrency) {
        var q = _queue(function (items, cb) {
            worker(items[0], cb);
        }, concurrency, 1);

        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
            return a.priority - b.priority;
        }

        function _binarySearch(sequence, item, compare) {
            var beg = -1,
                end = sequence.length - 1;
            while (beg < end) {
                var mid = beg + ((end - beg + 1) >>> 1);
                if (compare(item, sequence[mid]) >= 0) {
                    beg = mid;
                } else {
                    end = mid - 1;
                }
            }
            return beg;
        }

        function _insert(q, data, priority, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    priority: priority,
                    callback: typeof callback === 'function' ? callback : noop
                };

                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
                async.setImmediate(q.process);
            });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
            _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        return _queue(worker, 1, payload);
    };

    function _console_fn(name) {
        return _restParam(function (fn, args) {
            fn.apply(null, args.concat([_restParam(function (err, args) {
                if (typeof console === 'object') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _arrayEach(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            })]));
        });
    }
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        var has = Object.prototype.hasOwnProperty;
        hasher = hasher || identity;
        var memoized = _restParam(function memoized(args) {
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (has.call(memo, key)) {   
                async.setImmediate(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (has.call(queues, key)) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([_restParam(function (args) {
                    memo[key] = args;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                        q[i].apply(null, args);
                    }
                })]));
            }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
        return function () {
            return (fn.unmemoized || fn).apply(null, arguments);
        };
    };

    function _times(mapper) {
        return function (count, iterator, callback) {
            mapper(_range(count), iterator, callback);
        };
    }

    async.times = _times(async.map);
    async.timesSeries = _times(async.mapSeries);
    async.timesLimit = function (count, limit, iterator, callback) {
        return async.mapLimit(_range(count), limit, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return _restParam(function (args) {
            var that = this;

            var callback = args[args.length - 1];
            if (typeof callback == 'function') {
                args.pop();
            } else {
                callback = noop;
            }

            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
                    cb(err, nextargs);
                })]));
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        });
    };

    async.compose = function (/* functions... */) {
        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };


    function _applyEach(eachfn) {
        return _restParam(function(fns, args) {
            var go = _restParam(function(args) {
                var that = this;
                var callback = args.pop();
                return eachfn(fns, function (fn, _, cb) {
                    fn.apply(that, args.concat([cb]));
                },
                callback);
            });
            if (args.length) {
                return go.apply(this, args);
            }
            else {
                return go;
            }
        });
    }

    async.applyEach = _applyEach(async.eachOf);
    async.applyEachSeries = _applyEach(async.eachOfSeries);


    async.forever = function (fn, callback) {
        var done = only_once(callback || noop);
        var task = ensureAsync(fn);
        function next(err) {
            if (err) {
                return done(err);
            }
            task(next);
        }
        next();
    };

    function ensureAsync(fn) {
        return _restParam(function (args) {
            var callback = args.pop();
            args.push(function () {
                var innerArgs = arguments;
                if (sync) {
                    async.setImmediate(function () {
                        callback.apply(null, innerArgs);
                    });
                } else {
                    callback.apply(null, innerArgs);
                }
            });
            var sync = true;
            fn.apply(this, args);
            sync = false;
        });
    }

    async.ensureAsync = ensureAsync;

    async.constant = _restParam(function(values) {
        var args = [null].concat(values);
        return function (callback) {
            return callback.apply(this, args);
        };
    });

    async.wrapSync =
    async.asyncify = function asyncify(func) {
        return _restParam(function (args) {
            var callback = args.pop();
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            // if result is Promise object
            if (_isObject(result) && typeof result.then === "function") {
                result.then(function(value) {
                    callback(null, value);
                })["catch"](function(err) {
                    callback(err.message ? err : new Error(err));
                });
            } else {
                callback(null, result);
            }
        });
    };

    // Node.js
    if (typeof module === 'object' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define === 'function' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/process/browser.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/babel-regenerator-runtime/runtime.js":[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = Object.create((outerFn || Generator).prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function(arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    // This invoke function is written in a style that assumes some
    // calling function (or Promise) will handle exceptions.
    function invoke(method, arg) {
      var result = generator[method](arg);
      var value = result.value;
      return value instanceof AwaitArgument
        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
        : Promise.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration. If the Promise is rejected, however, the
            // result for this iteration will be rejected with the same
            // reason. Note that rejections of yielded Promises are not
            // thrown back into the generator function, as is the case
            // when an awaited Promise is rejected. This difference in
            // behavior between yield and await is important, because it
            // allows the consumer to decide what to do with the yielded
            // rejection (swallow it and continue, manually .throw it back
            // into the generator, abandon iteration, whatever). With
            // await, by contrast, there is no opportunity to examine the
            // rejection reason outside the generator function, so the
            // only option is to throw it from the await expression, and
            // let the generator function handle the exception.
            result.value = unwrapped;
            return result;
          });
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var invokeNext = invoke.bind(generator, "next");
    var invokeThrow = invoke.bind(generator, "throw");
    var invokeReturn = invoke.bind(generator, "return");
    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return invoke(method, arg);
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : new Promise(function (resolve) {
          resolve(callInvokeWithMethodAndArg());
        });
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          context._sent = arg;

          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }
        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/process/browser.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/base64-js/index.js":[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/bignumber.js/bignumber.js":[function(require,module,exports){
/*! bignumber.js v2.3.0 https://github.com/MikeMcl/bignumber.js/LICENCE */

;(function (globalObj) {
    'use strict';

    /*
      bignumber.js v2.3.0
      A JavaScript library for arbitrary-precision arithmetic.
      https://github.com/MikeMcl/bignumber.js
      Copyright (c) 2016 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */


    var cryptoObj, parseNumeric,
        isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        mathceil = Math.ceil,
        mathfloor = Math.floor,
        notBool = ' not a boolean or binary digit',
        roundingMode = 'rounding mode',
        tooManyDigits = 'number type has more than 15 significant digits',
        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
        BASE = 1e14,
        LOG_BASE = 14,
        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
        SQRT_BASE = 1e7,

        /*
         * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
         * the arguments to toExponential, toFixed, toFormat, and toPrecision, beyond which an
         * exception is thrown (if ERRORS is true).
         */
        MAX = 1E9;                                   // 0 to MAX_INT32

    if ( typeof crypto != 'undefined' ) cryptoObj = crypto;


    /*
     * Create and return a BigNumber constructor.
     */
    function constructorFactory(configObj) {
        var div,

            // id tracks the caller function, so its name can be included in error messages.
            id = 0,
            P = BigNumber.prototype,
            ONE = new BigNumber(1),


            /********************************* EDITABLE DEFAULTS **********************************/


            /*
             * The default values below must be integers within the inclusive ranges stated.
             * The values can also be changed at run-time using BigNumber.config.
             */

            // The maximum number of decimal places for operations involving division.
            DECIMAL_PLACES = 20,                     // 0 to MAX

            /*
             * The rounding mode used when rounding to the above decimal places, and when using
             * toExponential, toFixed, toFormat and toPrecision, and round (default value).
             * UP         0 Away from zero.
             * DOWN       1 Towards zero.
             * CEIL       2 Towards +Infinity.
             * FLOOR      3 Towards -Infinity.
             * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
             * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
             * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
             * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
             * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
             */
            ROUNDING_MODE = 4,                       // 0 to 8

            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

            // The exponent value at and beneath which toString returns exponential notation.
            // Number type: -7
            TO_EXP_NEG = -7,                         // 0 to -MAX

            // The exponent value at and above which toString returns exponential notation.
            // Number type: 21
            TO_EXP_POS = 21,                         // 0 to MAX

            // RANGE : [MIN_EXP, MAX_EXP]

            // The minimum exponent value, beneath which underflow to zero occurs.
            // Number type: -324  (5e-324)
            MIN_EXP = -1e7,                          // -1 to -MAX

            // The maximum exponent value, above which overflow to Infinity occurs.
            // Number type:  308  (1.7976931348623157e+308)
            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
            MAX_EXP = 1e7,                           // 1 to MAX

            // Whether BigNumber Errors are ever thrown.
            ERRORS = true,                           // true or false

            // Change to intValidatorNoErrors if ERRORS is false.
            isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors

            // Whether to use cryptographically-secure random number generation, if available.
            CRYPTO = false,                          // true or false

            /*
             * The modulo mode used when calculating the modulus: a mod n.
             * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
             * The remainder (r) is calculated as: r = a - n * q.
             *
             * UP        0 The remainder is positive if the dividend is negative, else is negative.
             * DOWN      1 The remainder has the same sign as the dividend.
             *             This modulo mode is commonly known as 'truncated division' and is
             *             equivalent to (a % n) in JavaScript.
             * FLOOR     3 The remainder has the same sign as the divisor (Python %).
             * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
             * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
             *             The remainder is always positive.
             *
             * The truncated division, floored division, Euclidian division and IEEE 754 remainder
             * modes are commonly used for the modulus operation.
             * Although the other rounding modes can also be used, they may not give useful results.
             */
            MODULO_MODE = 1,                         // 0 to 9

            // The maximum number of significant digits of the result of the toPower operation.
            // If POW_PRECISION is 0, there will be unlimited significant digits.
            POW_PRECISION = 100,                     // 0 to MAX

            // The format specification used by the BigNumber.prototype.toFormat method.
            FORMAT = {
                decimalSeparator: '.',
                groupSeparator: ',',
                groupSize: 3,
                secondaryGroupSize: 0,
                fractionGroupSeparator: '\xA0',      // non-breaking space
                fractionGroupSize: 0
            };


        /******************************************************************************************/


        // CONSTRUCTOR


        /*
         * The BigNumber constructor and exported function.
         * Create and return a new instance of a BigNumber object.
         *
         * n {number|string|BigNumber} A numeric value.
         * [b] {number} The base of n. Integer, 2 to 64 inclusive.
         */
        function BigNumber( n, b ) {
            var c, e, i, num, len, str,
                x = this;

            // Enable constructor usage without new.
            if ( !( x instanceof BigNumber ) ) {

                // 'BigNumber() constructor call without new: {n}'
                if (ERRORS) raise( 26, 'constructor call without new', n );
                return new BigNumber( n, b );
            }

            // 'new BigNumber() base not an integer: {b}'
            // 'new BigNumber() base out of range: {b}'
            if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

                // Duplicate.
                if ( n instanceof BigNumber ) {
                    x.s = n.s;
                    x.e = n.e;
                    x.c = ( n = n.c ) ? n.slice() : n;
                    id = 0;
                    return;
                }

                if ( ( num = typeof n == 'number' ) && n * 0 == 0 ) {
                    x.s = 1 / n < 0 ? ( n = -n, -1 ) : 1;

                    // Fast path for integers.
                    if ( n === ~~n ) {
                        for ( e = 0, i = n; i >= 10; i /= 10, e++ );
                        x.e = e;
                        x.c = [n];
                        id = 0;
                        return;
                    }

                    str = n + '';
                } else {
                    if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }
            } else {
                b = b | 0;
                str = n + '';

                // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
                // Allow exponential notation to be used with base 10 argument.
                if ( b == 10 ) {
                    x = new BigNumber( n instanceof BigNumber ? n : str );
                    return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
                }

                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                // Any number in exponential form will fail due to the [Ee][+-].
                if ( ( num = typeof n == 'number' ) && n * 0 != 0 ||
                  !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
                    '(?:\\.' + c + ')?$',b < 37 ? 'i' : '' ) ).test(str) ) {
                    return parseNumeric( x, str, num, b );
                }

                if (num) {
                    x.s = 1 / n < 0 ? ( str = str.slice(1), -1 ) : 1;

                    if ( ERRORS && str.replace( /^0\.0*|\./, '' ).length > 15 ) {

                        // 'new BigNumber() number type has more than 15 significant digits: {n}'
                        raise( id, tooManyDigits, n );
                    }

                    // Prevent later check for length on converted number.
                    num = false;
                } else {
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }

                str = convertBase( str, 10, b, x.s );
            }

            // Decimal point?
            if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );

            // Exponential form?
            if ( ( i = str.search( /e/i ) ) > 0 ) {

                // Determine exponent.
                if ( e < 0 ) e = i;
                e += +str.slice( i + 1 );
                str = str.substring( 0, i );
            } else if ( e < 0 ) {

                // Integer.
                e = str.length;
            }

            // Determine leading zeros.
            for ( i = 0; str.charCodeAt(i) === 48; i++ );

            // Determine trailing zeros.
            for ( len = str.length; str.charCodeAt(--len) === 48; );
            str = str.slice( i, len + 1 );

            if (str) {
                len = str.length;

                // Disallow numbers with over 15 significant digits if number type.
                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                if ( num && ERRORS && len > 15 && ( n > MAX_SAFE_INTEGER || n !== mathfloor(n) ) ) {
                    raise( id, tooManyDigits, x.s * n );
                }

                e = e - i - 1;

                 // Overflow?
                if ( e > MAX_EXP ) {

                    // Infinity.
                    x.c = x.e = null;

                // Underflow?
                } else if ( e < MIN_EXP ) {

                    // Zero.
                    x.c = [ x.e = 0 ];
                } else {
                    x.e = e;
                    x.c = [];

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = ( e + 1 ) % LOG_BASE;
                    if ( e < 0 ) i += LOG_BASE;

                    if ( i < len ) {
                        if (i) x.c.push( +str.slice( 0, i ) );

                        for ( len -= LOG_BASE; i < len; ) {
                            x.c.push( +str.slice( i, i += LOG_BASE ) );
                        }

                        str = str.slice(i);
                        i = LOG_BASE - str.length;
                    } else {
                        i -= len;
                    }

                    for ( ; i--; str += '0' );
                    x.c.push( +str );
                }
            } else {

                // Zero.
                x.c = [ x.e = 0 ];
            }

            id = 0;
        }


        // CONSTRUCTOR PROPERTIES


        BigNumber.another = constructorFactory;

        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;


        /*
         * Configure infrequently-changing library-wide settings.
         *
         * Accept an object or an argument list, with one or many of the following properties or
         * parameters respectively:
         *
         *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive
         *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive
         *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to 0 incl., 0 to MAX incl.]
         *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to -1 incl., integer 1 to MAX incl.]
         *   ERRORS          {boolean|number}   true, false, 1 or 0
         *   CRYPTO          {boolean|number}   true, false, 1 or 0
         *   MODULO_MODE     {number}           0 to 9 inclusive
         *   POW_PRECISION   {number}           0 to MAX inclusive
         *   FORMAT          {object}           See BigNumber.prototype.toFormat
         *      decimalSeparator       {string}
         *      groupSeparator         {string}
         *      groupSize              {number}
         *      secondaryGroupSize     {number}
         *      fractionGroupSeparator {string}
         *      fractionGroupSize      {number}
         *
         * (The values assigned to the above FORMAT object properties are not checked for validity.)
         *
         * E.g.
         * BigNumber.config(20, 4) is equivalent to
         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
         *
         * Ignore properties/parameters set to null or undefined.
         * Return an object with the properties current values.
         */
        BigNumber.config = function () {
            var v, p,
                i = 0,
                r = {},
                a = arguments,
                o = a[0],
                has = o && typeof o == 'object'
                  ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
                  : function () { if ( a.length > i ) return ( v = a[i++] ) != null; };

            // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
            // 'config() DECIMAL_PLACES not an integer: {v}'
            // 'config() DECIMAL_PLACES out of range: {v}'
            if ( has( p = 'DECIMAL_PLACES' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                DECIMAL_PLACES = v | 0;
            }
            r[p] = DECIMAL_PLACES;

            // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
            // 'config() ROUNDING_MODE not an integer: {v}'
            // 'config() ROUNDING_MODE out of range: {v}'
            if ( has( p = 'ROUNDING_MODE' ) && isValidInt( v, 0, 8, 2, p ) ) {
                ROUNDING_MODE = v | 0;
            }
            r[p] = ROUNDING_MODE;

            // EXPONENTIAL_AT {number|number[]}
            // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
            // 'config() EXPONENTIAL_AT not an integer: {v}'
            // 'config() EXPONENTIAL_AT out of range: {v}'
            if ( has( p = 'EXPONENTIAL_AT' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, 0, 2, p ) && isValidInt( v[1], 0, MAX, 2, p ) ) {
                        TO_EXP_NEG = v[0] | 0;
                        TO_EXP_POS = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    TO_EXP_NEG = -( TO_EXP_POS = ( v < 0 ? -v : v ) | 0 );
                }
            }
            r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

            // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
            // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
            // 'config() RANGE not an integer: {v}'
            // 'config() RANGE cannot be zero: {v}'
            // 'config() RANGE out of range: {v}'
            if ( has( p = 'RANGE' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, -1, 2, p ) && isValidInt( v[1], 1, MAX, 2, p ) ) {
                        MIN_EXP = v[0] | 0;
                        MAX_EXP = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v < 0 ? -v : v ) | 0 );
                    else if (ERRORS) raise( 2, p + ' cannot be zero', v );
                }
            }
            r[p] = [ MIN_EXP, MAX_EXP ];

            // ERRORS {boolean|number} true, false, 1 or 0.
            // 'config() ERRORS not a boolean or binary digit: {v}'
            if ( has( p = 'ERRORS' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    id = 0;
                    isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = ERRORS;

            // CRYPTO {boolean|number} true, false, 1 or 0.
            // 'config() CRYPTO not a boolean or binary digit: {v}'
            // 'config() crypto unavailable: {crypto}'
            if ( has( p = 'CRYPTO' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    CRYPTO = !!( v && cryptoObj );
                    if ( v && !CRYPTO && ERRORS ) raise( 2, 'crypto unavailable', cryptoObj );
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = CRYPTO;

            // MODULO_MODE {number} Integer, 0 to 9 inclusive.
            // 'config() MODULO_MODE not an integer: {v}'
            // 'config() MODULO_MODE out of range: {v}'
            if ( has( p = 'MODULO_MODE' ) && isValidInt( v, 0, 9, 2, p ) ) {
                MODULO_MODE = v | 0;
            }
            r[p] = MODULO_MODE;

            // POW_PRECISION {number} Integer, 0 to MAX inclusive.
            // 'config() POW_PRECISION not an integer: {v}'
            // 'config() POW_PRECISION out of range: {v}'
            if ( has( p = 'POW_PRECISION' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                POW_PRECISION = v | 0;
            }
            r[p] = POW_PRECISION;

            // FORMAT {object}
            // 'config() FORMAT not an object: {v}'
            if ( has( p = 'FORMAT' ) ) {

                if ( typeof v == 'object' ) {
                    FORMAT = v;
                } else if (ERRORS) {
                    raise( 2, p + ' not an object', v );
                }
            }
            r[p] = FORMAT;

            return r;
        };


        /*
         * Return a new BigNumber whose value is the maximum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.max = function () { return maxOrMin( arguments, P.lt ); };


        /*
         * Return a new BigNumber whose value is the minimum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.min = function () { return maxOrMin( arguments, P.gt ); };


        /*
         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
         * zeros are produced).
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         *
         * 'random() decimal places not an integer: {dp}'
         * 'random() decimal places out of range: {dp}'
         * 'random() crypto unavailable: {crypto}'
         */
        BigNumber.random = (function () {
            var pow2_53 = 0x20000000000000;

            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
            // Check if Math.random() produces more than 32 bits of randomness.
            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
              ? function () { return mathfloor( Math.random() * pow2_53 ); }
              : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                  (Math.random() * 0x800000 | 0); };

            return function (dp) {
                var a, b, e, k, v,
                    i = 0,
                    c = [],
                    rand = new BigNumber(ONE);

                dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
                k = mathceil( dp / LOG_BASE );

                if (CRYPTO) {

                    // Browsers supporting crypto.getRandomValues.
                    if ( cryptoObj && cryptoObj.getRandomValues ) {

                        a = cryptoObj.getRandomValues( new Uint32Array( k *= 2 ) );

                        for ( ; i < k; ) {

                            // 53 bits:
                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                            //                                     11111 11111111 11111111
                            // 0x20000 is 2^21.
                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                            // Rejection sampling:
                            // 0 <= v < 9007199254740992
                            // Probability that v >= 9e15, is
                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                            if ( v >= 9e15 ) {
                                b = cryptoObj.getRandomValues( new Uint32Array(2) );
                                a[i] = b[0];
                                a[i + 1] = b[1];
                            } else {

                                // 0 <= v <= 8999999999999999
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 2;
                            }
                        }
                        i = k / 2;

                    // Node.js supporting crypto.randomBytes.
                    } else if ( cryptoObj && cryptoObj.randomBytes ) {

                        // buffer
                        a = cryptoObj.randomBytes( k *= 7 );

                        for ( ; i < k; ) {

                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                            // 0 <= v < 9007199254740992
                            v = ( ( a[i] & 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
                                  ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
                                  ( a[i + 4] << 16 ) + ( a[i + 5] << 8 ) + a[i + 6];

                            if ( v >= 9e15 ) {
                                cryptoObj.randomBytes(7).copy( a, i );
                            } else {

                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 7;
                            }
                        }
                        i = k / 7;
                    } else if (ERRORS) {
                        raise( 14, 'crypto unavailable', cryptoObj );
                    }
                }

                // Use Math.random: CRYPTO is false or crypto is unavailable and ERRORS is false.
                if (!i) {

                    for ( ; i < k; ) {
                        v = random53bitInt();
                        if ( v < 9e15 ) c[i++] = v % 1e14;
                    }
                }

                k = c[--i];
                dp %= LOG_BASE;

                // Convert trailing digits to zeros according to dp.
                if ( k && dp ) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor( k / v ) * v;
                }

                // Remove trailing elements which are zero.
                for ( ; c[i] === 0; c.pop(), i-- );

                // Zero?
                if ( i < 0 ) {
                    c = [ e = 0 ];
                } else {

                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for ( e = -1 ; c[0] === 0; c.shift(), e -= LOG_BASE);

                    // Count the digits of the first element of c to determine leading zeros, and...
                    for ( i = 1, v = c[0]; v >= 10; v /= 10, i++);

                    // adjust the exponent accordingly.
                    if ( i < LOG_BASE ) e -= LOG_BASE - i;
                }

                rand.e = e;
                rand.c = c;
                return rand;
            };
        })();


        // PRIVATE FUNCTIONS


        // Convert a numeric string of baseIn to a numeric string of baseOut.
        function convertBase( str, baseOut, baseIn, sign ) {
            var d, e, k, r, x, xc, y,
                i = str.indexOf( '.' ),
                dp = DECIMAL_PLACES,
                rm = ROUNDING_MODE;

            if ( baseIn < 37 ) str = str.toLowerCase();

            // Non-integer.
            if ( i >= 0 ) {
                k = POW_PRECISION;

                // Unlimited precision.
                POW_PRECISION = 0;
                str = str.replace( '.', '' );
                y = new BigNumber(baseIn);
                x = y.pow( str.length - i );
                POW_PRECISION = k;

                // Convert str as if an integer, then restore the fraction part by dividing the
                // result by its base raised to a power.
                y.c = toBaseOut( toFixedPoint( coeffToString( x.c ), x.e ), 10, baseOut );
                y.e = y.c.length;
            }

            // Convert the number as integer.
            xc = toBaseOut( str, baseIn, baseOut );
            e = k = xc.length;

            // Remove trailing zeros.
            for ( ; xc[--k] == 0; xc.pop() );
            if ( !xc[0] ) return '0';

            if ( i < 0 ) {
                --e;
            } else {
                x.c = xc;
                x.e = e;

                // sign is needed for correct rounding.
                x.s = sign;
                x = div( x, y, dp, rm, baseOut );
                xc = x.c;
                r = x.r;
                e = x.e;
            }

            d = e + dp + 1;

            // The rounding digit, i.e. the digit to the right of the digit that may be rounded up.
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;

            r = rm < 4 ? ( i != null || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                       : i > k || i == k &&( rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                         rm == ( x.s < 0 ? 8 : 7 ) );

            if ( d < 1 || !xc[0] ) {

                // 1^-dp or 0.
                str = r ? toFixedPoint( '1', -dp ) : '0';
            } else {
                xc.length = d;

                if (r) {

                    // Rounding up may mean the previous digit has to be rounded up and so on.
                    for ( --baseOut; ++xc[--d] > baseOut; ) {
                        xc[d] = 0;

                        if ( !d ) {
                            ++e;
                            xc.unshift(1);
                        }
                    }
                }

                // Determine trailing zeros.
                for ( k = xc.length; !xc[--k]; );

                // E.g. [4, 11, 15] becomes 4bf.
                for ( i = 0, str = ''; i <= k; str += ALPHABET.charAt( xc[i++] ) );
                str = toFixedPoint( str, e );
            }

            // The caller will add the sign.
            return str;
        }


        // Perform division in the specified base. Called by div and convertBase.
        div = (function () {

            // Assume non-zero x and k.
            function multiply( x, k, base ) {
                var m, temp, xlo, xhi,
                    carry = 0,
                    i = x.length,
                    klo = k % SQRT_BASE,
                    khi = k / SQRT_BASE | 0;

                for ( x = x.slice(); i--; ) {
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;
                    carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;
                    x[i] = temp % base;
                }

                if (carry) x.unshift(carry);

                return x;
            }

            function compare( a, b, aL, bL ) {
                var i, cmp;

                if ( aL != bL ) {
                    cmp = aL > bL ? 1 : -1;
                } else {

                    for ( i = cmp = 0; i < aL; i++ ) {

                        if ( a[i] != b[i] ) {
                            cmp = a[i] > b[i] ? 1 : -1;
                            break;
                        }
                    }
                }
                return cmp;
            }

            function subtract( a, b, aL, base ) {
                var i = 0;

                // Subtract b from a.
                for ( ; aL--; ) {
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                }

                // Remove leading zeros.
                for ( ; !a[0] && a.length > 1; a.shift() );
            }

            // x: dividend, y: divisor.
            return function ( x, y, dp, rm, base ) {
                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                    yL, yz,
                    s = x.s == y.s ? 1 : -1,
                    xc = x.c,
                    yc = y.c;

                // Either NaN, Infinity or 0?
                if ( !xc || !xc[0] || !yc || !yc[0] ) {

                    return new BigNumber(

                      // Return NaN if either NaN, or both Infinity or 0.
                      !x.s || !y.s || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :

                        // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                    );
                }

                q = new BigNumber(s);
                qc = q.c = [];
                e = x.e - y.e;
                s = dp + e + 1;

                if ( !base ) {
                    base = BASE;
                    e = bitFloor( x.e / LOG_BASE ) - bitFloor( y.e / LOG_BASE );
                    s = s / LOG_BASE | 0;
                }

                // Result exponent may be one less then the current value of e.
                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );
                if ( yc[i] > ( xc[i] || 0 ) ) e--;

                if ( s < 0 ) {
                    qc.push(1);
                    more = true;
                } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;

                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                    n = mathfloor( base / ( yc[0] + 1 ) );

                    // Not necessary, but to handle odd bases where yc[0] == ( base / 2 ) - 1.
                    // if ( n > 1 || n++ == 1 && yc[0] < base / 2 ) {
                    if ( n > 1 ) {
                        yc = multiply( yc, n, base );
                        xc = multiply( xc, n, base );
                        yL = yc.length;
                        xL = xc.length;
                    }

                    xi = yL;
                    rem = xc.slice( 0, yL );
                    remL = rem.length;

                    // Add zeros to make remainder as long as divisor.
                    for ( ; remL < yL; rem[remL++] = 0 );
                    yz = yc.slice();
                    yz.unshift(0);
                    yc0 = yc[0];
                    if ( yc[1] >= base / 2 ) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if ( base == 3 && yc0 == 1 ) yc0 = 1 + 1e-15;

                    do {
                        n = 0;

                        // Compare divisor and remainder.
                        cmp = compare( yc, rem, yL, remL );

                        // If divisor < remainder.
                        if ( cmp < 0 ) {

                            // Calculate trial digit, n.

                            rem0 = rem[0];
                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );

                            // n is how many times the divisor goes into the current remainder.
                            n = mathfloor( rem0 / yc0 );

                            //  Algorithm:
                            //  1. product = divisor * trial digit (n)
                            //  2. if product > remainder: product -= divisor, n--
                            //  3. remainder -= product
                            //  4. if product was < remainder at 2:
                            //    5. compare new remainder and divisor
                            //    6. If remainder > divisor: remainder -= divisor, n++

                            if ( n > 1 ) {

                                // n may be > base only when base is 3.
                                if (n >= base) n = base - 1;

                                // product = divisor * trial digit.
                                prod = multiply( yc, n, base );
                                prodL = prod.length;
                                remL = rem.length;

                                // Compare product and remainder.
                                // If product > remainder.
                                // Trial digit n too high.
                                // n is 1 too high about 5% of the time, and is not known to have
                                // ever been more than 1 too high.
                                while ( compare( prod, rem, prodL, remL ) == 1 ) {
                                    n--;

                                    // Subtract divisor from product.
                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );
                                    prodL = prod.length;
                                    cmp = 1;
                                }
                            } else {

                                // n is 0 or 1, cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below,
                                // so change cmp to 1 to avoid it.
                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                if ( n == 0 ) {

                                    // divisor < remainder, so n must be at least 1.
                                    cmp = n = 1;
                                }

                                // product = divisor
                                prod = yc.slice();
                                prodL = prod.length;
                            }

                            if ( prodL < remL ) prod.unshift(0);

                            // Subtract product from remainder.
                            subtract( rem, prod, remL, base );
                            remL = rem.length;

                             // If product was < remainder.
                            if ( cmp == -1 ) {

                                // Compare divisor and new remainder.
                                // If divisor < new remainder, subtract divisor from remainder.
                                // Trial digit n too low.
                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                while ( compare( yc, rem, yL, remL ) < 1 ) {
                                    n++;

                                    // Subtract divisor from remainder.
                                    subtract( rem, yL < remL ? yz : yc, remL, base );
                                    remL = rem.length;
                                }
                            }
                        } else if ( cmp === 0 ) {
                            n++;
                            rem = [0];
                        } // else cmp === 1 and n will be 0

                        // Add the next digit, n, to the result array.
                        qc[i++] = n;

                        // Update the remainder.
                        if ( rem[0] ) {
                            rem[remL++] = xc[xi] || 0;
                        } else {
                            rem = [ xc[xi] ];
                            remL = 1;
                        }
                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );

                    more = rem[0] != null;

                    // Leading zero?
                    if ( !qc[0] ) qc.shift();
                }

                if ( base == BASE ) {

                    // To calculate q.e, first get the number of digits of qc[0].
                    for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );
                    round( q, dp + ( q.e = i + e * LOG_BASE - 1 ) + 1, rm, more );

                // Caller is convertBase.
                } else {
                    q.e = e;
                    q.r = +more;
                }

                return q;
            };
        })();


        /*
         * Return a string representing the value of BigNumber n in fixed-point or exponential
         * notation rounded to the specified decimal places or significant digits.
         *
         * n is a BigNumber.
         * i is the index of the last digit required (i.e. the digit that may be rounded up).
         * rm is the rounding mode.
         * caller is caller id: toExponential 19, toFixed 20, toFormat 21, toPrecision 24.
         */
        function format( n, i, rm, caller ) {
            var c0, e, ne, len, str;

            rm = rm != null && isValidInt( rm, 0, 8, caller, roundingMode )
              ? rm | 0 : ROUNDING_MODE;

            if ( !n.c ) return n.toString();
            c0 = n.c[0];
            ne = n.e;

            if ( i == null ) {
                str = coeffToString( n.c );
                str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG
                  ? toExponential( str, ne )
                  : toFixedPoint( str, ne );
            } else {
                n = round( new BigNumber(n), i, rm );

                // n.e may have changed if the value was rounded up.
                e = n.e;

                str = coeffToString( n.c );
                len = str.length;

                // toPrecision returns exponential notation if the number of significant digits
                // specified is less than the number of digits necessary to represent the integer
                // part of the value in fixed-point notation.

                // Exponential notation.
                if ( caller == 19 || caller == 24 && ( i <= e || e <= TO_EXP_NEG ) ) {

                    // Append zeros?
                    for ( ; len < i; str += '0', len++ );
                    str = toExponential( str, e );

                // Fixed-point notation.
                } else {
                    i -= ne;
                    str = toFixedPoint( str, e );

                    // Append zeros?
                    if ( e + 1 > len ) {
                        if ( --i > 0 ) for ( str += '.'; i--; str += '0' );
                    } else {
                        i += e - len;
                        if ( i > 0 ) {
                            if ( e + 1 == len ) str += '.';
                            for ( ; i--; str += '0' );
                        }
                    }
                }
            }

            return n.s < 0 && c0 ? '-' + str : str;
        }


        // Handle BigNumber.max and BigNumber.min.
        function maxOrMin( args, method ) {
            var m, n,
                i = 0;

            if ( isArray( args[0] ) ) args = args[0];
            m = new BigNumber( args[0] );

            for ( ; ++i < args.length; ) {
                n = new BigNumber( args[i] );

                // If any number is NaN, return NaN.
                if ( !n.s ) {
                    m = n;
                    break;
                } else if ( method.call( m, n ) ) {
                    m = n;
                }
            }

            return m;
        }


        /*
         * Return true if n is an integer in range, otherwise throw.
         * Use for argument validation when ERRORS is true.
         */
        function intValidatorWithErrors( n, min, max, caller, name ) {
            if ( n < min || n > max || n != truncate(n) ) {
                raise( caller, ( name || 'decimal places' ) +
                  ( n < min || n > max ? ' out of range' : ' not an integer' ), n );
            }

            return true;
        }


        /*
         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
         * Called by minus, plus and times.
         */
        function normalise( n, c, e ) {
            var i = 1,
                j = c.length;

             // Remove trailing zeros.
            for ( ; !c[--j]; c.pop() );

            // Calculate the base 10 exponent. First get the number of digits of c[0].
            for ( j = c[0]; j >= 10; j /= 10, i++ );

            // Overflow?
            if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {

                // Infinity.
                n.c = n.e = null;

            // Underflow?
            } else if ( e < MIN_EXP ) {

                // Zero.
                n.c = [ n.e = 0 ];
            } else {
                n.e = e;
                n.c = c;
            }

            return n;
        }


        // Handle values that fail the validity test in BigNumber.
        parseNumeric = (function () {
            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
                dotAfter = /^([^.]+)\.$/,
                dotBefore = /^\.([^.]+)$/,
                isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

            return function ( x, str, num, b ) {
                var base,
                    s = num ? str : str.replace( whitespaceOrPlus, '' );

                // No exception on Infinity or NaN.
                if ( isInfinityOrNaN.test(s) ) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                } else {
                    if ( !num ) {

                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                        s = s.replace( basePrefix, function ( m, p1, p2 ) {
                            base = ( p2 = p2.toLowerCase() ) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                            return !b || b == base ? p1 : m;
                        });

                        if (b) {
                            base = b;

                            // E.g. '1.' to '1', '.1' to '0.1'
                            s = s.replace( dotAfter, '$1' ).replace( dotBefore, '0.$1' );
                        }

                        if ( str != s ) return new BigNumber( s, base );
                    }

                    // 'new BigNumber() not a number: {n}'
                    // 'new BigNumber() not a base {b} number: {n}'
                    if (ERRORS) raise( id, 'not a' + ( b ? ' base ' + b : '' ) + ' number', str );
                    x.s = null;
                }

                x.c = x.e = null;
                id = 0;
            }
        })();


        // Throw a BigNumber Error.
        function raise( caller, msg, val ) {
            var error = new Error( [
                'new BigNumber',     // 0
                'cmp',               // 1
                'config',            // 2
                'div',               // 3
                'divToInt',          // 4
                'eq',                // 5
                'gt',                // 6
                'gte',               // 7
                'lt',                // 8
                'lte',               // 9
                'minus',             // 10
                'mod',               // 11
                'plus',              // 12
                'precision',         // 13
                'random',            // 14
                'round',             // 15
                'shift',             // 16
                'times',             // 17
                'toDigits',          // 18
                'toExponential',     // 19
                'toFixed',           // 20
                'toFormat',          // 21
                'toFraction',        // 22
                'pow',               // 23
                'toPrecision',       // 24
                'toString',          // 25
                'BigNumber'          // 26
            ][caller] + '() ' + msg + ': ' + val );

            error.name = 'BigNumber Error';
            id = 0;
            throw error;
        }


        /*
         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
         * If r is truthy, it is known that there are more digits after the rounding digit.
         */
        function round( x, sd, rm, r ) {
            var d, i, j, k, n, ni, rd,
                xc = x.c,
                pows10 = POWS_TEN;

            // if x is not Infinity or NaN...
            if (xc) {

                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                // ni is the index of n within x.c.
                // d is the number of digits of n.
                // i is the index of rd within n including leading zeros.
                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                out: {

                    // Get the number of digits of the first element of xc.
                    for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );
                    i = sd - d;

                    // If the rounding digit is in the first element of xc...
                    if ( i < 0 ) {
                        i += LOG_BASE;
                        j = sd;
                        n = xc[ ni = 0 ];

                        // Get the rounding digit at index j of n.
                        rd = n / pows10[ d - j - 1 ] % 10 | 0;
                    } else {
                        ni = mathceil( ( i + 1 ) / LOG_BASE );

                        if ( ni >= xc.length ) {

                            if (r) {

                                // Needed by sqrt.
                                for ( ; xc.length <= ni; xc.push(0) );
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                            } else {
                                break out;
                            }
                        } else {
                            n = k = xc[ni];

                            // Get the number of digits of n.
                            for ( d = 1; k >= 10; k /= 10, d++ );

                            // Get the index of rd within n.
                            i %= LOG_BASE;

                            // Get the index of rd within n, adjusted for leading zeros.
                            // The number of leading zeros of n is given by LOG_BASE - d.
                            j = i - LOG_BASE + d;

                            // Get the rounding digit at index j of n.
                            rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;
                        }
                    }

                    r = r || sd < 0 ||

                    // Are there any non-zero digits after the rounding digit?
                    // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                      xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );

                    r = rm < 4
                      ? ( rd || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                      : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&

                        // Check whether the digit to the left of the rounding digit is odd.
                        ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||
                          rm == ( x.s < 0 ? 8 : 7 ) );

                    if ( sd < 1 || !xc[0] ) {
                        xc.length = 0;

                        if (r) {

                            // Convert sd to decimal places.
                            sd -= x.e + 1;

                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                            xc[0] = pows10[ ( LOG_BASE - sd % LOG_BASE ) % LOG_BASE ];
                            x.e = -sd || 0;
                        } else {

                            // Zero.
                            xc[0] = x.e = 0;
                        }

                        return x;
                    }

                    // Remove excess digits.
                    if ( i == 0 ) {
                        xc.length = ni;
                        k = 1;
                        ni--;
                    } else {
                        xc.length = ni + 1;
                        k = pows10[ LOG_BASE - i ];

                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                        // j > 0 means i > number of leading zeros of n.
                        xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;
                    }

                    // Round up?
                    if (r) {

                        for ( ; ; ) {

                            // If the digit to be rounded up is in the first element of xc...
                            if ( ni == 0 ) {

                                // i will be the length of xc[0] before k is added.
                                for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );
                                j = xc[0] += k;
                                for ( k = 1; j >= 10; j /= 10, k++ );

                                // if i != k the length has increased.
                                if ( i != k ) {
                                    x.e++;
                                    if ( xc[0] == BASE ) xc[0] = 1;
                                }

                                break;
                            } else {
                                xc[ni] += k;
                                if ( xc[ni] != BASE ) break;
                                xc[ni--] = 0;
                                k = 1;
                            }
                        }
                    }

                    // Remove trailing zeros.
                    for ( i = xc.length; xc[--i] === 0; xc.pop() );
                }

                // Overflow? Infinity.
                if ( x.e > MAX_EXP ) {
                    x.c = x.e = null;

                // Underflow? Zero.
                } else if ( x.e < MIN_EXP ) {
                    x.c = [ x.e = 0 ];
                }
            }

            return x;
        }


        // PROTOTYPE/INSTANCE METHODS


        /*
         * Return a new BigNumber whose value is the absolute value of this BigNumber.
         */
        P.absoluteValue = P.abs = function () {
            var x = new BigNumber(this);
            if ( x.s < 0 ) x.s = 1;
            return x;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of Infinity.
         */
        P.ceil = function () {
            return round( new BigNumber(this), this.e + 1, 2 );
        };


        /*
         * Return
         * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
         * 0 if they have the same value,
         * or null if the value of either is NaN.
         */
        P.comparedTo = P.cmp = function ( y, b ) {
            id = 1;
            return compare( this, new BigNumber( y, b ) );
        };


        /*
         * Return the number of decimal places of the value of this BigNumber, or null if the value
         * of this BigNumber is Infinity or NaN.
         */
        P.decimalPlaces = P.dp = function () {
            var n, v,
                c = this.c;

            if ( !c ) return null;
            n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;

            // Subtract the number of trailing zeros of the last number.
            if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
            if ( n < 0 ) n = 0;

            return n;
        };


        /*
         *  n / 0 = I
         *  n / N = N
         *  n / I = 0
         *  0 / n = 0
         *  0 / 0 = N
         *  0 / N = N
         *  0 / I = 0
         *  N / n = N
         *  N / 0 = N
         *  N / N = N
         *  N / I = N
         *  I / n = I
         *  I / 0 = I
         *  I / N = N
         *  I / I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.dividedBy = P.div = function ( y, b ) {
            id = 3;
            return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
        };


        /*
         * Return a new BigNumber whose value is the integer part of dividing the value of this
         * BigNumber by the value of BigNumber(y, b).
         */
        P.dividedToIntegerBy = P.divToInt = function ( y, b ) {
            id = 4;
            return div( this, new BigNumber( y, b ), 0, 1 );
        };


        /*
         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.equals = P.eq = function ( y, b ) {
            id = 5;
            return compare( this, new BigNumber( y, b ) ) === 0;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of -Infinity.
         */
        P.floor = function () {
            return round( new BigNumber(this), this.e + 1, 3 );
        };


        /*
         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.greaterThan = P.gt = function ( y, b ) {
            id = 6;
            return compare( this, new BigNumber( y, b ) ) > 0;
        };


        /*
         * Return true if the value of this BigNumber is greater than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.greaterThanOrEqualTo = P.gte = function ( y, b ) {
            id = 7;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;

        };


        /*
         * Return true if the value of this BigNumber is a finite number, otherwise returns false.
         */
        P.isFinite = function () {
            return !!this.c;
        };


        /*
         * Return true if the value of this BigNumber is an integer, otherwise return false.
         */
        P.isInteger = P.isInt = function () {
            return !!this.c && bitFloor( this.e / LOG_BASE ) > this.c.length - 2;
        };


        /*
         * Return true if the value of this BigNumber is NaN, otherwise returns false.
         */
        P.isNaN = function () {
            return !this.s;
        };


        /*
         * Return true if the value of this BigNumber is negative, otherwise returns false.
         */
        P.isNegative = P.isNeg = function () {
            return this.s < 0;
        };


        /*
         * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.
         */
        P.isZero = function () {
            return !!this.c && this.c[0] == 0;
        };


        /*
         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.lessThan = P.lt = function ( y, b ) {
            id = 8;
            return compare( this, new BigNumber( y, b ) ) < 0;
        };


        /*
         * Return true if the value of this BigNumber is less than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.lessThanOrEqualTo = P.lte = function ( y, b ) {
            id = 9;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
        };


        /*
         *  n - 0 = n
         *  n - N = N
         *  n - I = -I
         *  0 - n = -n
         *  0 - 0 = 0
         *  0 - N = N
         *  0 - I = -I
         *  N - n = N
         *  N - 0 = N
         *  N - N = N
         *  N - I = N
         *  I - n = I
         *  I - 0 = I
         *  I - N = N
         *  I - I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
         * BigNumber(y, b).
         */
        P.minus = P.sub = function ( y, b ) {
            var i, j, t, xLTy,
                x = this,
                a = x.s;

            id = 10;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
            if ( a != b ) {
                y.s = -b;
                return x.plus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Either Infinity?
                if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );

                // Either zero?
                if ( !xc[0] || !yc[0] ) {

                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :

                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                      ROUNDING_MODE == 3 ? -0 : 0 );
                }
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Determine which is the bigger number.
            if ( a = xe - ye ) {

                if ( xLTy = a < 0 ) {
                    a = -a;
                    t = xc;
                } else {
                    ye = xe;
                    t = yc;
                }

                t.reverse();

                // Prepend zeros to equalise exponents.
                for ( b = a; b--; t.push(0) );
                t.reverse();
            } else {

                // Exponents equal. Check digit by digit.
                j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;

                for ( a = b = 0; b < j; b++ ) {

                    if ( xc[b] != yc[b] ) {
                        xLTy = xc[b] < yc[b];
                        break;
                    }
                }
            }

            // x < y? Point xc to the array of the bigger number.
            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

            b = ( j = yc.length ) - ( i = xc.length );

            // Append zeros to xc if shorter.
            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
            if ( b > 0 ) for ( ; b--; xc[i++] = 0 );
            b = BASE - 1;

            // Subtract yc from xc.
            for ( ; j > a; ) {

                if ( xc[--j] < yc[j] ) {
                    for ( i = j; i && !xc[--i]; xc[i] = b );
                    --xc[i];
                    xc[j] += BASE;
                }

                xc[j] -= yc[j];
            }

            // Remove leading zeros and adjust exponent accordingly.
            for ( ; xc[0] == 0; xc.shift(), --ye );

            // Zero?
            if ( !xc[0] ) {

                // Following IEEE 754 (2008) 6.3,
                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                y.c = [ y.e = 0 ];
                return y;
            }

            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
            // for finite x and y.
            return normalise( y, xc, ye );
        };


        /*
         *   n % 0 =  N
         *   n % N =  N
         *   n % I =  n
         *   0 % n =  0
         *  -0 % n = -0
         *   0 % 0 =  N
         *   0 % N =  N
         *   0 % I =  0
         *   N % n =  N
         *   N % 0 =  N
         *   N % N =  N
         *   N % I =  N
         *   I % n =  N
         *   I % 0 =  N
         *   I % N =  N
         *   I % I =  N
         *
         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
         */
        P.modulo = P.mod = function ( y, b ) {
            var q, s,
                x = this;

            id = 11;
            y = new BigNumber( y, b );

            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
            if ( !x.c || !y.s || y.c && !y.c[0] ) {
                return new BigNumber(NaN);

            // Return x if y is Infinity or x is zero.
            } else if ( !y.c || x.c && !x.c[0] ) {
                return new BigNumber(x);
            }

            if ( MODULO_MODE == 9 ) {

                // Euclidian division: q = sign(y) * floor(x / abs(y))
                // r = x - qy    where  0 <= r < abs(y)
                s = y.s;
                y.s = 1;
                q = div( x, y, 0, 3 );
                y.s = s;
                q.s *= s;
            } else {
                q = div( x, y, 0, MODULO_MODE );
            }

            return x.minus( q.times(y) );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber negated,
         * i.e. multiplied by -1.
         */
        P.negated = P.neg = function () {
            var x = new BigNumber(this);
            x.s = -x.s || null;
            return x;
        };


        /*
         *  n + 0 = n
         *  n + N = N
         *  n + I = I
         *  0 + n = n
         *  0 + 0 = 0
         *  0 + N = N
         *  0 + I = I
         *  N + n = N
         *  N + 0 = N
         *  N + N = N
         *  N + I = N
         *  I + n = I
         *  I + 0 = I
         *  I + N = N
         *  I + I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
         * BigNumber(y, b).
         */
        P.plus = P.add = function ( y, b ) {
            var t,
                x = this,
                a = x.s;

            id = 12;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
             if ( a != b ) {
                y.s = -b;
                return x.minus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Return Infinity if either Infinity.
                if ( !xc || !yc ) return new BigNumber( a / 0 );

                // Either zero?
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
            if ( a = xe - ye ) {
                if ( a > 0 ) {
                    ye = xe;
                    t = yc;
                } else {
                    a = -a;
                    t = xc;
                }

                t.reverse();
                for ( ; a--; t.push(0) );
                t.reverse();
            }

            a = xc.length;
            b = yc.length;

            // Point xc to the longer array, and b to the shorter length.
            if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;

            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
            for ( a = 0; b; ) {
                a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
                xc[b] %= BASE;
            }

            if (a) {
                xc.unshift(a);
                ++ye;
            }

            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
            // ye = MAX_EXP + 1 possible
            return normalise( y, xc, ye );
        };


        /*
         * Return the number of significant digits of the value of this BigNumber.
         *
         * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
         */
        P.precision = P.sd = function (z) {
            var n, v,
                x = this,
                c = x.c;

            // 'precision() argument not a boolean or binary digit: {z}'
            if ( z != null && z !== !!z && z !== 1 && z !== 0 ) {
                if (ERRORS) raise( 13, 'argument' + notBool, z );
                if ( z != !!z ) z = null;
            }

            if ( !c ) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;

            if ( v = c[v] ) {

                // Subtract the number of trailing zeros of the last element.
                for ( ; v % 10 == 0; v /= 10, n-- );

                // Add the number of digits of the first element.
                for ( v = c[0]; v >= 10; v /= 10, n++ );
            }

            if ( z && x.e + 1 > n ) n = x.e + 1;

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * dp decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if
         * omitted.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'round() decimal places out of range: {dp}'
         * 'round() decimal places not an integer: {dp}'
         * 'round() rounding mode not an integer: {rm}'
         * 'round() rounding mode out of range: {rm}'
         */
        P.round = function ( dp, rm ) {
            var n = new BigNumber(this);

            if ( dp == null || isValidInt( dp, 0, MAX, 15 ) ) {
                round( n, ~~dp + this.e + 1, rm == null ||
                  !isValidInt( rm, 0, 8, 15, roundingMode ) ? ROUNDING_MODE : rm | 0 );
            }

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
         *
         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         *
         * If k is out of range and ERRORS is false, the result will be 0 if k < 0, or Infinity
         * otherwise.
         *
         * 'shift() argument not an integer: {k}'
         * 'shift() argument out of range: {k}'
         */
        P.shift = function (k) {
            var n = this;
            return isValidInt( k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument' )

              // k < 1e+21, or truncate(k) will produce exponential notation.
              ? n.times( '1e' + truncate(k) )
              : new BigNumber( n.c && n.c[0] && ( k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER )
                ? n.s * ( k < 0 ? 0 : 1 / 0 )
                : n );
        };


        /*
         *  sqrt(-n) =  N
         *  sqrt( N) =  N
         *  sqrt(-I) =  N
         *  sqrt( I) =  I
         *  sqrt( 0) =  0
         *  sqrt(-0) = -0
         *
         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.squareRoot = P.sqrt = function () {
            var m, n, r, rep, t,
                x = this,
                c = x.c,
                s = x.s,
                e = x.e,
                dp = DECIMAL_PLACES + 4,
                half = new BigNumber('0.5');

            // Negative/NaN/Infinity/zero?
            if ( s !== 1 || !c || !c[0] ) {
                return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
            }

            // Initial estimate.
            s = Math.sqrt( +x );

            // Math.sqrt underflow/overflow?
            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
            if ( s == 0 || s == 1 / 0 ) {
                n = coeffToString(c);
                if ( ( n.length + e ) % 2 == 0 ) n += '0';
                s = Math.sqrt(n);
                e = bitFloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );

                if ( s == 1 / 0 ) {
                    n = '1e' + e;
                } else {
                    n = s.toExponential();
                    n = n.slice( 0, n.indexOf('e') + 1 ) + e;
                }

                r = new BigNumber(n);
            } else {
                r = new BigNumber( s + '' );
            }

            // Check for zero.
            // r could be zero if MIN_EXP is changed after the this value was created.
            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
            // coeffToString to throw.
            if ( r.c[0] ) {
                e = r.e;
                s = e + dp;
                if ( s < 3 ) s = 0;

                // Newton-Raphson iteration.
                for ( ; ; ) {
                    t = r;
                    r = half.times( t.plus( div( x, t, dp, 1 ) ) );

                    if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
                         coeffToString( r.c ) ).slice( 0, s ) ) {

                        // The exponent of r may here be one less than the final result exponent,
                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                        // are indexed correctly.
                        if ( r.e < e ) --s;
                        n = n.slice( s - 3, s + 1 );

                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                        // iteration.
                        if ( n == '9999' || !rep && n == '4999' ) {

                            // On the first iteration only, check to see if rounding up gives the
                            // exact result as the nines may infinitely repeat.
                            if ( !rep ) {
                                round( t, t.e + DECIMAL_PLACES + 2, 0 );

                                if ( t.times(t).eq(x) ) {
                                    r = t;
                                    break;
                                }
                            }

                            dp += 4;
                            s += 4;
                            rep = 1;
                        } else {

                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                            // result. If not, then there are further digits and m will be truthy.
                            if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {

                                // Truncate to the first rounding digit.
                                round( r, r.e + DECIMAL_PLACES + 2, 1 );
                                m = !r.times(r).eq(x);
                            }

                            break;
                        }
                    }
                }
            }

            return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
        };


        /*
         *  n * 0 = 0
         *  n * N = N
         *  n * I = I
         *  0 * n = 0
         *  0 * 0 = 0
         *  0 * N = N
         *  0 * I = N
         *  N * n = N
         *  N * 0 = N
         *  N * N = N
         *  N * I = N
         *  I * n = I
         *  I * 0 = N
         *  I * N = N
         *  I * I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber times the value of
         * BigNumber(y, b).
         */
        P.times = P.mul = function ( y, b ) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                base, sqrtBase,
                x = this,
                xc = x.c,
                yc = ( id = 17, y = new BigNumber( y, b ) ).c;

            // Either NaN, Infinity or 0?
            if ( !xc || !yc || !xc[0] || !yc[0] ) {

                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                if ( !x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc ) {
                    y.c = y.e = y.s = null;
                } else {
                    y.s *= x.s;

                    // Return Infinity if either is Infinity.
                    if ( !xc || !yc ) {
                        y.c = y.e = null;

                    // Return 0 if either is 0.
                    } else {
                        y.c = [0];
                        y.e = 0;
                    }
                }

                return y;
            }

            e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;

            // Ensure xc points to longer array and xcL to its length.
            if ( xcL < ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

            // Initialise the result array with zeros.
            for ( i = xcL + ycL, zc = []; i--; zc.push(0) );

            base = BASE;
            sqrtBase = SQRT_BASE;

            for ( i = ycL; --i >= 0; ) {
                c = 0;
                ylo = yc[i] % sqrtBase;
                yhi = yc[i] / sqrtBase | 0;

                for ( k = xcL, j = i + k; j > i; ) {
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
                    c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
                    zc[j--] = xlo % base;
                }

                zc[j] = c;
            }

            if (c) {
                ++e;
            } else {
                zc.shift();
            }

            return normalise( y, zc, e );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * sd significant digits using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toDigits() precision out of range: {sd}'
         * 'toDigits() precision not an integer: {sd}'
         * 'toDigits() rounding mode not an integer: {rm}'
         * 'toDigits() rounding mode out of range: {rm}'
         */
        P.toDigits = function ( sd, rm ) {
            var n = new BigNumber(this);
            sd = sd == null || !isValidInt( sd, 1, MAX, 18, 'precision' ) ? null : sd | 0;
            rm = rm == null || !isValidInt( rm, 0, 8, 18, roundingMode ) ? ROUNDING_MODE : rm | 0;
            return sd ? round( n, sd, rm ) : n;
        };


        /*
         * Return a string representing the value of this BigNumber in exponential notation and
         * rounded using ROUNDING_MODE to dp fixed decimal places.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toExponential() decimal places not an integer: {dp}'
         * 'toExponential() decimal places out of range: {dp}'
         * 'toExponential() rounding mode not an integer: {rm}'
         * 'toExponential() rounding mode out of range: {rm}'
         */
        P.toExponential = function ( dp, rm ) {
            return format( this,
              dp != null && isValidInt( dp, 0, MAX, 19 ) ? ~~dp + 1 : null, rm, 19 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounding
         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
         * but e.g. (-0.00001).toFixed(0) is '-0'.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFixed() decimal places not an integer: {dp}'
         * 'toFixed() decimal places out of range: {dp}'
         * 'toFixed() rounding mode not an integer: {rm}'
         * 'toFixed() rounding mode out of range: {rm}'
         */
        P.toFixed = function ( dp, rm ) {
            return format( this, dp != null && isValidInt( dp, 0, MAX, 20 )
              ? ~~dp + this.e + 1 : null, rm, 20 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounded
         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
         * of the FORMAT object (see BigNumber.config).
         *
         * FORMAT = {
         *      decimalSeparator : '.',
         *      groupSeparator : ',',
         *      groupSize : 3,
         *      secondaryGroupSize : 0,
         *      fractionGroupSeparator : '\xA0',    // non-breaking space
         *      fractionGroupSize : 0
         * };
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFormat() decimal places not an integer: {dp}'
         * 'toFormat() decimal places out of range: {dp}'
         * 'toFormat() rounding mode not an integer: {rm}'
         * 'toFormat() rounding mode out of range: {rm}'
         */
        P.toFormat = function ( dp, rm ) {
            var str = format( this, dp != null && isValidInt( dp, 0, MAX, 21 )
              ? ~~dp + this.e + 1 : null, rm, 21 );

            if ( this.c ) {
                var i,
                    arr = str.split('.'),
                    g1 = +FORMAT.groupSize,
                    g2 = +FORMAT.secondaryGroupSize,
                    groupSeparator = FORMAT.groupSeparator,
                    intPart = arr[0],
                    fractionPart = arr[1],
                    isNeg = this.s < 0,
                    intDigits = isNeg ? intPart.slice(1) : intPart,
                    len = intDigits.length;

                if (g2) i = g1, g1 = g2, g2 = i, len -= i;

                if ( g1 > 0 && len > 0 ) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr( 0, i );

                    for ( ; i < len; i += g1 ) {
                        intPart += groupSeparator + intDigits.substr( i, g1 );
                    }

                    if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                }

                str = fractionPart
                  ? intPart + FORMAT.decimalSeparator + ( ( g2 = +FORMAT.fractionGroupSize )
                    ? fractionPart.replace( new RegExp( '\\d{' + g2 + '}\\B', 'g' ),
                      '$&' + FORMAT.fractionGroupSeparator )
                    : fractionPart )
                  : intPart;
            }

            return str;
        };


        /*
         * Return a string array representing the value of this BigNumber as a simple fraction with
         * an integer numerator and an integer denominator. The denominator will be a positive
         * non-zero value less than or equal to the specified maximum denominator. If a maximum
         * denominator is not specified, the denominator will be the lowest value necessary to
         * represent the number exactly.
         *
         * [md] {number|string|BigNumber} Integer >= 1 and < Infinity. The maximum denominator.
         *
         * 'toFraction() max denominator not an integer: {md}'
         * 'toFraction() max denominator out of range: {md}'
         */
        P.toFraction = function (md) {
            var arr, d0, d2, e, exp, n, n0, q, s,
                k = ERRORS,
                x = this,
                xc = x.c,
                d = new BigNumber(ONE),
                n1 = d0 = new BigNumber(ONE),
                d1 = n0 = new BigNumber(ONE);

            if ( md != null ) {
                ERRORS = false;
                n = new BigNumber(md);
                ERRORS = k;

                if ( !( k = n.isInt() ) || n.lt(ONE) ) {

                    if (ERRORS) {
                        raise( 22,
                          'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
                    }

                    // ERRORS is false:
                    // If md is a finite non-integer >= 1, round it to an integer and use it.
                    md = !k && n.c && round( n, n.e + 1, 1 ).gte(ONE) ? n : null;
                }
            }

            if ( !xc ) return x.toString();
            s = coeffToString(xc);

            // Determine initial denominator.
            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];
            md = !md || n.cmp(d) > 0 ? ( e > 0 ? d : n1 ) : n;

            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber(s);

            // n0 = d1 = 0
            n0.c[0] = 0;

            for ( ; ; )  {
                q = div( n, d, 0, 1 );
                d2 = d0.plus( q.times(d1) );
                if ( d2.cmp(md) == 1 ) break;
                d0 = d1;
                d1 = d2;
                n1 = n0.plus( q.times( d2 = n1 ) );
                n0 = d2;
                d = n.minus( q.times( d2 = d ) );
                n = d2;
            }

            d2 = div( md.minus(d0), d1, 0, 1 );
            n0 = n0.plus( d2.times(n1) );
            d0 = d0.plus( d2.times(d1) );
            n0.s = n1.s = x.s;
            e *= 2;

            // Determine which fraction is closer to x, n0/d0 or n1/d1
            arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).abs().cmp(
                  div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) < 1
                    ? [ n1.toString(), d1.toString() ]
                    : [ n0.toString(), d0.toString() ];

            MAX_EXP = exp;
            return arr;
        };


        /*
         * Return the value of this BigNumber converted to a number primitive.
         */
        P.toNumber = function () {
            return +this;
        };


        /*
         * Return a BigNumber whose value is the value of this BigNumber raised to the power n.
         * If m is present, return the result modulo m.
         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
         * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using
         * ROUNDING_MODE.
         *
         * The modular power operation works efficiently when x, n, and m are positive integers,
         * otherwise it is equivalent to calculating x.toPower(n).modulo(m) (with POW_PRECISION 0).
         *
         * n {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         * [m] {number|string|BigNumber} The modulus.
         *
         * 'pow() exponent not an integer: {n}'
         * 'pow() exponent out of range: {n}'
         *
         * Performs 54 loop iterations for n of 9007199254740991.
         */
        P.toPower = P.pow = function ( n, m ) {
            var k, y, z,
                i = mathfloor( n < 0 ? -n : +n ),
                x = this;

            if ( m != null ) {
                id = 23;
                m = new BigNumber(m);
            }

            // Pass Infinity to Math.pow if exponent is out of range.
            if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &&
              ( !isFinite(n) || i > MAX_SAFE_INTEGER && ( n /= 0 ) ||
                parseFloat(n) != n && !( n = NaN ) ) || n == 0 ) {
                k = Math.pow( +x, n );
                return new BigNumber( m ? k % m : k );
            }

            if (m) {
                if ( n > 1 && x.gt(ONE) && x.isInt() && m.gt(ONE) && m.isInt() ) {
                    x = x.mod(m);
                } else {
                    z = m;

                    // Nullify m so only a single mod operation is performed at the end.
                    m = null;
                }
            } else if (POW_PRECISION) {

                // Truncating each coefficient array to a length of k after each multiplication
                // equates to truncating significant digits to POW_PRECISION + [28, 41],
                // i.e. there will be a minimum of 28 guard digits retained.
                // (Using + 1.5 would give [9, 21] guard digits.)
                k = mathceil( POW_PRECISION / LOG_BASE + 2 );
            }

            y = new BigNumber(ONE);

            for ( ; ; ) {
                if ( i % 2 ) {
                    y = y.times(x);
                    if ( !y.c ) break;
                    if (k) {
                        if ( y.c.length > k ) y.c.length = k;
                    } else if (m) {
                        y = y.mod(m);
                    }
                }

                i = mathfloor( i / 2 );
                if ( !i ) break;
                x = x.times(x);
                if (k) {
                    if ( x.c && x.c.length > k ) x.c.length = k;
                } else if (m) {
                    x = x.mod(m);
                }
            }

            if (m) return y;
            if ( n < 0 ) y = ONE.div(y);

            return z ? y.mod(z) : k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
        };


        /*
         * Return a string representing the value of this BigNumber rounded to sd significant digits
         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
         * necessary to represent the integer part of the value in fixed-point notation, then use
         * exponential notation.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toPrecision() precision not an integer: {sd}'
         * 'toPrecision() precision out of range: {sd}'
         * 'toPrecision() rounding mode not an integer: {rm}'
         * 'toPrecision() rounding mode out of range: {rm}'
         */
        P.toPrecision = function ( sd, rm ) {
            return format( this, sd != null && isValidInt( sd, 1, MAX, 24, 'precision' )
              ? sd | 0 : null, rm, 24 );
        };


        /*
         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
         * TO_EXP_NEG, return exponential notation.
         *
         * [b] {number} Integer, 2 to 64 inclusive.
         *
         * 'toString() base not an integer: {b}'
         * 'toString() base out of range: {b}'
         */
        P.toString = function (b) {
            var str,
                n = this,
                s = n.s,
                e = n.e;

            // Infinity or NaN?
            if ( e === null ) {

                if (s) {
                    str = 'Infinity';
                    if ( s < 0 ) str = '-' + str;
                } else {
                    str = 'NaN';
                }
            } else {
                str = coeffToString( n.c );

                if ( b == null || !isValidInt( b, 2, 64, 25, 'base' ) ) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                      ? toExponential( str, e )
                      : toFixedPoint( str, e );
                } else {
                    str = convertBase( toFixedPoint( str, e ), b | 0, 10, s );
                }

                if ( s < 0 && n.c[0] ) str = '-' + str;
            }

            return str;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber truncated to a whole
         * number.
         */
        P.truncated = P.trunc = function () {
            return round( new BigNumber(this), this.e + 1, 1 );
        };



        /*
         * Return as toString, but do not accept a base argument, and include the minus sign for
         * negative zero.
         */
        P.valueOf = P.toJSON = function () {
            var str,
                n = this,
                e = n.e;

            if ( e === null ) return n.toString();

            str = coeffToString( n.c );

            str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                ? toExponential( str, e )
                : toFixedPoint( str, e );

            return n.s < 0 ? '-' + str : str;
        };


        // Aliases for BigDecimal methods.
        //P.add = P.plus;         // P.add included above
        //P.subtract = P.minus;   // P.sub included above
        //P.multiply = P.times;   // P.mul included above
        //P.divide = P.div;
        //P.remainder = P.mod;
        //P.compareTo = P.cmp;
        //P.negate = P.neg;


        if ( configObj != null ) BigNumber.config(configObj);

        return BigNumber;
    }


    // PRIVATE HELPER FUNCTIONS


    function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
    }


    // Return a coefficient array as a string of base 10 digits.
    function coeffToString(a) {
        var s, z,
            i = 1,
            j = a.length,
            r = a[0] + '';

        for ( ; i < j; ) {
            s = a[i++] + '';
            z = LOG_BASE - s.length;
            for ( ; z--; s = '0' + s );
            r += s;
        }

        // Determine trailing zeros.
        for ( j = r.length; r.charCodeAt(--j) === 48; );
        return r.slice( 0, j + 1 || 1 );
    }


    // Compare the value of BigNumbers x and y.
    function compare( x, y ) {
        var a, b,
            xc = x.c,
            yc = y.c,
            i = x.s,
            j = y.s,
            k = x.e,
            l = y.e;

        // Either NaN?
        if ( !i || !j ) return null;

        a = xc && !xc[0];
        b = yc && !yc[0];

        // Either zero?
        if ( a || b ) return a ? b ? 0 : -j : i;

        // Signs differ?
        if ( i != j ) return i;

        a = i < 0;
        b = k == l;

        // Either Infinity?
        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;

        // Compare exponents.
        if ( !b ) return k > l ^ a ? 1 : -1;

        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;

        // Compare digit by digit.
        for ( i = 0; i < j; i++ ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;

        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    }


    /*
     * Return true if n is a valid number in range, otherwise false.
     * Use for argument validation when ERRORS is false.
     * Note: parseInt('1e+1') == 1 but parseFloat('1e+1') == 10.
     */
    function intValidatorNoErrors( n, min, max ) {
        return ( n = truncate(n) ) >= min && n <= max;
    }


    function isArray(obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
    }


    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. convertBase('255', 10, 16) returns [15, 15].
     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut( str, baseIn, baseOut ) {
        var j,
            arr = [0],
            arrL,
            i = 0,
            len = str.length;

        for ( ; i < len; ) {
            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );
            arr[ j = 0 ] += ALPHABET.indexOf( str.charAt( i++ ) );

            for ( ; j < arr.length; j++ ) {

                if ( arr[j] > baseOut - 1 ) {
                    if ( arr[j + 1] == null ) arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                }
            }
        }

        return arr.reverse();
    }


    function toExponential( str, e ) {
        return ( str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str ) +
          ( e < 0 ? 'e' : 'e+' ) + e;
    }


    function toFixedPoint( str, e ) {
        var len, z;

        // Negative exponent?
        if ( e < 0 ) {

            // Prepend zeros.
            for ( z = '0.'; ++e; z += '0' );
            str = z + str;

        // Positive exponent
        } else {
            len = str.length;

            // Append zeros.
            if ( ++e > len ) {
                for ( z = '0', e -= len; --e; z += '0' );
                str += z;
            } else if ( e < len ) {
                str = str.slice( 0, e ) + '.' + str.slice(e);
            }
        }

        return str;
    }


    function truncate(n) {
        n = parseFloat(n);
        return n < 0 ? mathceil(n) : mathfloor(n);
    }


    // EXPORT


   // AMD.
    if ( typeof define == 'function' && define.amd ) {
        define( function () { return constructorFactory(); } );

    // Node.js and other environments that support module.exports.
    } else if ( typeof module != 'undefined' && module.exports ) {
        module.exports = constructorFactory();

        // Split string stops browserify adding crypto shim.
        if ( !cryptoObj ) try { cryptoObj = require('cry' + 'pto'); } catch (e) {}

    // Browser.
    } else {
        if ( !globalObj ) globalObj = typeof self != 'undefined' ? self : Function('return this')();
        globalObj.BigNumber = constructorFactory();
    }
})(this);

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js":[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/base64-js/index.js","ieee754":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/ieee754/index.js","isarray":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/isarray/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/charenc/charenc.js":[function(require,module,exports){
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/es6/set.js":[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
module.exports = require('../modules/_core').Set;
},{"../modules/_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","../modules/es6.object.to-string":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.object.to-string.js","../modules/es6.set":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.set.js","../modules/es6.string.iterator":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.string.iterator.js","../modules/web.dom.iterable":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/web.dom.iterable.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/es6/symbol.js":[function(require,module,exports){
require('../modules/es6.symbol');
require('../modules/es6.object.to-string');
module.exports = require('../modules/_core').Symbol;
},{"../modules/_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","../modules/es6.object.to-string":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.object.to-string.js","../modules/es6.symbol":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.symbol.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/array/find-index.js":[function(require,module,exports){
require('../../modules/es6.array.find-index');
module.exports = require('../../modules/_core').Array.findIndex;
},{"../../modules/_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","../../modules/es6.array.find-index":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.array.find-index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/array/find.js":[function(require,module,exports){
require('../../modules/es6.array.find');
module.exports = require('../../modules/_core').Array.find;
},{"../../modules/_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","../../modules/es6.array.find":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.array.find.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/array/from.js":[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;
},{"../../modules/_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","../../modules/es6.array.from":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.array.from.js","../../modules/es6.string.iterator":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.string.iterator.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/array/of.js":[function(require,module,exports){
require('../../modules/es6.array.of');
module.exports = require('../../modules/_core').Array.of;
},{"../../modules/_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","../../modules/es6.array.of":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.array.of.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/object/is.js":[function(require,module,exports){
require('../../modules/es6.object.is');
module.exports = require('../../modules/_core').Object.is;
},{"../../modules/_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","../../modules/es6.object.is":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.object.is.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/string/includes.js":[function(require,module,exports){
require('../../modules/es6.string.includes');
module.exports = require('../../modules/_core').String.includes;
},{"../../modules/_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","../../modules/es6.string.includes":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.string.includes.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/fn/symbol/iterator.js":[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');
},{"../../modules/_wks-ext":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks-ext.js","../../modules/es6.string.iterator":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.string.iterator.js","../../modules/web.dom.iterable":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/web.dom.iterable.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_a-function.js":[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_add-to-unscopables.js":[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};
},{"./_hide":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_hide.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_an-instance.js":[function(require,module,exports){
module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_an-object.js":[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-object.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_array-includes.js":[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-index.js","./_to-iobject":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-iobject.js","./_to-length":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-length.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_array-methods.js":[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_array-species-create.js","./_ctx":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_ctx.js","./_iobject":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iobject.js","./_to-length":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-length.js","./_to-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-object.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_array-species-constructor.js":[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-array.js","./_is-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-object.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_array-species-create.js":[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_array-species-constructor.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_classof.js":[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof')
  , TAG = require('./_wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./_cof":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_cof.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_cof.js":[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_collection-strong.js":[function(require,module,exports){
'use strict';
var dP          = require('./_object-dp').f
  , create      = require('./_object-create')
  , redefineAll = require('./_redefine-all')
  , ctx         = require('./_ctx')
  , anInstance  = require('./_an-instance')
  , defined     = require('./_defined')
  , forOf       = require('./_for-of')
  , $iterDefine = require('./_iter-define')
  , step        = require('./_iter-step')
  , setSpecies  = require('./_set-species')
  , DESCRIPTORS = require('./_descriptors')
  , fastKey     = require('./_meta').fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./_an-instance":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_an-instance.js","./_ctx":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_ctx.js","./_defined":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_defined.js","./_descriptors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_descriptors.js","./_for-of":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_for-of.js","./_iter-define":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-define.js","./_iter-step":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-step.js","./_meta":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_meta.js","./_object-create":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-create.js","./_object-dp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dp.js","./_redefine-all":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_redefine-all.js","./_set-species":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_set-species.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_collection.js":[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , $export           = require('./_export')
  , redefine          = require('./_redefine')
  , redefineAll       = require('./_redefine-all')
  , meta              = require('./_meta')
  , forOf             = require('./_for-of')
  , anInstance        = require('./_an-instance')
  , isObject          = require('./_is-object')
  , fails             = require('./_fails')
  , $iterDetect       = require('./_iter-detect')
  , setToStringTag    = require('./_set-to-string-tag')
  , inheritIfRequired = require('./_inherit-if-required');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  var fixMethod = function(KEY){
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a){
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance             = new C
      // early implementations not supports chaining
      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
      // most early implementations doesn't supports iterables, most modern - not close it correctly
      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
      // for early implementations -0 and +0 not the same
      , BUGGY_ZERO = !IS_WEAK && fails(function(){
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new C()
          , index     = 5;
        while(index--)$instance[ADDER](index, index);
        return !$instance.has(-0);
      });
    if(!ACCEPT_ITERABLES){ 
      C = wrapper(function(target, iterable){
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base, target, C);
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
    // weak collections should not contains .clear method
    if(IS_WEAK && proto.clear)delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./_an-instance":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_an-instance.js","./_export":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_export.js","./_fails":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_fails.js","./_for-of":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_for-of.js","./_global":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js","./_inherit-if-required":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_inherit-if-required.js","./_is-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-object.js","./_iter-detect":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-detect.js","./_meta":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_meta.js","./_redefine":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_redefine.js","./_redefine-all":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_redefine-all.js","./_set-to-string-tag":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_set-to-string-tag.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js":[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_create-property.js":[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp')
  , createDesc      = require('./_property-desc');

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};
},{"./_object-dp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dp.js","./_property-desc":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_property-desc.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_ctx.js":[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_a-function.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_defined.js":[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_descriptors.js":[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_fails.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_dom-create.js":[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js","./_is-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-object.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_enum-bug-keys.js":[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_enum-keys.js":[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys')
  , gOPS    = require('./_object-gops')
  , pIE     = require('./_object-pie');
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};
},{"./_object-gops":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gops.js","./_object-keys":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-keys.js","./_object-pie":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-pie.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_export.js":[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , hide      = require('./_hide')
  , redefine  = require('./_redefine')
  , ctx       = require('./_ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","./_ctx":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_ctx.js","./_global":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js","./_hide":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_hide.js","./_redefine":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_redefine.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_fails-is-regexp.js":[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function(KEY){
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch(e){
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch(f){ /* empty */ }
  } return true;
};
},{"./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_fails.js":[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_for-of.js":[function(require,module,exports){
var ctx         = require('./_ctx')
  , call        = require('./_iter-call')
  , isArrayIter = require('./_is-array-iter')
  , anObject    = require('./_an-object')
  , toLength    = require('./_to-length')
  , getIterFn   = require('./core.get-iterator-method')
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;
},{"./_an-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_an-object.js","./_ctx":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_ctx.js","./_is-array-iter":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-array-iter.js","./_iter-call":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-call.js","./_to-length":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-length.js","./core.get-iterator-method":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/core.get-iterator-method.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js":[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_has.js":[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_hide.js":[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_descriptors.js","./_object-dp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dp.js","./_property-desc":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_property-desc.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_html.js":[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_ie8-dom-define.js":[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_descriptors.js","./_dom-create":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_dom-create.js","./_fails":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_fails.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_inherit-if-required.js":[function(require,module,exports){
var isObject       = require('./_is-object')
  , setPrototypeOf = require('./_set-proto').set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};
},{"./_is-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-object.js","./_set-proto":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_set-proto.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iobject.js":[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_cof.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-array-iter.js":[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./_iterators')
  , ITERATOR   = require('./_wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./_iterators":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iterators.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-array.js":[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_cof.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-object.js":[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-regexp.js":[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object')
  , cof      = require('./_cof')
  , MATCH    = require('./_wks')('match');
module.exports = function(it){
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};
},{"./_cof":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_cof.js","./_is-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-object.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-call.js":[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./_an-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_an-object.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-create.js":[function(require,module,exports){
'use strict';
var create         = require('./_object-create')
  , descriptor     = require('./_property-desc')
  , setToStringTag = require('./_set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./_hide":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_hide.js","./_object-create":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-create.js","./_property-desc":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_property-desc.js","./_set-to-string-tag":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_set-to-string-tag.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-define.js":[function(require,module,exports){
'use strict';
var LIBRARY        = require('./_library')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , hide           = require('./_hide')
  , has            = require('./_has')
  , Iterators      = require('./_iterators')
  , $iterCreate    = require('./_iter-create')
  , setToStringTag = require('./_set-to-string-tag')
  , getPrototypeOf = require('./_object-gpo')
  , ITERATOR       = require('./_wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./_export":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_export.js","./_has":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_has.js","./_hide":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_hide.js","./_iter-create":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-create.js","./_iterators":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iterators.js","./_library":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_library.js","./_object-gpo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gpo.js","./_redefine":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_redefine.js","./_set-to-string-tag":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_set-to-string-tag.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-detect.js":[function(require,module,exports){
var ITERATOR     = require('./_wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-step.js":[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iterators.js":[function(require,module,exports){
module.exports = {};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_keyof.js":[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./_object-keys":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-keys.js","./_to-iobject":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-iobject.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_library.js":[function(require,module,exports){
module.exports = false;
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_meta.js":[function(require,module,exports){
var META     = require('./_uid')('meta')
  , isObject = require('./_is-object')
  , has      = require('./_has')
  , setDesc  = require('./_object-dp').f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !require('./_fails')(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
},{"./_fails":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_fails.js","./_has":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_has.js","./_is-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-object.js","./_object-dp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dp.js","./_uid":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_uid.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-create.js":[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_an-object.js","./_dom-create":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_dom-create.js","./_enum-bug-keys":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_enum-bug-keys.js","./_html":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_html.js","./_object-dps":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dps.js","./_shared-key":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_shared-key.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dp.js":[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_an-object.js","./_descriptors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_descriptors.js","./_ie8-dom-define":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_ie8-dom-define.js","./_to-primitive":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-primitive.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dps.js":[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_an-object.js","./_descriptors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_descriptors.js","./_object-dp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dp.js","./_object-keys":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-keys.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gopd.js":[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_descriptors.js","./_has":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_has.js","./_ie8-dom-define":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_ie8-dom-define.js","./_object-pie":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-pie.js","./_property-desc":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_property-desc.js","./_to-iobject":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-primitive.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gopn-ext.js":[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject')
  , gOPN      = require('./_object-gopn').f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gopn.js","./_to-iobject":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-iobject.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gopn.js":[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_enum-bug-keys.js","./_object-keys-internal":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-keys-internal.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gops.js":[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gpo.js":[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = require('./_has')
  , toObject    = require('./_to-object')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};
},{"./_has":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_has.js","./_shared-key":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_shared-key.js","./_to-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-object.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-keys-internal.js":[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_array-includes.js","./_has":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_has.js","./_shared-key":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_shared-key.js","./_to-iobject":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-iobject.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-keys.js":[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_enum-bug-keys.js","./_object-keys-internal":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-keys-internal.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-pie.js":[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_property-desc.js":[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_redefine-all.js":[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function(target, src, safe){
  for(var key in src)redefine(target, key, src[key], safe);
  return target;
};
},{"./_redefine":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_redefine.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_redefine.js":[function(require,module,exports){
var global    = require('./_global')
  , hide      = require('./_hide')
  , has       = require('./_has')
  , SRC       = require('./_uid')('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
},{"./_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","./_global":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js","./_has":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_has.js","./_hide":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_hide.js","./_uid":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_uid.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_same-value.js":[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_set-proto.js":[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_an-object.js","./_ctx":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_ctx.js","./_is-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-object.js","./_object-gopd":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gopd.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_set-species.js":[function(require,module,exports){
'use strict';
var global      = require('./_global')
  , dP          = require('./_object-dp')
  , DESCRIPTORS = require('./_descriptors')
  , SPECIES     = require('./_wks')('species');

module.exports = function(KEY){
  var C = global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./_descriptors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_descriptors.js","./_global":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js","./_object-dp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dp.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_set-to-string-tag.js":[function(require,module,exports){
var def = require('./_object-dp').f
  , has = require('./_has')
  , TAG = require('./_wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./_has":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_has.js","./_object-dp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dp.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_shared-key.js":[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_shared.js","./_uid":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_uid.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_shared.js":[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_string-at.js":[function(require,module,exports){
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./_defined":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_defined.js","./_to-integer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-integer.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_string-context.js":[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp')
  , defined  = require('./_defined');

module.exports = function(that, searchString, NAME){
  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};
},{"./_defined":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_defined.js","./_is-regexp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-regexp.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-index.js":[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-integer.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-integer.js":[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-iobject.js":[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_defined.js","./_iobject":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iobject.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-length.js":[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-integer.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-object.js":[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_defined.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-primitive.js":[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-object.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_uid.js":[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks-define.js":[function(require,module,exports){
var global         = require('./_global')
  , core           = require('./_core')
  , LIBRARY        = require('./_library')
  , wksExt         = require('./_wks-ext')
  , defineProperty = require('./_object-dp').f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};
},{"./_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","./_global":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js","./_library":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_library.js","./_object-dp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dp.js","./_wks-ext":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks-ext.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks-ext.js":[function(require,module,exports){
exports.f = require('./_wks');
},{"./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js":[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js","./_shared":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_shared.js","./_uid":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_uid.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/core.get-iterator-method.js":[function(require,module,exports){
var classof   = require('./_classof')
  , ITERATOR  = require('./_wks')('iterator')
  , Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./_classof":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_classof.js","./_core":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_core.js","./_iterators":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iterators.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.array.find-index.js":[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(6)
  , KEY     = 'findIndex'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_add-to-unscopables.js","./_array-methods":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_array-methods.js","./_export":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_export.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.array.find.js":[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_add-to-unscopables.js","./_array-methods":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_array-methods.js","./_export":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_export.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.array.from.js":[function(require,module,exports){
'use strict';
var ctx            = require('./_ctx')
  , $export        = require('./_export')
  , toObject       = require('./_to-object')
  , call           = require('./_iter-call')
  , isArrayIter    = require('./_is-array-iter')
  , toLength       = require('./_to-length')
  , createProperty = require('./_create-property')
  , getIterFn      = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_create-property.js","./_ctx":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_ctx.js","./_export":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_export.js","./_is-array-iter":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-array-iter.js","./_iter-call":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-call.js","./_iter-detect":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-detect.js","./_to-length":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-length.js","./_to-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-object.js","./core.get-iterator-method":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/core.get-iterator-method.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.array.iterator.js":[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables')
  , step             = require('./_iter-step')
  , Iterators        = require('./_iterators')
  , toIObject        = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./_add-to-unscopables":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_add-to-unscopables.js","./_iter-define":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-define.js","./_iter-step":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-step.js","./_iterators":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iterators.js","./_to-iobject":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-iobject.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.array.of.js":[function(require,module,exports){
'use strict';
var $export        = require('./_export')
  , createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function(){
  function F(){}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , aLen   = arguments.length
      , result = new (typeof this == 'function' ? this : Array)(aLen);
    while(aLen > index)createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});
},{"./_create-property":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_create-property.js","./_export":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_export.js","./_fails":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_fails.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.object.is.js":[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', {is: require('./_same-value')});
},{"./_export":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_export.js","./_same-value":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_same-value.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.object.to-string.js":[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof')
  , test    = {};
test[require('./_wks')('toStringTag')] = 'z';
if(test + '' != '[object z]'){
  require('./_redefine')(Object.prototype, 'toString', function toString(){
    return '[object ' + classof(this) + ']';
  }, true);
}
},{"./_classof":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_classof.js","./_redefine":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_redefine.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.set.js":[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.2 Set Objects
module.exports = require('./_collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./_collection":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_collection.js","./_collection-strong":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_collection-strong.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.string.includes.js":[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export  = require('./_export')
  , context  = require('./_string-context')
  , INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /*, position = 0 */){
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});
},{"./_export":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_export.js","./_fails-is-regexp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_fails-is-regexp.js","./_string-context":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_string-context.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.string.iterator.js":[function(require,module,exports){
'use strict';
var $at  = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./_iter-define":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iter-define.js","./_string-at":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_string-at.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.symbol.js":[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global         = require('./_global')
  , has            = require('./_has')
  , DESCRIPTORS    = require('./_descriptors')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , META           = require('./_meta').KEY
  , $fails         = require('./_fails')
  , shared         = require('./_shared')
  , setToStringTag = require('./_set-to-string-tag')
  , uid            = require('./_uid')
  , wks            = require('./_wks')
  , wksExt         = require('./_wks-ext')
  , wksDefine      = require('./_wks-define')
  , keyOf          = require('./_keyof')
  , enumKeys       = require('./_enum-keys')
  , isArray        = require('./_is-array')
  , anObject       = require('./_an-object')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , createDesc     = require('./_property-desc')
  , _create        = require('./_object-create')
  , gOPNExt        = require('./_object-gopn-ext')
  , $GOPD          = require('./_object-gopd')
  , $DP            = require('./_object-dp')
  , $keys          = require('./_object-keys')
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f  = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./_library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./_an-object":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_an-object.js","./_descriptors":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_descriptors.js","./_enum-keys":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_enum-keys.js","./_export":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_export.js","./_fails":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_fails.js","./_global":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js","./_has":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_has.js","./_hide":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_hide.js","./_is-array":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_is-array.js","./_keyof":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_keyof.js","./_library":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_library.js","./_meta":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_meta.js","./_object-create":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-create.js","./_object-dp":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-dp.js","./_object-gopd":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gopd.js","./_object-gopn":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gopn.js","./_object-gopn-ext":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gopn-ext.js","./_object-gops":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-gops.js","./_object-keys":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-keys.js","./_object-pie":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_object-pie.js","./_property-desc":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_property-desc.js","./_redefine":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_redefine.js","./_set-to-string-tag":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_set-to-string-tag.js","./_shared":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_shared.js","./_to-iobject":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_to-primitive.js","./_uid":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_uid.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js","./_wks-define":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks-define.js","./_wks-ext":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks-ext.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/web.dom.iterable.js":[function(require,module,exports){
var $iterators    = require('./es6.array.iterator')
  , redefine      = require('./_redefine')
  , global        = require('./_global')
  , hide          = require('./_hide')
  , Iterators     = require('./_iterators')
  , wks           = require('./_wks')
  , ITERATOR      = wks('iterator')
  , TO_STRING_TAG = wks('toStringTag')
  , ArrayValues   = Iterators.Array;

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype
    , key;
  if(proto){
    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
  }
}
},{"./_global":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_global.js","./_hide":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_hide.js","./_iterators":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_iterators.js","./_redefine":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_redefine.js","./_wks":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/_wks.js","./es6.array.iterator":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/core-js/modules/es6.array.iterator.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/crypt/crypt.js":[function(require,module,exports){
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/deep-equal/index.js":[function(require,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/deep-equal/lib/is_arguments.js","./lib/keys.js":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/deep-equal/lib/keys.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/deep-equal/lib/is_arguments.js":[function(require,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/deep-equal/lib/keys.js":[function(require,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/ieee754/index.js":[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/is-buffer/index.js":[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/isarray/index.js":[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/l10n-manticore/index.js":[function(require,module,exports){
'use strict';

var parse = require('es6-template-strings/compile');

/**
 * Lazy loading wouldn't really help here because we're mostly just using browserify and that's
 * going to pack the whole bundle. We would need tighter native integration to delay load stuff.
 * TODO see if this matters
 */
var Log = require('manticore-log')('l10n'),
    cultureOrder = ['en-US','en'];

/**
 * Return an instance of l10n against the specified JSON settings
 * @param allCultures
 * @returns {Function}
 */
module.exports = function (allCultures) {
    /**
     * Look from most specific culture to least specific for a value
     * for the given string key. The values are stored in JSON files
     * with a hierarchical structure (e.g. category.screen.stringName: value)
     * and accessed with dotted notation keys.
     * @param key The name of the string value you seek
     * @param substitutions If present, the values used to substitute template values in the string
     * @returns string The string value for the key, or the key if there isn't one.
     */
    return function l10n(key, substitutions) {
        var parts = key.split('.');
        var rawValue = key;
        for (var i = 0; i < cultureOrder.length; i++) {
            var vals = allCultures[cultureOrder[i]];
            if (vals) {
                var value = vals, j = 0;
                for (j = 0; j < parts.length && value; j++) {
                    value = value[parts[j]];
                }
                if (j === parts.length && value) {
                    rawValue = value;
                    break;
                }
            }
        }
        if (substitutions) {
            return subst(rawValue, substitutions);
        }
        return rawValue;
    };
};

var fnPattern = /^\s*l10n\s*\(\s*['"](.*)['"]\s*\)\s*$/;

function subst(rawValue, substitutions) {
    var parsed = parse(rawValue), l = parsed.literals;
    var merged = [];
    for (var lit = 0, len = l.length-1; lit < len; lit++) {
        merged.push(l[lit]);
        var s = (parsed.substitutions[lit] === null || parsed.substitutions[lit] === undefined) ? '' : parsed.substitutions[lit];
        // You can't use full expressions in l10n strings, but you can use
        // l10n(keyname) to at least compose strings
        if (s.indexOf('l10n(') === 0) {
            s = module.exports(s.match(fnPattern)[1], substitutions);
        } else {
            s = (substitutions[s] === null || substitutions[s] === undefined) ? '' : substitutions[s];
        }
        merged.push(s);
    }
    merged.push(l[l.length-1]);
    return merged.join('');
}

/**
 * Change the active culture order
 * @param culture
 */
module.exports.setCultures = function (cultures) {
    cultureOrder = cultures;
};

/**
 * Run straight variable substitution
 */
module.exports.subst = subst;

},{"es6-template-strings/compile":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/l10n-manticore/node_modules/es6-template-strings/compile.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/l10n-manticore/node_modules/es6-template-strings/compile.js":[function(require,module,exports){
'use strict';

var current, literals, substitutions, sOut, sEscape, sAhead, sIn, sInEscape;

sOut = function (char) {
	if (char === '\\') return sEscape;
	if (char === '$') return sAhead;
	current += char;
	return sOut;
};
sEscape = function (char) {
	if ((char !== '\\') && (char !== '$')) current += '\\';
	current += char;
	return sOut;
};
sAhead = function (char) {
	if (char === '{') {
		literals.push(current);
		current = '';
		return sIn;
	}
	if (char === '$') {
		current += '$';
		return sAhead;
	}
	current += '$' + char;
	return sOut;
};
sIn = function (char) {
	if (char === '\\') return sInEscape;
	if (char === '}') {
		substitutions.push(current);
		current = '';
		return sOut;
	}
	current += char;
	return sIn;
};
sInEscape = function (char) {
	if ((char !== '\\') && (char !== '}')) current += '\\';
	current += char;
	return sIn;
};

module.exports = function (str) {
	var length, state, i, result;
	current = '';
	literals = [];
	substitutions = [];

	str = String(str);
	length = str.length;

	state = sOut;
	for (i = 0; i < length; ++i) state = state(str[i]);
	if (state === sOut) {
		literals.push(current);
	} else if (state === sEscape) {
		literals.push(current + '\\');
	} else if (state === sAhead) {
		literals.push(current + '$');
	} else if (state === sIn) {
		literals[literals.length - 1] += '${' + current;
	} else if (state === sInEscape) {
		literals[literals.length - 1] += '${' + current + '\\';
	}
	result = { literals: literals, substitutions: substitutions };
	literals = substitutions = null;
	return result;
};

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js":[function(require,module,exports){
'use strict';

var manticore = require('manticore');

/**
 * Common logging framework for the SDK. You can pass a string,
 * or use an es6 template INSIDE a function (for best performance).
 * @example
 * // Simple string logging
 * Log.debug('Hello World');
 * @example
 * // Use a template but only evaluate the template when logging is enabled
 * Log.debug(() => `Hello ${world}`);
 * @private
 */

var Level = {
    DEBUG: 'DEBUG',
    INFO: 'INFO',
    WARN: 'WARN',
    ERROR: 'ERROR'
};

var Ranks = {
    DEBUG: 1,
    INFO: 2,
    WARN: 3,
    ERROR: 4,
    QUIET: 5
};

var Names = {
    1: 'DEBUG',
    2: 'INFO',
    3: 'WARN',
    4: 'ERROR',
    5: 'QUIET'
};

function manticoreLogger(level, component, message, extraData) {
    manticore.log(level, component.name, message, extraData);
}

// There's probably a smarter way to do this, but at least this is better
// than rampant strings
var RootLogger = {
    name: '*',
    level: 'DEBUG',
    children: {}
}, LogWriters = [manticoreLogger];

function componentLogger(component) {
    var loggers = component.split('.'), myComponent = RootLogger, parent = RootLogger, name;
    for (var i = 0; i < loggers.length; i++) {
        if (name) {
            name += '.' + loggers[i];
        } else {
            name = loggers[i];
        }
        if (!myComponent.children[loggers[i]]) {
            myComponent.children[loggers[i]] = {name: name, children: {}, parent: parent};
        }
        myComponent = myComponent.children[loggers[i]];
        parent = myComponent;
    }
    var closure = {
        debug: function debug(item, extraData) {
            log(Ranks.DEBUG, myComponent, item, extraData);
        },
        info: function info(item, extraData) {
            log(Ranks.INFO, myComponent, item, extraData);
        },
        warn: function warn(item, extraData) {
            log(Ranks.WARN, myComponent, item, extraData);
        },
        error: function error(item, extraData) {
            log(Ranks.ERROR, myComponent, item, extraData);
        },
        withContext: function loggerWithBaseData(context) {
            return makeContextualLogger(closure, context);
        },
        Config: myComponent,
        Root: RootLogger
    };
    return closure;
}

function makeContextualLogger(baseLogger, context) {
    var closure = {
        context: context,
        debug: function debug(item, extraData) {
            baseLogger.debug(item, extend(extraData, context));
        },
        info: function info(item, extraData) {
            baseLogger.info(item, extend(extraData, context));
        },
        warn: function warn(item, extraData) {
            baseLogger.warn(item, extend(extraData, context));
        },
        error: function error(item, extraData) {
            baseLogger.error(item, extend(extraData, context));
        },
        withContext: function loggerWithBaseData(context) {
            return makeContextualLogger(closure, context);
        },
        Config: baseLogger.Config,
        Root: RootLogger
    };
    return closure;
}

function extend(dest, src) {
    if (!dest && !src) {
        return null;
    } else if (!dest || !src) {
        return dest || src;
    }
    for (var prop in src) {
        if (!Object.prototype.hasOwnProperty.call(dest, prop)) {
            dest[prop] = src[prop];
        }
    }
    return dest;
}

module.exports = componentLogger;

/**
 * You can build your own hierarchy by passing some other "Root" object as parent.
 * Otherwise we're configuring from RootLogger and then using levelFor
 * @param json Configuration specification for the log subsystem
 * @param parent Typically null, and we will configure the RootLogger.
 */
function configLogging(json, parent) {
    parent = parent || RootLogger;
    for (var c in json) {
        var v = json[c];
        var component = parent.children[c];
        if (!component) {
            component = parent.children[c] = {};
        }
        component.name = v.name || c;
        component.parent = parent;
        component.children = component.children || {};
        if (v.level) {
            component.level = v.level;
        } else {
            delete component.level;
        }
        if (v.children) {
            configLogging(v.children, component);
        }
    }
}

module.exports.configure = configLogging;
module.exports.Config = module.exports.Root = RootLogger;
module.exports.Level = Level;
module.exports.Ranks = Ranks;

/**
 * Add a function that will be "cc'ed" on log messages. Only messages that
 * are configured to be logged will make it to this function (i.e. we still
 * check log levels and such)
 */
module.exports.addLogger = function (fn) {
    LogWriters.push(fn);
};

module.exports.removeLogger = function (fn) {
    var ix = LogWriters.indexOf(fn);
    if (ix >= 0) {
        LogWriters.splice(ix, 1);
    }
};

function log(level, component, fnOrString, extraData) {
    var configuredLevel = levelFor(component);
    if (level >= configuredLevel) {
        if (typeof(fnOrString) === 'function') {
            fnOrString = fnOrString();
        }
        fnOrString = fnOrString.toString();
        var levelName = Names[level];
        for (var eli = 0, len = LogWriters.length; eli < len; eli++) {
            LogWriters[eli](levelName, component, fnOrString, extraData);
        }
    }
}

function levelFor(component) {
    // We will walk up the chain and pick the first level we find,
    // which should always terminate at the RootLogger, but just in case you mess with us...
    var c = component, configuredLevel;
    while (c && !(configuredLevel = c.level)) {
        c = c.parent;
    }
    return Ranks[configuredLevel || RootLogger.level] || 0;
}

module.exports.levelFor = levelFor;
},{"manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-paypalerror/build/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _PayPalError = require('./src/PayPalError');

Object.keys(_PayPalError).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _PayPalError[key];
    }
  });
});

var _PayPalErrorInfo = require('./src/PayPalErrorInfo');

Object.keys(_PayPalErrorInfo).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _PayPalErrorInfo[key];
    }
  });
});
},{"./src/PayPalError":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-paypalerror/build/src/PayPalError.js","./src/PayPalErrorInfo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-paypalerror/build/src/PayPalErrorInfo.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-paypalerror/build/src/PayPalError.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// SEE README.md for proper usage from JS
/**
 * A common base class for PayPal related errors which includes a debugId and code.
 * This id will be filled out if the error was generated from the PayPal servers.
 * @class
 * @property {string} domain The subsystem responsible for this error, in which the code
 *  should uniquely identify the type of error that has occurred
 * @property {string} code A non-localized code for this error
 * @property {string} message The explanation of the error
 * @property {string} debugId A server-generated identifier used by PayPal to
 *  help diagnose this error
 * @property {string} developerMessage A developer friendly, user unfriendly
 *  message for log statements to give you as much info as possible.
 */

var PayPalError = exports.PayPalError = function () {

  /**
   * Native can't make these
   * @private
   */

  function PayPalError() {
    _classCallCheck(this, PayPalError);

    throw new Error('Do no construct PayPalError.');
  }

  /**
   * Decorate an error to include code, domain and a localized message
   * @param {PayPalError} error the error to be decorated or null if a new error should be created
   * @param {PayPalErrorInfo} info the error info
   * @returns {PayPalError}
   */


  _createClass(PayPalError, null, [{
    key: 'makeError',
    value: function makeError(error, info) {
      // TODO: localize the error message
      // let error  = new Error(getLocalizedErrorMessage(code, domain));
      var _error = error || new Error(info.developerMessage);
      _error.code = info.code;
      _error.domain = info.domain;
      _error.debugId = info.debugId;
      _error.developerMessage = info.developerMessage;
      return _error;
    }
  }]);

  return PayPalError;
}();
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-paypalerror/build/src/PayPalErrorInfo.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A template class for all the properties of the error object
 * @class
 * @property {string} domain The subsystem responsible for this error, in which the code
 *  should uniquely identify the type of error that has occurred
 * @property {string} code A non-localized code for this error
 * @property {string} debugId A server-generated identifier used by PayPal to
 *  help diagnose this error
 * @property {string} developerMessage A developer friendly, user unfriendly
 *  message for log statements to give you as much info as possible.
 */

var PayPalErrorInfo = exports.PayPalErrorInfo = function PayPalErrorInfo() {
  _classCallCheck(this, PayPalErrorInfo);
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js":[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

exports.extend = extend;
exports.assignSome = assignSome;
exports.assignExcept = assignExcept;
exports.reverseKeysAndValues = reverseKeysAndValues;
exports.clone = clone;
exports.deepToJSON = deepToJSON;
function extend(dest, src) {
  for (var prop in src) {
    if (!Object.prototype.hasOwnProperty.call(dest, prop)) {
      dest[prop] = src[prop];
    }
  }
  return dest;
}

function assignSome(dest, src, keys) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var prop = _step.value;

      if (src.hasOwnProperty(prop)) {
        dest[prop] = src[prop];
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return dest;
}

function assignExcept(dest, src, keys) {
  for (var prop in src) {
    if (prop[0] !== '_' && src.hasOwnProperty(prop) && keys.indexOf(prop) < 0) {
      dest[prop] = src[prop];
    }
  }
  return dest;
}

function reverseKeysAndValues(obj) {
  if (!obj) {
    return obj;
  }
  var newObject = {};
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObject[obj[key]] = key;
    }
  }
  return newObject;
}

function clone(obj) {
  var copy = void 0;

  // Handle the 3 simple types, and null or undefined
  if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
    return obj;
  }

  // Handle Date
  if (obj instanceof Date) {
    copy = new Date();
    copy.setTime(obj.getTime());
    return copy;
  }

  // Handle Array
  if (obj instanceof Array) {
    copy = [];
    for (var i = 0, len = obj.length; i < len; i++) {
      copy[i] = clone(obj[i]);
    }
    return copy;
  }

  // Handle Object
  if (obj instanceof Object) {
    copy = {};
    for (var attr in obj) {
      if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
    }
    return copy;
  }

  throw new Error('Unable to copy obj! Its type isn\'t supported.');
}

// Like doing JSON.parse(JSON.stringify(obj)), but without the string
// serialization/deserialization overhead.
function deepToJSON(obj) {
  // Handle the 3 simple types, and null or undefined
  if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
    return obj;
  }

  // Handle thing that has a toJSON method
  if (obj && typeof obj.toJSON === 'function') {
    return deepToJSON(obj.toJSON());
  }

  var retVal = void 0;

  // Handle Array
  if (obj instanceof Array) {
    retVal = [];
    for (var i = 0, len = obj.length; i < len; i++) {
      retVal[i] = deepToJSON(obj[i]);
    }
    return retVal;
  }

  // Handle Object
  if (obj instanceof Object) {
    retVal = {};
    for (var attr in obj) {
      if (obj.hasOwnProperty(attr)) retVal[attr] = deepToJSON(obj[attr]);
    }
    return retVal;
  }

  throw new Error('Unable to deepToJSON obj! Its type isn\'t supported.');
}

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js":[function(require,module,exports){
module.exports = manticore;
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/md5/md5.js":[function(require,module,exports){
(function(){
  var crypt = require('crypt'),
      utf8 = require('charenc').utf8,
      isBuffer = require('is-buffer'),
      bin = require('charenc').bin,

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();

},{"charenc":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/charenc/charenc.js","crypt":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/crypt/crypt.js","is-buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/is-buffer/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/index.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Terminal = require('./lib/Terminal');

Object.keys(_Terminal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Terminal[key];
    }
  });
});
var TerminalDisplay = exports.TerminalDisplay = require('./lib/TerminalDisplay');
var Tags = exports.Tags = require('./lib/MiuraTags');
var CardStatus = exports.CardStatus = require('./lib/messages/CardStatus');

},{"./lib/MiuraTags":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/MiuraTags.js","./lib/Terminal":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/Terminal.js","./lib/TerminalDisplay":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/TerminalDisplay.js","./lib/messages/CardStatus":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/messages/CardStatus.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/MiuraTags.js":[function(require,module,exports){
'use strict';

/**** DO NOT EDIT THIS FILE, IT IS AUTOMATICALLY GENERATED BY gulpfile.js ****/

var DefinedTag = require('tlvlib').DefinedTag;
var ValueFormat = require('tlvlib').ValueFormat;

module.exports = {
  MiuraFileLength: new DefinedTag('MiuraFileLength', 0x80, ValueFormat.Numeric),
  MiuraCommandData: new DefinedTag('MiuraCommandData', 0xE0, ValueFormat.TypeLengthValueList),
  MiuraConfigurationInformation: new DefinedTag('MiuraConfigurationInformation', 0xED, ValueFormat.TypeLengthValueList),
  MiuraSoftwareInformation: new DefinedTag('MiuraSoftwareInformation', 0xEF, ValueFormat.TypeLengthValueList),
  MiuraIdentifier: new DefinedTag('MiuraIdentifier', 0xDF0D, ValueFormat.Alpha),
  MiuraVersionInformation: new DefinedTag('MiuraVersionInformation', 0xDF7F, ValueFormat.Alpha),
  MiuraStateChangeReason: new DefinedTag('MiuraStateChangeReason', 0xC3, ValueFormat.Binary, 1),
  MiuraStateChangeText: new DefinedTag('MiuraStateChangeText', 0xC4, ValueFormat.Alpha),
  MiuraCardStatusInfo: new DefinedTag('MiuraCardStatusInfo', 0x48, ValueFormat.Binary, 2),
  MiuraSREDData: new DefinedTag('MiuraSREDData', 0xdfae02, ValueFormat.Binary),
  MiuraKSN: new DefinedTag('MiuraKSN', 0xdfae03, ValueFormat.Binary),
  MiuraMaskedICCTrack2: new DefinedTag('MiuraMaskedICCTrack2', 0xdfae57, ValueFormat.CompressedAlpha),
  MiuraMaskedPan: new DefinedTag('MiuraMaskedPan', 0xdfae5a, ValueFormat.AlphaNumeric),
  MiuraMaskedTrack2: new DefinedTag('MiuraMaskedTrack2', 0xdfae22, ValueFormat.Alpha),
  MiuraMaskedContactlessTrack2: new DefinedTag('MiuraMaskedContactlessTrack2', 0xdfae6b, ValueFormat.Alpha),
  MiuraKeyboardData: new DefinedTag('MiuraKeyboardData', 0xdfa205, ValueFormat.Binary, 1),
  MiuraNumericData: new DefinedTag('MiuraNumericData', 0xdfa208, ValueFormat.AlphaNumeric),
  MiuraCardholderVerificationStatus: new DefinedTag('MiuraCardholderVerificationStatus', 0xdf28, ValueFormat.Binary, 1),
  MiuraDigitsInPinBuffer: new DefinedTag('MiuraDigitsInPinBuffer', 0xdfa101, ValueFormat.Numeric),
  MiuraPinEntryStatus: new DefinedTag('MiuraPinEntryStatus', 0xdfa102, ValueFormat.Binary, 1),
  MiuraP2PEStatus: new DefinedTag('MiuraP2PEStatus', 0xdfae01, ValueFormat.Binary, 1),
  MiuraFileWriteOffset: new DefinedTag('MiuraFileWriteOffset', 0xDFA301, ValueFormat.Binary),
  MiuraFileWriteLength: new DefinedTag('MiuraFileWriteLength', 0xDFA302, ValueFormat.Binary),
  MiuraFileWriteTimeout: new DefinedTag('MiuraFileWriteTimeout', 0xDFA303, ValueFormat.Binary, 1),
  MiuraFileMD5: new DefinedTag('MiuraFileMD5', 0xDFA304, ValueFormat.Binary),
  MiuraContactlessType: new DefinedTag('MiuraContactlessType', 0xdf30, ValueFormat.Binary, 2),
  MiuraBatteryData: new DefinedTag('MiuraBatteryData', 0xdfa209, ValueFormat.Binary, 1),
  MiuraImageData: new DefinedTag('MiuraImageData', 0xDFAC03, ValueFormat.AlphaNumeric),
  MiuraTextData: new DefinedTag('MiuraTextData', 0xDFAC02, ValueFormat.AlphaNumeric),
  MiuraMediaCoordinates: new DefinedTag('MiuraMediaCoordinates', 0xDFAC01, ValueFormat.Numeric, 2)
};

},{"tlvlib":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/Parser.js":[function(require,module,exports){
(function (Buffer){
'use strict';

var _retailPaymentDevice = require('retail-payment-device');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var manticore = require('manticore'),
    EventEmitter = require('events').EventEmitter,
    Log = require('manticore-log')('miura.parser'),
    Tlv = require('tlvlib'),
    MiuraTags = require('./MiuraTags'),
    ResponsePacket = require('./ResponsePacket');

var ParserEvent = {
    unsolicited: 'unsolicited',
    response: 'response'
};

var MiuraParser = function (_EventEmitter) {
    _inherits(MiuraParser, _EventEmitter);

    function MiuraParser() {
        _classCallCheck(this, MiuraParser);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        _this.partial = null;
        return _this;
    }

    MiuraParser.prototype.reset = function reset() {
        this.partial = null;
    };

    MiuraParser.prototype.received = function received(data) {
        try {
            var raw = Buffer.isBuffer(data) ? data : new Buffer(data, 'base64');
            if (this.incompletePacket) {
                raw = Buffer.concat([this.incompletePacket, raw]);
                delete this.incompletePacket;
            }
            if (raw.length < 3 || raw.length < raw[2] + 4) {
                this.incompletePacket = raw;
                Log.debug('Incomplete packet received.');
                return;
            }
            this._completePacket(raw);
        } catch (x) {
            Log.error('Failed processing Miura packet: ' + x.message + '\n' + x.stack);
            throw x;
        }
    };

    MiuraParser.prototype._completePacket = function _completePacket(raw) {
        var rz = null;
        try {
            rz = this._readResponse(raw);
        } catch (x) {
            Log.error(function () {
                return 'Failed to read terminal response: ' + x.message + '\n' + x.stack;
            });
        }
        if (!rz) {
            return; // No message here, likely a partial
        }
        Log.debug(function () {
            return 'Emitting ' + (rz.unsolicited ? 'unsolicited' : 'responsive') + ' terminal message';
        });
        if (rz.unsolicited) {
            this.emit(ParserEvent.unsolicited, rz);
        } else {
            this.emit(ParserEvent.response, rz);
        }
    };

    MiuraParser.prototype._readResponse = function _readResponse(buffer) {
        var ret = new ResponsePacket();
        buffer = this._validateBuffer(ret, buffer);
        if (buffer[1] === 1) {
            // Partial packet.
            this._processPartial(buffer);
            return;
        }
        ret.length = buffer[2];
        buffer = this._applyPartial(ret, buffer);
        ret.raw = buffer;
        if (ret.length + 4 !== buffer.length) {
            Log.warn(function () {
                return 'Received response packet with non-matching length bytes. Expected ' + (ret.length + 4) + ', got ' + buffer.length;
            });
        }
        var rawBytes = ret.unsolicited ? false : this.expectRawBytes;
        try {
            ret.apdu = new Tlv.ApduResponse(buffer, 3, ret.length, rawBytes);
            Log.debug(function () {
                return 'Miura response template: ' + (ret.apdu.template ? ret.apdu.template.toString(16) : '<empty>') + ' SW1: ' + ret.apdu.sw1.toString(16) + ' SW2: ' + ret.apdu.sw2.toString(16) + ' Raw: ' + buffer.toString('hex');
            });
        } catch (x) {
            Log.error('Failed to parse APDU from raw response: ' + buffer.toString('hex') + '\nError: ' + x.message);
        }
        return ret;
    };

    MiuraParser.prototype._processPartial = function _processPartial(buffer) {
        Log.debug(function () {
            return 'Received partial packet of ' + (buffer.length - 4) + ' bytes ' + buffer.toString('hex');
        });
        if (this.partial === null) {
            this.partial = [];
            this.partialLen = 0;
            this.partial.push(new Buffer('000000', 'hex')); // fake the preamble
        }
        this.partialLen += buffer[2];
        this.partial.push(buffer.slice(3, buffer.length - 1));
    };

    MiuraParser.prototype._applyPartial = function _applyPartial(response, buffer) {
        if (this.partial) {
            this.partial.push(buffer.slice(3, buffer.length - 1));
            this.partial.push(new Buffer('00', 'hex'));
            Log.debug(function () {
                return 'Final packet of partial ' + buffer.toString('hex');
            });
            buffer = Buffer.concat(this.partial);
            response.length += this.partialLen;
            Log.debug(function () {
                return 'Reassembled ' + buffer.length + ' bytes (' + response.length + ').';
            });
            this.partial = null;
            this.partialLen = 0;
        }
        return buffer;
    };

    MiuraParser.prototype._validateBuffer = function _validateBuffer(response, buffer) {
        var _this2 = this;

        if (buffer[0] !== 0x01) {
            Log.warn(function () {
                return 'Received response packet with non-standard NAD byte: ' + buffer[0];
            });
        }
        if (buffer[1] !== 0x00 && buffer[1] !== 0x40 && buffer[1] !== 1) {
            Log.warn(function () {
                return 'Received response packet with non-standard PCB byte: ' + buffer[1];
            });
        }
        if (buffer[1] === 0x40) {
            response.unsolicited = true;
        }
        if (buffer.length > buffer[2] + 4) {
            // Overflow.
            var spill = buffer.slice(buffer[2] + 4, buffer.length);
            buffer = buffer.slice(0, buffer[2] + 4);
            manticore.setTimeout(function () {
                _this2.received(spill);
            }, 0);
        }
        verifyLrc(buffer);
        return buffer;
    };

    return MiuraParser;
}(EventEmitter);

function verifyLrc(buffer) {
    var lrc = 0;
    for (var i = 0; i < buffer.length - 1; i++) {
        lrc ^= buffer[i];
    }
    lrc = lrc & 0xFF;
    if (lrc !== buffer[buffer.length - 1]) {
        Log.warn('LRC did not match. Expected ' + lrc.toString(16) + ', got ' + buffer[buffer.length - 1].toString(16) + '\n' + buffer.toString('hex'));
        throw (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.dataValidationError.withDevMessage('Miura packet error checking failed'));
    }
}

module.exports = MiuraParser;

module.exports.Event = ParserEvent;

}).call(this,require("buffer").Buffer)
},{"./MiuraTags":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/MiuraTags.js","./ResponsePacket":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/ResponsePacket.js","buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js","tlvlib":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/ResponsePacket.js":[function(require,module,exports){
'use strict';

/**
 * Miura response packet including an APDU
 * @property {Buffer} raw the raw bytes of the response
 * @property {int} length the length of the data element of the response
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResponsePacket = function () {
    function ResponsePacket() {
        _classCallCheck(this, ResponsePacket);
    }

    ResponsePacket.prototype.toString = function toString(shouldParse) {
        var str = ['<----\nMiura Response: ', this.apdu ? this.apdu.toString(shouldParse) : 'blank', '\n'];
        str.push('---->');
        return str.join('');
    };

    _createClass(ResponsePacket, [{
        key: 'tlvs',
        get: function get() {
            return this.apdu.tlvs;
        }
    }]);

    return ResponsePacket;
}();

module.exports = ResponsePacket;

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/Terminal.js":[function(require,module,exports){
(function (Buffer){
'use strict';

exports.__esModule = true;
exports.Terminal = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _events = require('events');

var _tlvlib = require('tlvlib');

var _retailPaymentDevice = require('retail-payment-device');

var _MiuraTags = require('./MiuraTags');

var _MiuraTags2 = _interopRequireDefault(_MiuraTags);

var _Parser = require('./Parser');

var _Parser2 = _interopRequireDefault(_Parser);

var _Writer = require('./Writer');

var _Writer2 = _interopRequireDefault(_Writer);

var _BatteryStatus = require('./messages/BatteryStatus');

var _BatteryStatus2 = _interopRequireDefault(_BatteryStatus);

var _TerminalStatus = require('./messages/TerminalStatus');

var _TerminalStatus2 = _interopRequireDefault(_TerminalStatus);

var _CardStatus = require('./messages/CardStatus');

var _CardStatus2 = _interopRequireDefault(_CardStatus);

var _KeyStatus = require('./messages/KeyStatus');

var _KeyStatus2 = _interopRequireDefault(_KeyStatus);

var _TerminalConfig = require('./TerminalConfig');

var _TerminalConfig2 = _interopRequireDefault(_TerminalConfig);

var _TerminalDisplay = require('./TerminalDisplay');

var _TerminalDisplay2 = _interopRequireDefault(_TerminalDisplay);

var _yaku = require('yaku');

var _yaku2 = _interopRequireDefault(_yaku);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = (0, _manticoreLog2.default)('miura.terminal');
var FormFactor = _retailPaymentDevice.PaymentDevice.FormFactor;

var imageMatcherRegex = void 0;

function startTxCommon(txSequenceNumber, txType, amount, currencyCode) {
  var e0Tags = new _tlvlib.TlvList();
  var now = new Date();
  e0Tags.add(_tlvlib.Tags.TransactionSequenceCounter, txSequenceNumber);
  e0Tags.add(_tlvlib.Tags.TransactionDate, now);
  e0Tags.add(_tlvlib.Tags.TransactionTime, now);
  e0Tags.add(_tlvlib.Tags.TransactionType, txType);

  e0Tags.add(_tlvlib.Tags.AmountAuthorized, _tlvlib.Tags.AmountAuthorized.format.toBytes(amount, 6));
  e0Tags.add(_tlvlib.Tags.TransactionCurrencyCode, currencyCode);
  return e0Tags;
}

function buildApps(dr, response) {
  var appId = void 0;
  var appLabel = void 0;
  for (var i = 0; i < response.tlvs.values.length; i++) {
    var t = response.tlvs.values[i];
    if (t.tag === _tlvlib.Tags.TerminalApplicationIdentifier) {
      if (appId) {
        dr.apps.push([appId, appLabel]);
        appLabel = null;
      }
      appId = t.parse();
    } else if (t.tag === _tlvlib.Tags.ApplicationLabel) {
      if (appLabel && appId) {
        dr.apps.push([appId, appLabel]);
        appId = null;
      }
      appLabel = t.parse();
    }
  }
  if (appId) {
    dr.apps.push([appId, appLabel]);
  }
}

var Terminal = exports.Terminal = function (_EventEmitter) {
  _inherits(Terminal, _EventEmitter);

  function Terminal(sendFn, reader) {
    _classCallCheck(this, Terminal);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.reader = reader;
    _this.parser = new _Parser2.default();
    _this.parser.on(Terminal.Event.unsolicited, function (m) {
      return _this._emitUnsolicited(m);
    });
    _this.writer = new _Writer2.default(_this, sendFn);
    _this.Config = new _TerminalConfig2.default(_this);
    // TODO get real model number from somewhere...
    _this.displayController = new _TerminalDisplay2.default('M010');
    return _this;
  }

  Terminal.prototype.didConnect = function didConnect() {
    this.parser.reset();
  };

  Terminal.prototype.received = function received(data) {
    this.parser.received(data);
  };

  /**
   * Put one or more responders at the front of the chain
   * @param responders
   */


  Terminal.prototype.injectResponders = function injectResponders(responders) {
    this.writer.responders = responders.concat(this.writer.responders);
  };

  Terminal.prototype._emitUnsolicited = function _emitUnsolicited(rz) {
    this.emit(Terminal.Event.unsolicited, rz);
    var detailMessage = rz;
    var tmpl = rz.apdu.template;
    if (rz.apdu.template === 0xE6) {
      detailMessage = new _TerminalStatus2.default(rz);
    } else if (rz.apdu.template === 0xE1) {
      if (rz.tlvs && rz.tlvs.find(_MiuraTags2.default.MiuraCardStatusInfo)) {
        detailMessage = new _CardStatus2.default(rz);
        this._reflectCardStatus(detailMessage);
      } else if (rz.tlvs && rz.tlvs.find(_MiuraTags2.default.MiuraKeyboardData)) {
        detailMessage = new _KeyStatus2.default(rz);
      }
    }
    Log.debug(function () {
      return 'Unsolicited message: ' + detailMessage;
    });
    this.emit(Terminal.Event.deviceEvent, detailMessage);
    if (tmpl) {
      this.emit(Terminal.Event.deviceEvent + '.' + tmpl.toString(16), detailMessage);
    }
    if (detailMessage instanceof _CardStatus2.default && (detailMessage.magstripeFlags & 1) === 1) {
      Log.debug(function () {
        return 'EMV Card Swiped ' + rz.raw.toString('hex');
      });
      this.emit(Terminal.Event.cardPresented, detailMessage.getPresentedCard(this.reader));
    }
  };

  Terminal.prototype._reflectCardStatus = function _reflectCardStatus(cardStatus) {
    var _this2 = this;

    var old = this.cardStatus || _retailPaymentDevice.EmvDevice.CardStatus.None;
    if ((cardStatus.chipFlags & 0x3) === 0x3) {
      this.cardStatus = _retailPaymentDevice.EmvDevice.CardStatus.EmvCard;
    } else if ((cardStatus.chipFlags & 0x1) === 0x1) {
      this.cardStatus = _retailPaymentDevice.EmvDevice.CardStatus.NonEmvCard;
    } else {
      this.cardStatus = _retailPaymentDevice.EmvDevice.CardStatus.None;
    }
    // Handle EMV card action here, magstripe happens below for no good reason
    Log.debug(function () {
      return 'Previous card status ' + old + '. New Status ' + _this2.cardStatus;
    });
    if (old !== this.cardStatus && (this.cardStatus & 0x3) > 0) {
      var card = cardStatus.getPresentedCard(this.reader);
      if (card.failed && card.formFactor === FormFactor.Chip) {
        this.emit(Terminal.Event.error, (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.invalidChip), card.formFactor);
        return;
      }
      this.emit(Terminal.Event.cardPresented, card);
    } else if (old !== this.cardStatus && this.cardStatus === _retailPaymentDevice.EmvDevice.CardStatus.None) {
      this.emit(Terminal.Event.cardRemoved);
    }
  };

  Terminal.prototype.display = function display(messageId, values, callback, displaySystemIcons) {
    var msg = this.displayController.formatMessage(messageId, values);
    var mediaMsg = this._parseMedia(msg);

    if (!msg) {
      callback((0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.dataValidationError.withDevMessage('Empty Message')));
      return;
    }

    if (mediaMsg) {
      this.displayImageAndText(mediaMsg.imageId, mediaMsg.msg, callback);
      return;
    }

    this.showMessage(msg, callback, displaySystemIcons);
  };

  Terminal.prototype._parseMedia = function _parseMedia(msg) {
    if (!imageMatcherRegex) {
      imageMatcherRegex = /\$image\((.+)\)(?:\n)*(.*)/;
    }

    var match = imageMatcherRegex.exec(msg);
    if (!match) {
      return null;
    }

    return {
      imageId: match[1],
      msg: match[2]
    };
  };

  Terminal.prototype.displayImage = function displayImage(imageId, callback) {
    var cmd = new _tlvlib.ApduCommand(0xD2, 0xD2);
    cmd.appendString(Terminal.Images[imageId]);
    this.writer.sendAndReceive(cmd, callback);
  };

  Terminal.prototype.displayImageAndText = function displayImageAndText(image, msg, callback) {
    var xText = 0;
    var yText = 50;
    var xImage = 0;
    var yImage = 0;

    var e0Tags = new _tlvlib.TlvList();

    // Display image related tags
    var imagePosition = [_MiuraTags2.default.MiuraMediaCoordinates.valueToBytes(xImage), _MiuraTags2.default.MiuraMediaCoordinates.valueToBytes(yImage)];
    e0Tags.add(_MiuraTags2.default.MiuraMediaCoordinates, Buffer.concat(imagePosition));
    e0Tags.add(_MiuraTags2.default.MiuraImageData, _MiuraTags2.default.MiuraImageData.valueToBytes(image));

    // Display text related tags
    var textPosition = [_MiuraTags2.default.MiuraMediaCoordinates.valueToBytes(xText), _MiuraTags2.default.MiuraMediaCoordinates.valueToBytes(yText)];

    e0Tags.add(_MiuraTags2.default.MiuraMediaCoordinates, Buffer.concat(textPosition));
    e0Tags.add(_MiuraTags2.default.MiuraTextData, _MiuraTags2.default.MiuraTextData.valueToBytes(msg));

    var e0 = new _tlvlib.TlvList();
    e0.add(_MiuraTags2.default.MiuraCommandData, e0Tags);
    var cmd = new _tlvlib.ApduCommand(0xD2, 0x20, 0x00, 0x00);
    cmd.appendBytes(e0.toBytes());
    this.writer.sendAndReceive(cmd, callback);
  };

  // ////////////////////////////////////////////////////////////////////
  // Commands
  // ////////////////////////////////////////////////////////////////////


  Terminal.prototype.softReset = function softReset(callback) {
    this.writer.sendAndReceive(new _tlvlib.ApduCommand(0xD0, 0), callback);
  };

  Terminal.prototype.hardReset = function hardReset(callback) {
    this.writer.sendAndReceive(new _tlvlib.ApduCommand(0xD0, 0, 0x01), callback);
  };

  Terminal.prototype.abortTransaction = function abortTransaction(callback) {
    this.writer.sendAndReceive(new _tlvlib.ApduCommand(0xD0, 0xFF), callback);
  };

  // Response check for acceptable templates
  // ignore=true processes the result for templates to be ignored.
  // ignore expects the response to have a template, but that is not in the acceptableTemplates


  Terminal.prototype.getResponseCheck = function getResponseCheck(templateList, checkDescription, ignore) {
    var responseCheck = function responseCheck(rz) {
      var error = null;
      var mine = false;
      var responseTemplate = rz && rz.apdu && rz.apdu.template;

      var templateTypeText = ignore ? 'Ignored templates' : 'Acceptable Templates';
      if (responseTemplate) {
        mine = templateList.indexOf(responseTemplate) !== -1; //acceptableTemplates contains responseTemplate
        mine = ignore ? !mine : mine;
        Log.debug(function () {
          return 'getResponseCheck ' + checkDescription + '. This is a response with template 0x' + responseTemplate.toString(16) + '. ' + templateTypeText + ' = ' + templateList + '. Mine=' + mine;
        });
      } else {
        Log.debug(function () {
          return 'getResponseCheck ' + checkDescription + ' This is a response with no template. ' + templateTypeText + ' = ' + templateList + '. Mine=' + mine;
        });
      }
      return [error, mine];
    };
    return responseCheck;
  };

  Terminal.prototype.getBatteryLevel = function getBatteryLevel(callback) {

    var responseCheck = this.getResponseCheck([0xE1], 'getBatteryLevel', false);

    this.writer.sendAndReceive(new _tlvlib.ApduCommand(0xD0, 0x62), { responseCheck: responseCheck }, function (err, rz) {
      var batteryStatus = rz && rz.tlvs && rz.tlvs.find(_MiuraTags2.default.MiuraBatteryData) && new _BatteryStatus2.default(rz);
      if (callback) {
        callback(err, batteryStatus);
      }
    });
  };

  Terminal.prototype.disconnectUsb = function disconnectUsb(callback) {
    this.writer.sendAndReceive(new _tlvlib.ApduCommand(0xD0, 0xC0), callback);
  };

  /**
   * Determine whether card status events are sent to your application
   * @param yesEvents truthy to get events, false to turn them off
   * @param callback called when the message has been acknowledged
   */


  Terminal.prototype.registerForCardEvents = function registerForCardEvents(yesEvents, callback) {
    this.writer.sendAndReceive(new _tlvlib.ApduCommand(0xD0, 0x60, yesEvents ? 0x0F : 0), { noResponse: yesEvents }, callback);
  };

  /**
   * Determine whether keyboard events are sent to your application
   * @param yesEvents truthy to get events, false to turn them off
   * @param callback called when the message has been acknowledged
   */


  Terminal.prototype.registerForKeyboardEvents = function registerForKeyboardEvents(yesEvents, callback) {
    this.writer.sendAndReceive(new _tlvlib.ApduCommand(0xD0, 0x61, yesEvents ? 1 : 0), callback);
  };

  Terminal.prototype.showMessage = function showMessage(message, callback, displaySystemIcons) {
    var systemIconsDisplayByte = displaySystemIcons ? 0x01 : 0;
    var cmd = new _tlvlib.ApduCommand(0xD2, 0x01, systemIconsDisplayByte, 0x80);
    cmd.appendString(message);
    this.writer.sendAndReceive(cmd, callback);
  };

  /*
   Prompts: (0-based)
   Please Select
   Enter/Entrez/Voer
   Server Port
   Amount?
   Gratuity?
   Enter Last 4 Digits
   (1) Credit Account
   (2) Cheque Account
   (3) Savings Account
   Enter Budget Period
   (1) Manual Login
   (2) Card Swipe Login
   Prompt index 0x000D
   Enter Expiry Date
   Enter CVV2
   CHQ     SAV     CR
   Enter Cashback Amount
   Enter Store Number
   Enter User ID
   Enter Table Number
   Enter Check Number
   Select Either
   (1) Table Number
   (2) Check Number
   (1) Sale
   (2) Refund
   as MMYY
   Enter Amount
   (1) Full Amount
   (2) Partial Amount
   Account
   Straight or Budget?
   (1) Straight
   (2) Budget
   Enter mobile number
   Enter ref number
   1) 5%          10% (2
   3) 15%         20% (4
   5) Enter Amount
   1) 10%         15% (2
   3) 20%         25% (4
   5) Enter TIP Amount
   Enter TIP Amount
   Prompt index 0x002C
   Enter Gratuity
   Enter TIP
   TIP?
   Prompt index 0x0030
   Enter Issue Number
   Enter Start Date
   Prompt index 0x0033
   Enter refund amount
   1) 5%          2) 10%
   3) 15%         4) 20%
   Prompt index 0x0037
   Please Enter
   Prompt index 0x0039
   Prompt index 0x003A
   Prompt index 0x003B
   Prompt index 0x003C
   Prompt index 0x003D
   Prompt index 0x003E
   Prompt index 0x003F
   Prompt index 0x0040
   Try Again
   Select Account
   Prompt index 0x0043
   Prompt index 0x0044
   Prompt index 0x0045
   Prompt index 0x0046
   Prompt index 0x0047
   Prompt index 0x0048
   Prompt index 0x0049
   Prompt index 0x004A
   Prompt index 0x004B
   Prompt index 0x004C
   Prompt index 0x004D
   Prompt index 0x004E
   Prompt index 0x004F
   Prompt index 0x0050
   Prompt index 0x0051
   Prompt index 0x0052
   Auth Code
   Prompt index 0x0054
   $Revision: Miura-1-1 $
   */


  Terminal.prototype.promptForNumericEntry = function promptForNumericEntry(options, callback) {
    this._numericPrompt(options).then(function (card) {
      return callback(null, card);
    }).catch(function (error) {
      return callback(error, null);
    });
  };

  Terminal.prototype._numericPrompt = function _numericPrompt(options) {
    var promptIndexes, numberFormat, numberToEdit, autoEnt, piBuf, numBuf, cmd, e0Tags, e0, data, numTlv;
    return regeneratorRuntime.async(function _numericPrompt$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            promptIndexes = void 0, numberFormat = void 0, numberToEdit = void 0;
            autoEnt = 0;


            if (options.entryType === _retailPaymentDevice.EmvDevice.NumericEntryType.ExpirationDate) {
              promptIndexes = '000E001B0000';
              numberFormat = '0400';
              autoEnt = 1;
            } else if (options.entryType === _retailPaymentDevice.EmvDevice.NumericEntryType.Cvv) {
              promptIndexes = '0000000F0000';
              numberFormat = '0500';
            }

            piBuf = new Buffer(promptIndexes, 'hex');
            numBuf = new Buffer(numberFormat, 'hex');

            if (!(piBuf.length !== 4 && piBuf.length !== 6)) {
              _context.next = 7;
              break;
            }

            throw (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.dataValidationError.withDevMessage('Prompt index array must be 4 or 6 hex bytes (8 or 12 characters) referencing the prompts.txt file.'));

          case 7:
            if (!(numBuf.length !== 2)) {
              _context.next = 9;
              break;
            }

            throw (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.dataValidationError.withDevMessage('Number format must be 2 hex bytes (4 characters)'));

          case 9:
            cmd = new _tlvlib.ApduCommand(0xD2, 4, autoEnt, 1);
            e0Tags = new _tlvlib.TlvList();

            e0Tags.add(0xDFA206, piBuf);
            e0Tags.add(0xDFA207, numBuf);
            if (numberToEdit) {
              e0Tags.add(0xDFA208, new Buffer(numberToEdit.toString(), 'utf8'));
            }
            e0 = new _tlvlib.TlvList();

            e0.add(0xE0, e0Tags.toBytes());
            cmd.appendBytes(e0.toBytes());
            _context.next = 19;
            return regeneratorRuntime.awrap(this.writer.sendAndReceiveP(cmd));

          case 19:
            data = _context.sent;

            if (data.tlvs) {
              _context.next = 22;
              break;
            }

            throw (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.numericEntryFailed);

          case 22:
            numTlv = data.tlvs.find(_MiuraTags2.default.MiuraNumericData);
            return _context.abrupt('return', numTlv.parse());

          case 24:
          case 'end':
            return _context.stop();
        }
      }
    }, null, this);
  };

  /*
   Prompts:
   Please Enter
   Card Number
   Account Number
   Enter Card Number
   Enter Account Number
   $File: acc-data-prompts $
   $Revision: 1.00 $
   */


  Terminal.prototype.promptForSecureAccountNumber = function promptForSecureAccountNumber(options, callback) {
    this._securePrompt(options).then(function (card) {
      return callback(null, card);
    }).catch(function (error) {
      return callback(error, null);
    });
  };

  Terminal.prototype._securePrompt = function _securePrompt(options) {
    var piBuf, cmd, e0Tags, e0, data, numTlv, card, masked, mmyy;
    return regeneratorRuntime.async(function _securePrompt$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            piBuf = new Buffer('00000004', 'hex');

            if (!(piBuf.length !== 4 && piBuf.length !== 6)) {
              _context2.next = 3;
              break;
            }

            throw (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.dataValidationError, 'Prompt index array must be 4 or 6 hex bytes (8 or 12 characters) referencing the prompts.txt file.');

          case 3:
            cmd = new _tlvlib.ApduCommand(0xD2, 0x5A, 0, 1);
            e0Tags = new _tlvlib.TlvList();

            e0Tags.add(0xDFA206, piBuf);
            e0 = new _tlvlib.TlvList();

            e0.add(0xE0, e0Tags.toBytes());
            cmd.appendBytes(e0.toBytes());
            _context2.next = 11;
            return regeneratorRuntime.awrap(this.writer.sendAndReceiveP(cmd));

          case 11:
            data = _context2.sent;

            if (data.tlvs) {
              _context2.next = 14;
              break;
            }

            throw (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.secureEntryFailed);

          case 14:
            if (data.apdu.isSuccess) {
              _context2.next = 16;
              break;
            }

            throw (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.actionCancelled);

          case 16:
            numTlv = data.tlvs.find(_MiuraTags2.default.MiuraNumericData);
            card = new _retailPaymentDevice.ManuallyEnteredCard();

            card.formFactor = FormFactor.SecureManualEntry;
            card.emvData = data.apdu.data.toString('hex');
            card.reader = this.reader;
            masked = numTlv.parse();

            card.cardIssuer = _retailPaymentDevice.CardDataUtil.getCardIssuerFromCardNumber(masked);
            card.lastFourDigits = masked.substring(masked.length - 4);
            Log.debug('Card number entry complete');

            if (!options.expiration) {
              _context2.next = 30;
              break;
            }

            _context2.next = 28;
            return regeneratorRuntime.awrap(this._numericPrompt({
              entryType: _retailPaymentDevice.EmvDevice.NumericEntryType.ExpirationDate
            }));

          case 28:
            mmyy = _context2.sent;

            card.expiration = '' + mmyy.substring(2) + mmyy.substring(0, 2);

          case 30:
            if (!options.cvv) {
              _context2.next = 36;
              break;
            }

            _context2.t0 = card;
            _context2.next = 34;
            return regeneratorRuntime.awrap(this._numericPrompt({
              entryType: _retailPaymentDevice.EmvDevice.NumericEntryType.Cvv
            }));

          case 34:
            _context2.t1 = _context2.sent;

            _context2.t0.setCvv.call(_context2.t0, _context2.t1);

          case 36:
            return _context2.abrupt('return', card);

          case 37:
          case 'end':
            return _context2.stop();
        }
      }
    }, null, this);
  };

  Terminal.prototype.startICCTransaction = function startICCTransaction(txSequenceNumber, txType, amount, currencyCode, callback) {
    var e0Tags = startTxCommon(txSequenceNumber, txType, amount, currencyCode);
    var e0 = new _tlvlib.TlvList();
    e0.add(_MiuraTags2.default.MiuraCommandData, e0Tags);
    var cmd = new _tlvlib.ApduCommand(0xDE, 0xD1);
    cmd.appendBytes(e0.toBytes());
    this.writer.sendAndReceive(cmd, function (err, response) {
      var error = err || Terminal.parseContactError(response);
      if (error) {
        callback(error, response);
        return;
      }

      if (response.apdu.template === 0xe2 && response.tlvs.find(_tlvlib.Tags.TerminalApplicationIdentifier)) {
        var dr = new _retailPaymentDevice.DecisionRequired(response);
        buildApps(dr, response);
        dr.apdu = response.apdu;
        callback(null, dr);
      } else {
        // TODO more specific response objects to allow other reader types
        callback(null, response);
      }
    });
  };

  Terminal.parseContactError = function parseContactError(response) {
    if (!response || !response.apdu) {
      return (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.badEmvData);
    }

    var apdu = response.apdu;
    if (apdu.template === 0xE5) {
      return (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.contactIssuer);
    }

    var errorMap = {
      0x41: _retailPaymentDevice.deviceError.paymentCancelled,
      0x23: _retailPaymentDevice.deviceError.smartCardNotInSlot,
      0x25: _retailPaymentDevice.deviceError.cardBlocked,
      0x28: _retailPaymentDevice.deviceError.mustSwipeCard
    };

    if (apdu.sw1 === 0x9f && errorMap[apdu.sw2]) {
      return (0, _retailPaymentDevice.getError)(new Error(), errorMap[apdu.sw2]);
    }

    return null;
  };

  Terminal.prototype.startContactlessTransaction = function startContactlessTransaction(txSequenceNumber, txType, amount, currencyCode, callback) {
    var e0Tags = startTxCommon(txSequenceNumber, txType, amount, currencyCode);
    var e0 = new _tlvlib.TlvList();
    e0.add(_MiuraTags2.default.MiuraCommandData, e0Tags);
    var cmd = new _tlvlib.ApduCommand(0xDE, 0xC1, 0x04, 0x00);
    cmd.appendBytes(e0.toBytes());

    var responseCheck = function responseCheck(rz) {
      var error = null;
      var mine = false;
      var acceptableTemplates = [0xE3, 0xE4, 0xE5];
      var responseTemplate = rz && rz.apdu && rz.apdu.template;

      if (rz && rz.apdu && rz.apdu.sw1 === 0x9f && rz.apdu.sw2 === 0xff) {
        error = (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.cannotAcceptMessage);
      } else {
        mine = acceptableTemplates.indexOf(responseTemplate) !== -1 || Terminal.parseContactlessError(rz);
      }

      return [error, mine];
    };

    this.writer.sendAndReceive(cmd, { responseCheck: responseCheck }, function (err, response) {
      var error = err || Terminal.parseContactlessError(response);
      callback(error, response);
    });
  };

  Terminal.parseContactlessError = function parseContactlessError(response) {
    if (!response || !response.apdu) {
      return (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.badEmvData);
    }

    var apdu = response.apdu;
    if (apdu.template === 0xE5) {
      return (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.nfcNotAllowed);
    }

    var errorMap = {
      0x41: _retailPaymentDevice.deviceError.paymentCancelled,
      0x42: _retailPaymentDevice.deviceError.nfcTimeout,
      0x43: _retailPaymentDevice.deviceError.contactlessPaymentAbortedByCardInsert,
      0x44: _retailPaymentDevice.deviceError.contactlessPaymentAbortedByCardSwipe,
      0xc1: _retailPaymentDevice.deviceError.nfcNotAllowed,
      0xc2: _retailPaymentDevice.deviceError.tryDifferentCard,
      0xc3: _retailPaymentDevice.deviceError.mustInsertCard,
      0xcf: _retailPaymentDevice.deviceError.hardwareError
    };

    if (apdu.sw1 === 0x9f && errorMap[apdu.sw2]) {
      return (0, _retailPaymentDevice.getError)(new Error(), errorMap[apdu.sw2]);
    }

    if (!apdu.isSuccess) {
      return (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.generic);
    }

    return null;
  };

  Terminal.prototype.continueTransaction = function continueTransaction(authCode, callback) {
    // The authCode is in fact a TLV buffer. Not the best name from the server for this. So we
    // hand pack the message to the terminal.
    var cmd = new _tlvlib.ApduCommand(0xDE, 0xD2);
    cmd.expectNoBytes = true;
    var e0 = new _tlvlib.TlvList();
    e0.add(0xE0, new Buffer(authCode, 'hex'));
    cmd.appendBytes(e0.toBytes());
    this.writer.sendAndReceive(cmd, function (err, rz) {
      var rzError = void 0;
      if (rz.apdu && (rz.apdu.template === 0XE5 || !rz.apdu.data || rz.apdu.sw1 === 0x9f)) {
        rzError = (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.contactIssuer);
      }
      callback(rzError || err, rz);
    });
  };

  Terminal.prototype.selectApplication = function selectApplication(aid, callback) {
    var responseCheck = this.getResponseCheck([0xE1], 'selectApplication', true);
    var cmd = new _tlvlib.ApduCommand(0xDE, 0xD2);
    cmd.expectNoBytes = true;
    var e0Tags = new _tlvlib.TlvList();
    e0Tags.add(_tlvlib.Tags.TerminalApplicationIdentifier, aid);
    var e0 = new _tlvlib.TlvList();
    e0.add(0xE0, e0Tags.toBytes());
    cmd.appendBytes(e0.toBytes());
    this.writer.sendAndReceive(cmd, { responseCheck: responseCheck }, callback);
  };

  _createClass(Terminal, [{
    key: 'formFactors',
    get: function get() {
      // until we know for sure, assume we can only handle chip
      return this.Config.formFactors || [FormFactor.Chip, FormFactor.MagneticCardSwipe];
    }
  }]);

  return Terminal;
}(_events.EventEmitter);

Terminal.EventType = {
  TerminalStatus: require('./messages/TerminalStatus'),
  ResponsePacket: require('./ResponsePacket')
};

Terminal.TransactionType = {
  SALE: 0,
  REFUND: 20
};

Terminal.Event = {
  unsolicited: _Parser2.default.Event.unsolicited,
  deviceEvent: 'deviceEvent',
  cardPresented: 'cardPresented',
  cardRemoved: 'cardRemoved',
  error: 'error',
  seePhone: 'seePhone'
};

}).call(this,require("buffer").Buffer)
},{"./MiuraTags":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/MiuraTags.js","./Parser":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/Parser.js","./ResponsePacket":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/ResponsePacket.js","./TerminalConfig":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/TerminalConfig.js","./TerminalDisplay":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/TerminalDisplay.js","./Writer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/Writer.js","./messages/BatteryStatus":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/messages/BatteryStatus.js","./messages/CardStatus":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/messages/CardStatus.js","./messages/KeyStatus":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/messages/KeyStatus.js","./messages/TerminalStatus":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/messages/TerminalStatus.js","buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js","tlvlib":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/index.js","yaku":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/yaku/lib/yaku.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/TerminalConfig.js":[function(require,module,exports){
(function (Buffer){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventEmitter = require('events').EventEmitter,
    Tlv = require('tlvlib'),
    MiuraTags = require('./MiuraTags'),
    DeviceCaps = require('./messages/DeviceCaps'),
    Writer = require('./Writer'),
    FormFactor = require('retail-payment-device').PaymentDevice.FormFactor,
    Log = require('manticore-log')('miura.terminal.config');

/**
 * Terminal commands related to device configuration
 */

var TerminalConfig = function () {
    function TerminalConfig(device) {
        _classCallCheck(this, TerminalConfig);

        this.device = device;
        this.writer = device.writer;
    }

    TerminalConfig.prototype.removeLogs = function removeLogs(callback) {
        Log.debug('removeLogs');
        this.writer.sendAndReceive(new Tlv.ApduCommand(0xD0, 0xE1, 0x01), callback);
    };

    TerminalConfig.prototype.archiveLogs = function archiveLogs(callback) {
        Log.debug('archiveLogs');
        this.writer.sendAndReceive(new Tlv.ApduCommand(0xD0, 0xE1), callback);
    };

    /**
     * Select a file on the terminal, such as mpi.log
     * @param file
     * @param callback
     */


    TerminalConfig.prototype.selectFile = function selectFile(file, truncate, callback) {
        var cmd = new Tlv.ApduCommand(0, 0xA4, truncate ? 1 : 0);
        cmd.appendString(file);
        Log.debug(function () {
            return 'Miura Sending selectFile (' + file + ') ApduCommand: ' + cmd;
        });
        this.writer.sendAndReceive(cmd, callback);
    };

    TerminalConfig.prototype.readBinary = function readBinary(offset, len, callback) {
        var cmd;
        if (offset > 0x7FFF) {
            cmd = new Tlv.ApduCommand(0, 0xB0, 0x80 | offset >> 16 & 0x7F, offset >> 8 & 0xFF);
            cmd.appendBytes(new Buffer([offset & 0xFF]));
        } else {
            cmd = new Tlv.ApduCommand(0, 0xB0, offset >> 8 & 0x7F, offset & 0xFF);
        }
        cmd.le = len;
        this.writer.sendAndReceive(cmd, { rawResponse: true }, callback);
    };

    TerminalConfig.prototype.getConfiguration = function getConfiguration(callback) {
        this.writer.sendAndReceive(new Tlv.ApduCommand(0xD0, 1), function (e, r) {
            if (r) {
                r = new DeviceCaps(r);
            }
            callback(e, r);
        });
    };

    TerminalConfig.prototype.getDeviceCapabilities = function getDeviceCapabilities(callback) {
        var _this = this;

        this.writer.sendAndReceive(new Tlv.ApduCommand(0xD0, 2), function (e, r) {
            if (r && r.apdu.isSuccess) {
                r = new DeviceCaps(r);
                _this._factors = [];
                if (r.caps.Smartcard) {
                    _this._factors.push(FormFactor.Chip);
                }
                if (r.caps.Contactless) {
                    _this._factors.push(FormFactor.EmvCertifiedContactless);
                }
                if (r.caps.Mag) {
                    _this._factors.push(FormFactor.MagneticCardSwipe);
                }
                if (r.caps.Keyboard) {
                    _this._factors.push(FormFactor.SecureManualEntry);
                }
            } else {
                Log.debug('Miura device does not support getDeviceCapabilities - proceeding with default capabilities.');
            }
            callback(e, r);
        });
    };

    TerminalConfig.prototype.getP2PEStatus = function getP2PEStatus(callback) {
        this.writer.sendAndReceive(new Tlv.ApduCommand(0xEE, 0xE0), callback);
    };

    TerminalConfig.prototype.initializeP2PE = function initializeP2PE(callback) {
        this.writer.sendAndReceive(new Tlv.ApduCommand(0xEE, 0xE1), callback);
    };

    TerminalConfig.prototype.importP2PE = function importP2PE(callback) {
        this.writer.sendAndReceive(new Tlv.ApduCommand(0xEE, 0xE2), callback);
    };

    TerminalConfig.prototype.getLogFile = function getLogFile(callback) {
        var _this2 = this;

        Log.debug('getLogFile');
        this.archiveLogs(function (eAl, rAl) {
            if (eAl) {
                Log.error('Failed to archive Logs: ' + eAl.message + '\n' + eAl.stack);
                return callback(eAl);
            }
            _this2.getFile('mpi.log', function (eGf, rGf) {
                if (eGf) {
                    Log.error('Failed to get mpi.log: ' + eGf.message + '\n' + eGf.stack);
                }
                callback(eGf, rGf);
                //ToDo: Decide whether we want to remove after copying, as recommended by Miura docs?
            });
        });
    };

    TerminalConfig.prototype.getFile = function getFile(filename, callback) {
        var _this3 = this;

        this.selectFile(filename, 0, function (e, rz) {
            if (e || !rz.apdu.isSuccess) {
                return callback(e || new Error('Could not select file ' + filename), null);
            }
            var lenVal = rz.tlvs.find(MiuraTags.MiuraFileLength);
            if (!lenVal || !lenVal.bytes) {
                return callback(new Error('Empty or missing file length for ' + filename));
            }
            var len = lenVal.parse();
            Log.debug('Fetching ' + len + ' bytes of ' + filename);
            var offset = 0,
                bufs = [],
                reader = function reader() {
                _this3.readBinary(offset, 250, function (e, rz) {
                    if (e) {
                        return callback(e);
                    }
                    len -= rz.apdu.data.length;
                    offset += rz.apdu.data.length;
                    bufs.push(rz.apdu.data);
                    if (len > 0) {
                        return reader();
                    }
                    callback(null, Buffer.concat(bufs));
                });
            };
            reader();
        });
    };

    TerminalConfig.prototype.streamBinary = function streamBinary(data, offset, timeout, md5, callback) {
        var cmd = new Tlv.ApduCommand(0, 0xd7, md5 ? 1 : 0);
        var e0Tags = new Tlv.TlvList();
        var isBuffer = Buffer.isBuffer(data);
        // If it's not a buffer, it's a base64 string
        var dataLength = isBuffer ? data.length : Writer.base64ByteLength(data);
        e0Tags.add(MiuraTags.MiuraFileWriteOffset, numberToBuffer(offset, 3));
        e0Tags.add(MiuraTags.MiuraFileWriteLength, numberToBuffer(dataLength, 3));
        e0Tags.add(MiuraTags.MiuraFileWriteTimeout, numberToBuffer(timeout, 1));
        var e0 = new Tlv.TlvList();
        e0.add(MiuraTags.MiuraCommandData, e0Tags);
        cmd.appendBytes(e0.toBytes());
        Log.debug(function () {
            return 'Miura sending binary stream of ' + dataLength + ' bytes with offset ' + offset;
        });

        this.writer.sendAndReceive(cmd, { additionalData: data }, function (error, result) {
            if (!error && md5 && result && result.tlvs) {
                (function () {
                    var terminalMD5 = result.tlvs.find(MiuraTags.MiuraFileMD5);
                    terminalMD5 = terminalMD5 && terminalMD5.bytes.toString('hex');
                    Log.debug(function () {
                        return 'Comparing md5s. \nSource: ' + md5 + ' \nDestination: ' + terminalMD5;
                    });
                    if (md5 !== terminalMD5) {
                        error = new Error('Mismatched MD5 after streaming binary!');
                    }
                })();
            }

            callback && callback(error, result);
        });
    };

    _createClass(TerminalConfig, [{
        key: 'formFactors',
        get: function get() {
            return this._factors;
        }
    }]);

    return TerminalConfig;
}();

module.exports = TerminalConfig;

function numberToBuffer(number, lengthInBytes) {
    var buf = new Buffer(lengthInBytes);
    buf.writeUIntBE(number, 0, lengthInBytes);
    return buf;
}

}).call(this,require("buffer").Buffer)
},{"./MiuraTags":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/MiuraTags.js","./Writer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/Writer.js","./messages/DeviceCaps":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/messages/DeviceCaps.js","buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js","tlvlib":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/TerminalDisplay.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Message = require('retail-payment-device').PaymentDevice.Message;

var TerminalDisplay = function () {
    function TerminalDisplay(model) {
        _classCallCheck(this, TerminalDisplay);

        this.model = model;
        // This needs to be listed as ifs so that browserify picks up all the relevant files.
        if (model === 'M010') {
            this.lines = 4; // TODO this comes from somewhere in the configs?
            this.lineWidth = 21; // TODO this comes from somewhere in the configs?
            this.l10n = require('l10n-manticore')({
                en: require('../strings/m010/en')
            });
        }
    }

    TerminalDisplay.prototype.formatMessage = function formatMessage(messageId, values) {
        var verticallyCenter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (messageId === Message.SoftwareUpdateProgress && values) {
            messageId = 'SwUpdate.' + values.stage;
        }
        var formatted = this.l10n(messageId, values);
        if (formatted !== messageId) {
            return this.centerString(formatted.split('\n'), verticallyCenter).join('\n');
        } else {
            return '';
        }
    };

    TerminalDisplay.prototype.centerString = function centerString(lineOrLines, verticallyCenter) {
        if (typeof lineOrLines === 'string') {
            if (!this.lines) {
                return [centerLine(lineOrLines, this.lineWidth)];
            }
            lineOrLines = [lineOrLines];
        }
        var newStrs = [];
        for (var _iterator = lineOrLines, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var l = _ref;

            newStrs.push(centerLine(l, this.lineWidth));
        }

        if (!verticallyCenter) {
            return newStrs;
        }

        var lines = this.lines;
        while (lines && lines-- > newStrs.length + 1) {
            newStrs.unshift('');
        }
        return newStrs;
    };

    return TerminalDisplay;
}();

function centerLine(l, w) {
    if (l.length >= w - 1 || l.length === 0) {
        return l;
    }
    return Array(Math.floor((w - l.length) / 2) + 1).join(' ') + l;
}

module.exports = TerminalDisplay;

},{"../strings/m010/en":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/strings/m010/en.js","l10n-manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/l10n-manticore/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/Writer.js":[function(require,module,exports){
(function (Buffer){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _manticore = require('manticore');

var _manticore2 = _interopRequireDefault(_manticore);

var _Parser = require('./Parser');

var _Parser2 = _interopRequireDefault(_Parser);

var _retailPaymentDevice = require('retail-payment-device');

var _manticoreUtil = require('manticore-util');

var _manticoreUtil2 = _interopRequireDefault(_manticoreUtil);

var _yaku = require('yaku');

var _yaku2 = _interopRequireDefault(_yaku);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Log = (0, _manticoreLog2.default)('miura.writer');

/**
 * A class to manage outbound messages to the Terminal and hook up appropriate callbacks with
 * terminal responses.
 * @class
 */

var Writer = function () {
    function Writer(terminal, sendFn) {
        var _this = this;

        _classCallCheck(this, Writer);

        this._terminal = terminal;
        this._sendFn = sendFn;
        this._parser = this._terminal.parser;
        this._parser.on(_Parser2.default.Event.response, function (r) {
            return _this._responseHandler(r);
        });
        this._terminal.reader.on(_retailPaymentDevice.PaymentDevice.Event.disconnected, function () {
            return _this._deviceDisconnected();
        });
        this._requestQueue = [];
        this._requestCounter = 0;
        this._responseQueue = [];
    }

    Writer.prototype.sendAndReceiveP = function sendAndReceiveP(apdu, opts) {
        var _this2 = this;

        return new _yaku2.default(function (accept, reject) {
            _this2.sendAndReceive(apdu, opts, function (error, result) {
                if (error) {
                    reject(error);
                } else {
                    accept(result);
                }
            });
        });
    };

    /**
     * Send a command to Miura and invoke the callback with the response from the device
     * Options:
     *   additionalData: (Buffer/Base64 string) additional data that must be sent with the apdu
     *   noResponse: (Boolean) if true then the request is not expected to get a response from the reader
     *   rawResponse: (Boolean) if true the response is expected to be a stream of raw data rather than a message
     *   responseCheck: (Function (response) => [error, handled]) if this request would receive a response first the responseCheck is invoked. It should return true for handled if it wants to claim the response, false if it wants the next request to attempt to handle it, and an error if the an error should be communicated to the next response
     * @param apdu The tlvlib.ApduCommand to send
     * @param opts - An object containing one/many/none of the options described above OR a function which is shorthand for sendAndReceive(apdu, null, opts)
     * @param callback - The callback function to invoke on receiving an error (if any) and response from the reader
     */


    Writer.prototype.sendAndReceive = function sendAndReceive(apdu, opts, callback) {
        if (typeof opts === 'function') {
            callback = opts;
            opts = {};
        }

        opts = opts || {};

        Log.debug(function () {
            return 'Queueing APDU ' + apdu.toString(true);
        });
        var dataParts = [buildCommandBytes(apdu)];
        if (opts.additionalData) {
            dataParts.push(opts.additionalData);
        }

        var requestData = {
            dataParts: dataParts,
            callback: callback,
            noResponse: opts.noResponse,
            rawResponse: opts.rawResponse,
            responseCheck: opts.responseCheck,
            status: Writer.CommandStatus.Queued,
            ordinal: this._requestCounter++
        };

        this._requestQueue.push(requestData);
        this._sendNext();
    };

    /**
     * If we're not already sending a message send the next one. recursive to send all available messages asap
     * @private
     */


    Writer.prototype._sendNext = function _sendNext() {
        var _this3 = this;

        if (this.sending) {
            Log.debug(function () {
                return 'Already sending message.';
            });
            return;
        } else {
            (function () {
                var cmd = _this3._requestQueue.find(function (x) {
                    return x.status === Writer.CommandStatus.Queued;
                });
                if (cmd) {
                    cmd.status = Writer.CommandStatus.AwaitingResponse;
                    Log.debug(function () {
                        return 'Sending message.';
                    });
                    _this3.sending = true;
                    _this3._updateParserExpectations();
                    _this3._send(cmd.dataParts, function (error) {
                        if (error || cmd.noResponse) {
                            if (error) {
                                Log.error('_sendNext failure: ' + error + ' ' + error.message);
                            }

                            var cmdIndex = _this3._requestQueue.findIndex(function (e) {
                                return e.ordinal === cmd.ordinal;
                            });
                            if (cmdIndex !== -1) {
                                _this3._requestQueue.splice(cmdIndex, 1);
                            }

                            cmd.callback && cmd.callback(error);
                        }
                        _this3.sending = false;
                        _this3._sendNext();
                    });
                } else {
                    Log.debug(function () {
                        return 'No suitable message to send.';
                    });
                }
            })();
        }
    };

    /**
     * Communicate the given data to the terminal. Implements recursive throttling and chunking to accommodate shortcomings in the comm stack
     * @private
     */


    Writer.prototype._send = function _send(dataParts, callback) {
        var _this4 = this;

        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        if (!this._terminal.reader.canPushCommands()) {
            callback && callback((0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.cannotAcceptMessage));
            return;
        }

        var data = dataParts[0];
        var isBuffer = Buffer.isBuffer(data);
        var dataLen = isBuffer ? data.length : base64ByteLength(data);
        var bytesToWrite = dataLen - offset;
        var throttle = this.throttleInfo && this.throttleInfo.pause || 0;
        bytesToWrite = this.throttleInfo && bytesToWrite > this.throttleInfo.size ? this.throttleInfo.size : bytesToWrite;

        Log.debug(function () {
            return 'Sending data part. Total length: ' + dataLen + '. Offset: ' + offset + '. Length to send: ' + bytesToWrite + '. Remaining parts: ' + dataParts.length;
        });
        var sendArgs = void 0;
        if (offset || bytesToWrite < dataLen) {
            if (isBuffer) {
                // It's a buffer, so don't bother making the sendFn do the substring of an overly long base64
                sendArgs = data.slice(offset, offset + bytesToWrite).toString('base64');
            } else {
                // It's base64, so leave it alone and let native pull it out
                sendArgs = {
                    data: data,
                    offset: offset,
                    len: bytesToWrite
                };
            }
        } else {
            sendArgs = isBuffer ? data.toString('base64') : data;
        }

        this._sendFn(sendArgs, function (error) {
            if (error) {
                callback && callback(error);
            } else {
                (function () {
                    var newOffset = offset + bytesToWrite;
                    if (newOffset >= dataLen) {
                        dataParts.shift();
                        newOffset = 0;
                    }

                    if (!dataParts.length) {
                        Log.debug(function () {
                            return 'Successfully sent message.';
                        });
                        callback && callback();
                    } else {
                        _manticore2.default.setTimeout(function () {
                            _this4._send(dataParts, callback, newOffset);
                        }, throttle);
                    }
                })();
            }
        });
    };

    /**
     * @private
     */


    Writer.prototype._updateParserExpectations = function _updateParserExpectations() {
        var currentRequest = this._requestQueue.length && this._requestQueue[0];
        if (currentRequest && currentRequest.status === Writer.CommandStatus.AwaitingResponse) {
            this._parser.expectRawBytes = currentRequest.rawResponse;
        } else {
            this._parser.expectRawBytes = false;
        }
    };

    /**
     * Clean up after device disconnection
     * @private
     */


    Writer.prototype._deviceDisconnected = function _deviceDisconnected() {
        for (var _iterator = this._requestQueue, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var request = _ref;

            request.callback && request.callback((0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.deviceNotConnected));
        }

        this._requestQueue = [];
        this._responseQueue = [];
        this._updateParserExpectations();
    };

    /**
     * Add a response to the queue so we can be sure to handle it in the order it was received
     * @private
     */


    Writer.prototype._responseHandler = function _responseHandler(rz) {
        Log.debug(function () {
            return 'Received response. Adding to queue.';
        });
        this._responseQueue.push(rz);
        this._handleNextResponse();
    };

    /**
     * If we are not handling a response and there is one to handle find the associated request and do the right thing
     * @private
     */


    Writer.prototype._handleNextResponse = function _handleNextResponse() {
        var _this5 = this;

        if (!this._handlingResponse && this._responseQueue.length) {
            this._handlingResponse = true;
            // Skip over responses that don't meet specified criteria of the earlier messages.
            var response = this._responseQueue.shift(),
                requestIndex = 0,
                request = null,
                error = null,
                handled = false;
            Log.debug(function () {
                return 'Handling response';
            });
            while (1) {
                if (this._requestQueue.length <= requestIndex || this._requestQueue[requestIndex].status !== Writer.CommandStatus.AwaitingResponse) {
                    // For now, ignore unexpected responses.
                    this._handlingResponse = false;
                    Log.debug(function () {
                        return 'unexpectedResponse: Remaining unhandled responses: ' + _this5._responseQueue.length + '. Remaining outstanding requests: ' + _this5._requestQueue.length + '. These numbers should eventually get to 0.';
                    });
                    this._responseQueue = [];
                    return;
                }

                request = this._requestQueue[requestIndex];

                if (!error && request.responseCheck) {
                    var _request$responseChec = request.responseCheck(response);

                    error = _request$responseChec[0];
                    handled = _request$responseChec[1];
                } else {
                    handled = true;
                }

                if (handled) {
                    this._requestQueue.splice(requestIndex, 1);
                    request.callback && request.callback(error, response);
                    this._updateParserExpectations();
                    Log.debug(function () {
                        return 'Response handled: Remaining unhandled responses: ' + _this5._responseQueue.length + '. Remaining outstanding requests: ' + _this5._requestQueue.length + '. These numbers should eventually get to 0.';
                    });
                    this._handlingResponse = false;
                    this._handleNextResponse();
                    return;
                } else {
                    requestIndex++;
                }
            }
        }
    };

    _createClass(Writer, [{
        key: 'throttleInfo',
        get: function get() {
            return this._terminal && this._terminal.reader.throttleInfo;
        }
    }]);

    return Writer;
}();

Writer.CommandStatus = {
    Queued: 0,
    AwaitingResponse: 1
};

module.exports = Writer;

function buildCommandBytes(apdu) {
    var lrc = 0;
    var preamble = new Buffer(3);
    preamble.writeUInt8(1, 0); // NAD always 1
    lrc ^= 1;
    preamble.writeUInt8(0, 1); // PCB always 0
    var meat = apdu.toBytes();
    if (meat.length > 255) {
        throw (0, _retailPaymentDevice.getError)(new Error(), _retailPaymentDevice.deviceError.dataValidationError.withDevMessage('Miura command is too long, max 255 bytes, got ' + meat.length));
    }
    preamble.writeUInt8(meat.length, 2);
    lrc ^= meat.length;
    for (var i = 0; i < meat.length; i++) {
        lrc ^= meat[i];
    }
    var epilogue = new Buffer(1);
    epilogue.writeUInt8(lrc & 0xFF, 0);
    return Buffer.concat([preamble, meat, epilogue]);
}

function base64ByteLength(str) {
    var rawLength = str.length * 3 / 4;
    if (str[str.length - 1] === '=') {
        rawLength--;
    }
    if (str[str.length - 2] === '=') {
        rawLength--;
    }
    return rawLength;
}

module.exports.buildCommandBytes = buildCommandBytes;
module.exports.base64ByteLength = base64ByteLength;

}).call(this,require("buffer").Buffer)
},{"./Parser":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/Parser.js","buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","manticore-util":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js","yaku":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/yaku/lib/yaku.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/messages/BatteryStatus.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BatteryStatus = function () {
    function BatteryStatus(apduResponse) {
        _classCallCheck(this, BatteryStatus);

        this.response = apduResponse;
        for (var _iterator = this.response.tlvs.values, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var v = _ref;

            if (v.tagNumber === 0xdfa209) {
                this.readStatus(v);
            } else if (v.tagNumber === 0xdfa20a) {
                this.batteryPercentage = v.bytes[0];
            }
        }
    }

    BatteryStatus.prototype.readStatus = function readStatus(v) {
        switch (v.bytes[0]) {
            case 0:
                this.status = BatteryStatus.DRAINING;
                this.connectedToPower = false;
                break;
            case 1:
                this.status = BatteryStatus.CHARGING;
                this.connectedToPower = true;
                break;
            case 2:
                this.status = BatteryStatus.CHARGED;
                this.connectedToPower = true;
                break;
            case 0xFF:
                this.status = BatteryStatus.DRAINED;
                this.connectedToPower = false;
                break;
            default:
                this.status = BatteryStatus.UNKNOWN;
                this.connectedToPower = false;
                break;
        }
    };

    BatteryStatus.prototype.toString = function toString() {
        return 'Battery Status: ' + this.status + ' (' + this.batteryPercentage + '%), ConnectedToPower? ' + this.connectedToPower;
    };

    return BatteryStatus;
}();

BatteryStatus.DRAINING = 'Draining';
BatteryStatus.DRAINED = 'Drained';
BatteryStatus.CHARGING = 'Charging';
BatteryStatus.CHARGED = 'Charged';
BatteryStatus.UNKNOWN = 'Unknown';

module.exports = BatteryStatus;

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/messages/CardStatus.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Card = require('retail-payment-device').Card,
    Log = require('manticore-log')('miura'),
    Utils = require('manticore-util'),
    FormFactor = require('retail-payment-device').PaymentDevice.FormFactor,
    MagneticCard = require('retail-payment-device').MagneticCard;

/**
 * Contain the details of card events on the Miura terminal such as insertion,
 * swipe, removal, etc.
 */

var CardStatus = function () {
    function CardStatus(miuraResponse) {
        _classCallCheck(this, CardStatus);

        /*jshint maxcomplexity:9 */
        this.response = miuraResponse;
        for (var _iterator = this.response.tlvs.values, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var v = _ref;

            if (v.tagNumber === 0x48) {
                this.chipFlags = v.bytes[0];
                this.magstripeFlags = v.bytes[1];
            } else if (v.tagNumber === 0xdfae03) {
                this.ksn = v.parse();
            } else if (v.tagNumber === 0xdfae02) {
                this.sredData = v.parse();
            } else if (v.tagNumber === 0xdfae22) {
                this.maskedTrack2 = v.parse();
            } else if (v.tagNumber === 0x5f22) {
                this.track2 = v.parse();
            } else if (v.tagNumber === 0xdf30) {
                this.formFactor = FormFactor.EmvCertifiedContactless;
                var contactlessMode = v.bytes[1];
                //Contactless MSD would be set to either 0 or 2
                this.emv = !(contactlessMode === 0 || contactlessMode === 2);
            }
        }
        this.p2pe = miuraResponse.apdu.data.slice(1).toString('hex');
    }

    CardStatus.prototype.getPresentedCard = function getPresentedCard(reader) {
        var card;
        if ((this.magstripeFlags & 0x1) === 0x1) {
            return this._magstripe(reader);
        } else if ((this.chipFlags & 0x3) === 0x3) {
            card = new Card();
            card.formFactor = FormFactor.Chip;
            card.reader = reader;
            Log.debug('EMV Card Inserted');
            return card;
        } else if ((this.chipFlags & 0x1) === 0x1) {
            card = new Card();
            card.formFactor = FormFactor.Chip;
            card.reader = reader;
            card.failed = true;
            Log.warn('EMV Chip Invalid');
            return card;
        } else if (this.formFactor === FormFactor.EmvCertifiedContactless) {
            card = new Card();
            card.formFactor = this.formFactor;
            card.emvData = this.response;
            card.isEmv = this.emv;
            card.reader = reader;
            card.failed = this.response.apdu.template === 0xE5;
            card.isContactlessMSD = !this.emv;
            Utils.extend(card, reader.parseCardData(card, this.response));
            return card;
        }
    };

    CardStatus.prototype._magstripe = function _magstripe(reader) {
        var card = new MagneticCard();
        card.formFactor = FormFactor.MagneticCardSwipe;
        card.ksn = this.ksn ? this.ksn.toString('hex') : '';
        card.reader = reader;
        var track = this.maskedTrack2 || this.track2;
        if (!track || !track.length) {
            Log.error('Missing track 2 from card swipe data');
            card.failed = true;
            return card;
        }
        var start = track.indexOf('=');
        if (start < 6) {
            Log.error('Missing track2 = sentinel from card swipe data');
            card.failed = true;
            return card;
        }
        var serviceCode = track.substring(start + 5, start + 6);
        if (serviceCode === '2' || serviceCode === '6') {
            card.chipCard = true;
        }
        card.track2 = this.response.apdu.data.toString('hex');
        Utils.assignExcept(card, reader.parseCardData(card, this.response), 'isSignatureRequired');
        return card;
    };

    CardStatus.prototype.toString = function toString() {
        var parts = [this.response.toString(), '\nChip flags ', this.chipFlags.toString(16), ' Magstripe flags ', this.magstripeFlags.toString(16)];
        if (this.ksn) {
            parts.push('\nKSN: ');
            parts.push(this.ksn.toString('hex'));
        }
        if (this.track2) {
            parts.push('\nTrack 2: ');
            parts.push(this.track2.toString('hex'));
        }
        if (this.maskedTrack2) {
            parts.push('\nMasked Track 2: ');
            parts.push(this.maskedTrack2);
        }
        if (this.sredData) {
            parts.push('\nSRED: ');
            parts.push(this.sredData.toString('hex'));
        }
        return parts.join('');
    };

    return CardStatus;
}();

module.exports = CardStatus;

},{"manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","manticore-util":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js","retail-payment-device":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/messages/DeviceCaps.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tags = require('../MiuraTags');

var DeviceCaps = function () {
    function DeviceCaps(apduResponse) {
        _classCallCheck(this, DeviceCaps);

        this.response = apduResponse;
        this.caps = {};
        for (var _iterator = this.response.tlvs.values, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var v = _ref;

            if (v.tagNumber === Tags.MiuraConfigurationInformation.number) {
                this.readPair(v.parse());
            }
        }
    }

    DeviceCaps.prototype.readPair = function readPair(tlv) {
        var key,
            val = true;
        for (var _iterator2 = tlv.values, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
            } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
            }

            var v = _ref2;

            if (v.tagNumber === Tags.MiuraIdentifier.number) {
                key = v.parse();
            } else if (v.tagNumber === Tags.MiuraVersionInformation.number) {
                val = v.parse();
            }
        }
        if (key) {
            this.caps[key] = val;
        }
    };

    DeviceCaps.prototype.toString = function toString() {
        var parts = [this.response.toString(), '\nCapabilities: '];
        for (var _iterator3 = this.caps, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
            var _ref3;

            if (_isArray3) {
                if (_i3 >= _iterator3.length) break;
                _ref3 = _iterator3[_i3++];
            } else {
                _i3 = _iterator3.next();
                if (_i3.done) break;
                _ref3 = _i3.value;
            }

            var k = _ref3;

            parts.push('  ');
            parts.push(k);
            if (this.caps[k] && this.caps[k] !== true) {
                parts.push(': ');
                parts.push(this.caps[k]);
            }
        }
        return parts.join('');
    };

    return DeviceCaps;
}();

module.exports = DeviceCaps;

},{"../MiuraTags":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/MiuraTags.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/messages/KeyStatus.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var KeyStatus = function () {
    function KeyStatus(miuraResponse) {
        _classCallCheck(this, KeyStatus);

        this.response = miuraResponse;
        for (var _iterator = this.response.tlvs.values, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var v = _ref;

            if (v.tagNumber === 0xdfa205) {
                this.keyCode = v.bytes[0];
            }
        }
    }

    KeyStatus.prototype.toString = function toString() {
        return this.response.toString() + '\nKeyCode 0x' + this.keyCode.toString(16);
    };

    return KeyStatus;
}();

module.exports = KeyStatus;

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/messages/TerminalStatus.js":[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tags = require('../MiuraTags'),
    Log = require('manticore-log')('device.miura');

var TerminalStatus = function () {
    function TerminalStatus(apduResponse) {
        _classCallCheck(this, TerminalStatus);

        var self = this;
        this.response = apduResponse;
        this.response.tlvs.values.forEach(function (v) {
            if (v.tag === Tags.MiuraStateChangeReason) {
                self.changeType = getTerminalStatus(v.bytes[0]);
            } else if (v.tag === Tags.MiuraStateChangeText) {
                self.description = v.parse();
            } else if (v.tag === Tags.MiuraDigitsInPinBuffer) {
                self.pinDigits = v.parse();
            } else if (v.tag === Tags.MiuraPinEntryStatus) {
                var outcome = v.bytes[0];
                readOutcome(self, outcome);
            }
        });
    }

    TerminalStatus.prototype.toString = function toString() {
        var str = [this.response.toString() + '\nChange Type: ' + this.changeType + ' (' + this.description + ')'];
        if (this.hasOwnProperty('pinDigits')) {
            str.push('\nPIN digits: ');
            str.push(this.pinDigits);
        }
        if (this.hasOwnProperty('pinComplete')) {
            str.push('\nPIN entry complete.');
            if (this.hasOwnProperty('pinCorrect')) {
                str.push('Correct? ' + (this.pinCorrect ? 'yes' : 'no'));
                if (!this.pinCorrect) {
                    str.push('\nPIN failure reason: ');
                    str.push(this.pinFailureReason);
                }
            }
            if (this.lastPinAttempt) {
                str.push('\n*** LAST PIN ATTEMPT ***');
            }
        }
        return str.join('');
    };

    return TerminalStatus;
}();

function getTerminalStatus(byte0) {
    switch (byte0) {
        case 1:
            return TerminalStatus.Constants.PoweringOn;
        case 2:
            return TerminalStatus.Constants.PinEntryStateChange;
        case 3:
            return TerminalStatus.Constants.ApplicationSelection;
        case 0xA:
            return TerminalStatus.Constants.PoweringOff;
        case 0xB:
            return TerminalStatus.Constants.Rebooting;
        case 0xC:
            return TerminalStatus.Constants.MpiRestarting;
        case 0xc0:
            return TerminalStatus.Constants.SeePhone;
        default:
            Log.error('Received unknown terminal status tag (0xC3) value ' + byte0);
            return 'Unknown';
    }
}

function readOutcome(self, outcome) {
    if (outcome === 1) {
        self.lastPinAttempt = true;
    } else if (outcome === 2) {
        self.pinCorrect = true;
        self.pinComplete = true;
    } else if (outcome === 3) {
        self.pinCorrect = false;
        self.pinComplete = true;
        self.pinFailureReason = 'Incorrect PIN';
    } else if (outcome === 4) {
        self.pinCorrect = false;
        self.pinComplete = true;
        self.pinFailureReason = 'Entry Error';
    } else if (outcome === 5) {
        self.pinComplete = true;
    }
}

TerminalStatus.Constants = {
    PoweringOn: 'PoweringOn',
    PinEntryStateChange: 'PinEntryStateChange',
    ApplicationSelection: 'ApplicationSelection',
    PoweringOff: 'PoweringOff',
    Rebooting: 'Rebooting',
    MpiRestarting: 'MpiRestarting',
    SeePhone: 'SeePhone'
};

module.exports = TerminalStatus;

},{"../MiuraTags":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/lib/MiuraTags.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/miura-emv/strings/m010/en.js":[function(require,module,exports){
'use strict';

module.exports = {
    Connecting: '\nConnecting to\nApplication',
    NotConnected: 'Open the app on your\nphone or tablet.',
    Ready: 'Ready to accept\npayments.',
    NfcTimeout: '${amount}\nTransaction timed out',
    GeneralNfcFallback: 'Unable to read card.\nInsert or swipe\ncard now or try\n a different card',
    TransactionCancelled: '${amount}\nTransaction cancelled',
    ReadyForInsertAndSwipePayment: '$image(insertswipe.bmp)\n${amount}',
    ReadyForInsertPayment: '$image(Insert.bmp)\n${amount}',
    ReadyForSwipePayment: '$image(Swipe.bmp)\n${amount}',
    ContactIssuer: 'Please contact your\ncard issuer.',
    InvoiceTotal: '${amount}${footer}',
    RechargeNow: 'Recharge now.',
    AmountTooLow: 'Card minimum is\n${amount}',
    AmountTooHigh: 'Card maximum is\n${amount}',
    SwUpdate: {
        EncryptInit: 'Initializing\nDevice',
        EncryptGet: 'Validating\nSecurity\nKeys',
        EncryptDone: 'Security\nKeys\nInstalled',
        Required: 'Software\nUpdate\nRequired',
        OS: 'Updating OS\n${progress}%',
        MPI: 'Updating Terminal\n${progress}%',
        Config: 'Updating\nConfiguration\n${progress}%',
        Failed: 'Software update\nfailed.'
    },
    Processing: {
        Tap: 'Processing...',
        Contact: '${amount}\nDo not remove card.\nProcessing...',
        PinOk: '\nDo not remove card.\nProcessing...\nPIN OK'
    },
    Paid: {
        RemoveCard: '${amount} paid.\nPlease remove card.',
        Successful: '${amount} paid.\nThank you!'
    },
    Refund: {
        RemoveCard: '${amount} refunded.\nPlease remove card.',
        Successful: '${amount} refunded.\nThank you!'
    },
    Declined: {
        BlockedCardInserted: 'Declined.\nPlease remove card.',
        UnableToReadNfcCard: 'Unable to read card.\nInsert, swipe, or\npress OK on the app\nand tap another card.',
        NfcDecline: 'Declined.\nRetry with\ninsert or swipe?',
        IncorrectPin: 'Incorrect PIN\nPlease try again.'
    },
    Signature: {
        Insert: 'Signature Required.\nDo not remove card.',
        NonEmv: '${amount} paid\nSignature Required.',
        Tap: 'Signature Required.'
    },
    CompletingPayment: 'Completing payment...',
    TransactionCancelling: 'Cancelling...'
};

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/moment/moment.js":[function(require,module,exports){
//! moment.js
//! version : 2.15.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        var k;
        for (k in obj) {
            // even if its not own property I'd still call it non-empty
            return false;
        }
        return true;
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return this._months;
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return this._monthsShort;
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        if (!m) {
            return this._weekdays;
        }
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = create_utc__createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        ordinalParse: defaultOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                            'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, parentConfig = baseConfig;
            // MERGE
            if (locales[name] != null) {
                parentConfig = locales[name]._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (isDate(input)) {
            config._d = input;
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);

            if (tZone === 0) {
                this.utcOffset(0, true);
            } else {
                this.utcOffset(offsetFromString(matchOffset, this._i));
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIOROITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = stringGet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = stringSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var prototype__proto = Locale.prototype;

    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto.ordinal         = ordinal;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    prototype__proto.weekdaysRegex       =        weekdaysRegex;
    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function lists__listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function lists__listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function lists__listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function lists__listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.15.1';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.updateLocale          = updateLocale;
    utils_hooks__hooks.locales               = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.calendarFormat        = getCalendarFormat;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/index.js":[function(require,module,exports){
'use strict';

var InvoicingFakeServer = null;
try {
  InvoicingFakeServer = require('./lib/InvoicingFakeServer').default;
} catch (x) {
  // Do nothing, fake server not available.
}

module.exports = {
  setupFakeServer: function setupFakeServer(fakeServer) {
    if (!InvoicingFakeServer || !InvoicingFakeServer.getFakeResponses) {
      throw new Error('Fake server module is not available.');
    }
    fakeServer.addFakeResponses(InvoicingFakeServer.getFakeResponses());
  },


  BaseService: require('./lib/BaseClasses/BaseService').default,
  InvoicingService: require('./lib/InvoicingService').default,
  Currency: require('./lib/Currency').default,
  InvoicePayment: require('./lib/Payment').default,
  InvoicePaymentTerm: require('./lib/PaymentTerm').default,
  InvoiceRefund: require('./lib/Refund').default,
  InvoiceCCInfo: require('./lib/CCInfo').default,
  InvoiceAddress: require('./lib/Address').default,
  InvoiceBillingInfo: require('./lib/BillingInfo').default,
  InvoiceMerchantInfo: require('./lib/MerchantInfo').default,
  InvoiceShippingInfo: require('./lib/ShippingInfo').default,
  InvoiceItem: require('./lib/Item').default,
  InvoiceNotification: require('./lib/Notification').default,
  InvoicingRequester: require('./lib/Requester').default,
  InvoiceActions: require('./lib/InvoiceActions').default,
  InvoiceAttachment: require('./lib/Attachment').default,
  Invoice: require('./lib/Invoice').default,
  InvoiceListRequest: require('./lib/InvoiceListRequest').default,
  InvoiceListResponse: require('./lib/InvoiceListResponse').default,
  InvoiceSearchRequest: require('./lib/SearchRequest').default,
  AccountSummary: require('./lib/AccountSummary').default,
  AccountSummarySection: require('./lib/AccountSummarySection').default,
  Countries: require('./lib/Countries').default,
  Country: require('./lib/Country').default,
  InvoiceEnums: require('./lib/InvoiceEnums').default,
  InvoiceCustomAmount: require('./lib/CustomAmount').default,

  $$: require('./lib/InvoiceBigNumber').$$
};
},{"./lib/AccountSummary":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/AccountSummary.js","./lib/AccountSummarySection":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/AccountSummarySection.js","./lib/Address":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Address.js","./lib/Attachment":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Attachment.js","./lib/BaseClasses/BaseService":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/BaseClasses/BaseService.js","./lib/BillingInfo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/BillingInfo.js","./lib/CCInfo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/CCInfo.js","./lib/Countries":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Countries.js","./lib/Country":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Country.js","./lib/Currency":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Currency.js","./lib/CustomAmount":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/CustomAmount.js","./lib/Invoice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Invoice.js","./lib/InvoiceActions":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceActions.js","./lib/InvoiceBigNumber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceBigNumber.js","./lib/InvoiceEnums":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceEnums.js","./lib/InvoiceListRequest":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceListRequest.js","./lib/InvoiceListResponse":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceListResponse.js","./lib/InvoicingFakeServer":false,"./lib/InvoicingService":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoicingService.js","./lib/Item":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Item.js","./lib/MerchantInfo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/MerchantInfo.js","./lib/Notification":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Notification.js","./lib/Payment":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Payment.js","./lib/PaymentTerm":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/PaymentTerm.js","./lib/Refund":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Refund.js","./lib/Requester":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Requester.js","./lib/SearchRequest":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/SearchRequest.js","./lib/ShippingInfo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/ShippingInfo.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/AccountSummary.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _InvoiceEnums = require('./InvoiceEnums');

var _InvoiceEnums2 = _interopRequireDefault(_InvoiceEnums);

var _InvoiceBigNumber = require('./InvoiceBigNumber');

var _AccountSummarySection = require('./AccountSummarySection');

var _AccountSummarySection2 = _interopRequireDefault(_AccountSummarySection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Account summary for current merchant
 * @class
 * @property {decimal} outstandingAmount outstanding amount on account
 * @property {AccountSummarySection} pastDueSection section summary
 *  containing past due invoice information
 * @property {AccountSummarySection} awaitingPaymentSection section
 *  summary containing awaiting invoice information
 * @property {AccountSummarySection} draftSection section summary
 *  containing draft invoice information
 * @property {AccountSummarySection} paidSection section summary
 *  containing paid invoice information
 */

var AccountSummary = function () {
  function AccountSummary(nonOverdueJson, overdueJson) {
    _classCallCheck(this, AccountSummary);

    this.pastDueSection = this.sectionFromSummaries(overdueJson.summaries);

    // The 'nonOverdueJson' actually includes overdue invoices.
    this.awaitingPaymentSection = this.sectionForStatuses([_InvoiceEnums2.default.Status.SENT, _InvoiceEnums2.default.Status.PARTIALLY_PAID, _InvoiceEnums2.default.Status.UNPAID], nonOverdueJson);

    this.draftSection = this.sectionForStatuses([_InvoiceEnums2.default.Status.DRAFT], nonOverdueJson);

    this.paidSection = this.sectionForStatuses([_InvoiceEnums2.default.Status.MARKED_AS_PAID, _InvoiceEnums2.default.Status.PAID], nonOverdueJson);

    this.outstandingAmount = this.awaitingPaymentSection.totalAmount;
  }

  // Given an array of invoice statuses and a JSON response from the summary endpoint, returns
  // an AccountSummarySection whose values are the sum of all the summaries whose statuses
  // are in the status array


  AccountSummary.prototype.sectionForStatuses = function sectionForStatuses(statuses, json) {
    return this.sectionFromSummaries(this.summariesForStatuses(statuses, json));
  };

  // Given an array of invoice statuses and a JSON response from the summary endpoint, returns an
  // array of the summaries whose statuses are in the status array


  AccountSummary.prototype.summariesForStatuses = function summariesForStatuses(statuses, json) {
    var retVal = [];
    for (var _iterator = json.summaries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var summary = _ref;

      if (statuses.indexOf(_InvoiceEnums2.default.Status[summary.status]) >= 0) {
        retVal.push(summary);
      }
    }
    return retVal;
  };

  // Given an array of summaries, sums all their values into an AccountSummarySection


  AccountSummary.prototype.sectionFromSummaries = function sectionFromSummaries(summaries) {
    var count = 0;
    var totalAmount = (0, _InvoiceBigNumber.$$)('0');
    var paidAmount = (0, _InvoiceBigNumber.$$)('0');
    var refundedAmount = (0, _InvoiceBigNumber.$$)('0');
    for (var _iterator2 = summaries, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var summary = _ref2;

      count += summary.count;
      if (summary.amount_summary && summary.amount_summary.length) {
        // TODO: the amount_summary array contains multiple summaries
        // grouped by currency codes. Right now we just take the first.
        // Weird stuff will happen if we actually get multiple currencies.
        var amountSummary = summary.amount_summary[0];
        if (amountSummary.total_amount) {
          totalAmount = totalAmount.add((0, _InvoiceBigNumber.$$)(amountSummary.total_amount.value));
        }
        if (amountSummary.paid_amount) {
          if (amountSummary.paid_amount.other) {
            paidAmount = paidAmount.add((0, _InvoiceBigNumber.$$)(amountSummary.paid_amount.other.value));
          }
          if (amountSummary.paid_amount.paypal) {
            paidAmount = paidAmount.add((0, _InvoiceBigNumber.$$)(amountSummary.paid_amount.paypal.value));
          }
        }
        if (amountSummary.refunded_amount) {
          if (amountSummary.refunded_amount.other) {
            refundedAmount = refundedAmount.add((0, _InvoiceBigNumber.$$)(amountSummary.refunded_amount.other.value));
          }
          if (amountSummary.refunded_amount.paypal) {
            refundedAmount = refundedAmount.add((0, _InvoiceBigNumber.$$)(amountSummary.refunded_amount.paypal.value));
          }
        }
      }
    }
    return new _AccountSummarySection2.default(count, totalAmount, paidAmount, refundedAmount);
  };

  AccountSummary.prototype.subtractSection = function subtractSection(section1, section2) {
    return new _AccountSummarySection2.default(section1.totalCount - section2.totalCount, section1.totalAmount.minus(section2.totalAmount), section1.paidAmount.minus(section2.paidAmount), section1.refundedAmount.minus(section2.refundedAmount));
  };

  return AccountSummary;
}();

exports.default = AccountSummary;
},{"./AccountSummarySection":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/AccountSummarySection.js","./InvoiceBigNumber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceBigNumber.js","./InvoiceEnums":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceEnums.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/AccountSummarySection.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Account summary for current merchant
 * @class
 * @property {decimal} totalCount total count of invoices for section
 * @property {decimal} totalAmount total amount for section
 * @property {decimal} paidAmount paid amount for section
 * @property {decimal} refundedAmount refunded amount for section
 */

var AccountSummarySection = function AccountSummarySection(totalCount, totalAmount, paidAmount, refundedAmount) {
  _classCallCheck(this, AccountSummarySection);

  this.totalCount = totalCount;
  this.totalAmount = totalAmount;
  this.paidAmount = paidAmount;
  this.refundedAmount = refundedAmount;
};

exports.default = AccountSummarySection;
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Address.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Container for addresses used on various invoice entities
 * @class
 *
 * @property {string} line1 First line of the address @required
 * @property {string} line2 Second line of the address
 * @property {string} city City portion of the address
 * @property {string} state State, if applicable
 * @property {string} postalCode Postal Code
 * @property {string} country ISO two letter country code @required
 * @property {string} phone Phone number in E.123 format.
 * @property {bool} isPrimary
 * @property {string} addressee
 */

var InvoiceAddress = function () {
  function InvoiceAddress() {
    _classCallCheck(this, InvoiceAddress);
  }

  InvoiceAddress.prototype.readFromJson = function readFromJson(json) {
    if (json) {
      this.line1 = json.line1;
      if (!this.line1 && json.addressLine1) {
        this.line1 = json.addressLine1;
      }
      this.line2 = json.line2;
      if (!this.line2 && json.addressLine2) {
        this.line2 = json.addressLine2;
      }
      this.city = json.city;
      this.state = json.state;
      this.postalCode = json.postal_code;
      this.country = json.country_code;
      this.phone = json.phone;
      this.addressee = json.addressee_name;
      this.isPrimary = json.isPrimary;
    }
  };

  InvoiceAddress.prototype.toJSON = function toJSON() {
    var r = void 0;
    if (this.hasAnyValue()) {
      r = {};
      r.line1 = this.line1;
      r.line2 = this.line2;
      r.city = this.city;
      r.state = this.state;
      r.postal_code = this.postalCode;
      r.country_code = this.country;
      r.addressee = this.addressee;
      r.isPrimary = this.isPrimary;
      r.phone = this.phone;
    }
    return r;
  };

  /**
   * Check to see if this object has any value
   * @returns {bool}
   */


  InvoiceAddress.prototype.hasAnyValue = function hasAnyValue() {
    if (this.line1 || this.line2 || this.city || this.state || this.postalCode || this.country || this.addressee || this.phone) {
      return true;
    }
    return false;
  };

  return InvoiceAddress;
}();

exports.default = InvoiceAddress;
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Attachment.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Invoice attachment
 * @class
 * @property {string} name name of the attachment
 * @property {string} url url of the attachment
 */

var InvoiceAttachment = function () {
  function InvoiceAttachment() {
    _classCallCheck(this, InvoiceAttachment);
  }

  InvoiceAttachment.readFromJson = function readFromJson(json) {
    var a = new InvoiceAttachment();

    a.name = json.name;
    a.url = json.url;

    return a;
  };

  /**
   * workaround for known API issue, returns usable version of the URL
   * @returns {string} the usable url
   */


  InvoiceAttachment.prototype.usableURL = function usableURL() {
    var re = new RegExp('sig.*&');
    var section = this.url.match(re)[0];
    var newSection = section.split('/').join('.').split('+').join('-').replace('=&', '&');
    var newURL = this.url.replace(section, newSection);

    return newURL;
  };

  return InvoiceAttachment;
}();

exports.default = InvoiceAttachment;
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/BaseClasses/BaseService.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 */

var BaseService = function BaseService() {
  _classCallCheck(this, BaseService);
};

exports.default = BaseService;
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/BillingInfo.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Address = require('./Address');

var _Address2 = _interopRequireDefault(_Address);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Container for information about the payer or intended payer on an invoice
 * @class
 * @property {string} email The email address of the payer @required @length(1,260) @format(email)
 * @property {string} firstName The first name of the payer @length(,30)
 * @property {string} lastName The last name of the payer @length(,30)
 * @property {string} businessName The business name of the payer
 * @property {InvoiceAddress} address The address of the payer @length(,100)
 * @property {string} language Language of the email sent to the payer. Will
 *  only be used if payer doesn't have a PayPal account.
 * @property {string} additionalInfo Option to display additional information
 *  such as business hours. 40 characters max.
 * @property {string} notificationChannel Preferred notification channel of the
 *  payer. Email by default.
 * @property {string} countryCode Country code (in E.164 format). Assume length is n.
 * @property {string} nationalNumber In-country phone number (in E.164 format).
 *  Maximum (15 - n) digits
 */

var InvoiceBillingInfo = function () {
  function InvoiceBillingInfo() {
    _classCallCheck(this, InvoiceBillingInfo);

    this.address = new _Address2.default();
  }

  InvoiceBillingInfo.prototype.readFromJson = function readFromJson(json) {
    if (json) {
      this.address.readFromJson(json.address);
      this.firstName = json.first_name;
      this.lastName = json.last_name;
      this.businessName = json.business_name;
      this.email = json.email;
      this.language = json.language;
      this.additionalInfo = json.additional_info;
      this.notificationChannel = json.notification_channel;
      if (json.phone) {
        this.countryCode = json.phone.country_code;
        this.nationalNumber = json.phone.national_number;
      }
    }
  };

  InvoiceBillingInfo.prototype.toJSON = function toJSON() {
    var r = {};
    // If the address is empty, don't include it in the JSON.
    if (Object.keys(this.address).length) {
      r.address = this.address;
    }
    r.first_name = this.firstName;
    r.last_name = this.lastName;
    r.email = this.email;
    r.business_name = this.businessName;
    r.language = this.language;
    r.additional_info = this.additionalInfo;
    r.notification_channel = this.notificationChannel;

    if (this.nationalNumber) {
      r.phone = {};
      r.phone.country_code = this.countryCode;
      r.phone.national_number = this.nationalNumber;
    }

    return r;
  };

  /**
   * Check to see if this object has any value
   * @returns {bool}
   */


  InvoiceBillingInfo.prototype.hasAnyValue = function hasAnyValue() {
    if (this.email || this.firstName || this.lastName || this.businessName || this.address.hasAnyValue() || this.language || this.additionalInfo || this.notificationChannel || this.countryCode || this.nationalNumber) {
      return true;
    }
    return false;
  };

  return InvoiceBillingInfo;
}();

exports.default = InvoiceBillingInfo;
},{"./Address":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Address.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/CCInfo.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Address = require('./Address');

var _Address2 = _interopRequireDefault(_Address);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Container for information about a person CC'ed on an invoice
 * @class
 * @property {string} email The email address of the
 *  merchant @required @length(1,260) @format(email)
 * @property {string} firstName The first name of the merchant @length(,30)
 * @property {string} lastName The last name of the merchant @length(,30)
 * @property {InvoiceAddress} address The address of the merchant
 * @property {string} businessName The business name of the merchant
 * @property {string} phone The phone number of the merchant
 * @property {string} fax The fax number of the merchant
 * @property {string} website The URL of the merchant website @format{url}
 * @property {string} additionalInfo option to display additional info such as business hours
 **/

var InvoiceCCInfo = function () {
  function InvoiceCCInfo() {
    _classCallCheck(this, InvoiceCCInfo);

    this.address = new _Address2.default();
  }

  InvoiceCCInfo.fromJson = function fromJson(json) {
    var ccInfo = new InvoiceCCInfo();

    if (json) {
      ccInfo.address.readFromJson(json.address);
      ccInfo.firstName = json.first_name;
      ccInfo.lastName = json.last_name;
      ccInfo.businessName = json.business_name;
      ccInfo.email = json.email;
      ccInfo.phone = json.phone;
      ccInfo.fax = json.fax;
      ccInfo.website = json.website;
      ccInfo.additionalInfo = json.additional_info;
    }

    return ccInfo;
  };

  InvoiceCCInfo.prototype.toJSON = function toJSON() {
    var r = {};
    r.email = this.email;
    r.first_name = this.firstName;
    r.last_name = this.lastName;
    r.business_name = this.businessName;
    r.phone = this.phone;
    r.fax = this.fax;
    r.website = this.website;
    r.additional_info = this.additionalInfo;
    r.address = this.address;

    return r;
  };

  return InvoiceCCInfo;
}();

exports.default = InvoiceCCInfo;
},{"./Address":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Address.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Countries.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Country = require('./Country');

var _Country2 = _interopRequireDefault(_Country);

var _CountryMap = require('./CountryMap');

var _CountryMap2 = _interopRequireDefault(_CountryMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 *
 *
 */

var Countries = function () {
  function Countries() {
    _classCallCheck(this, Countries);
  }

  /**
   * @returns {[Country]}
   */

  Countries.countries = function countries() {
    if (!Countries._countries) {
      Countries._countries = [];
      for (var _iterator = Object.keys(_CountryMap2.default), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var countryCode = _ref;

        Countries._countries.push(new _Country2.default(countryCode, _CountryMap2.default[countryCode]));
      }
    }

    return Countries._countries;
  };

  /**
   * Given a country code, returns the full name of the country.
   * If there's no match, returns undefined.
   * @param {string} countryCode
   * @returns {string}
   */


  Countries.countryForCountryCode = function countryForCountryCode(countryCode) {
    if (!countryCode) {
      return undefined;
    }
    var upperCountryCode = countryCode.toUpperCase();

    for (var _iterator2 = this.countries(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var country = _ref2;

      if (country.code === upperCountryCode) {
        if (country.name) {
          return country.name;
        }
      }
    }
    return undefined;
  };

  return Countries;
}();

exports.default = Countries;
},{"./Country":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Country.js","./CountryMap":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/CountryMap.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Country.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 *
 * @property {string} code The code for a country @readonly
 * @property {string} name The name of a country @readonly
 */

var Country =
/**
 * Create a new country.
 * @constructor
 * @param {string} countryCode
 * @param {string} countryName
 */
function Country(countryCode, countryName) {
  _classCallCheck(this, Country);

  this.code = countryCode;
  this.name = countryName;
};

exports.default = Country;
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/CountryMap.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = {
  AL: 'Albania',
  DZ: 'Algeria',
  AD: 'Andorra',
  AO: 'Angola',
  AI: 'Anguilla',
  AG: 'Antigua & Barbuda',
  AR: 'Argentina',
  AM: 'Armenia',
  AW: 'Aruba',
  AU: 'Australia',
  AT: 'Austria',
  AZ: 'Azerbaijan',
  BS: 'Bahamas',
  BH: 'Bahrain',
  BB: 'Barbados',
  BY: 'Belarus',
  BE: 'Belgium',
  BZ: 'Belize',
  BJ: 'Benin',
  BM: 'Bermuda',
  BT: 'Bhutan',
  BO: 'Bolivia',
  BA: 'Bosnia & Herzegovina',
  BW: 'Botswana',
  BR: 'Brazil',
  VG: 'British Virgin Islands',
  BN: 'Brunei',
  BG: 'Bulgaria',
  BF: 'Burkina Faso',
  BI: 'Burundi',
  KH: 'Cambodia',
  CM: 'Cameroon',
  CA: 'Canada',
  CV: 'Cape Verde',
  KY: 'Cayman Islands',
  TD: 'Chad',
  CL: 'Chile',
  CN: 'China',
  C2: 'China World Wide',
  CO: 'Colombia',
  KM: 'Comoros',
  CG: 'Congo - Brazzaville',
  CD: 'Congo - Kinshasa',
  CK: 'Cook Islands',
  CR: 'Costa Rica',
  CI: 'Cte dIvoire',
  HR: 'Croatia',
  CY: 'Cyprus',
  CZ: 'Czech Republic',
  DK: 'Denmark',
  DJ: 'Djibouti',
  DM: 'Dominica',
  DO: 'Dominican Republic',
  EC: 'Ecuador',
  EG: 'Egypt',
  SV: 'El Salvador',
  ER: 'Eritrea',
  EE: 'Estonia',
  ET: 'Ethiopia',
  FK: 'Falkland Islands',
  FO: 'Faroe Islands',
  FJ: 'Fiji',
  FI: 'Finland',
  FR: 'France',
  GF: 'French Guiana',
  PF: 'French Polynesia',
  GA: 'Gabon',
  GM: 'Gambia',
  GE: 'Georgia',
  DE: 'Germany',
  GI: 'Gibraltar',
  GR: 'Greece',
  GL: 'Greenland',
  GD: 'Grenada',
  GP: 'Guadeloupe',
  GT: 'Guatemala',
  GN: 'Guinea',
  GW: 'Guinea - Bissau',
  GY: 'Guyana',
  HN: 'Honduras',
  HK: 'Hong Kong SAR China',
  HU: 'Hungary',
  IS: 'Iceland',
  IN: 'India',
  ID: 'Indonesia',
  IE: 'Ireland',
  IL: 'Israel',
  IT: 'Italy',
  JM: 'Jamaica',
  JP: 'Japan',
  JO: 'Jordan',
  KZ: 'Kazakhstan',
  KE: 'Kenya',
  KI: 'Kiribati',
  KW: 'Kuwait',
  KG: 'Kyrgyzstan',
  LA: 'Laos',
  LV: 'Latvia',
  LS: 'Lesotho',
  LI: 'Liechtenstein',
  LT: 'Lithuania',
  LU: 'Luxembourg',
  MK: 'Macedonia',
  MG: 'Madagascar',
  MW: 'Malawi',
  MY: 'Malaysia',
  MV: 'Maldives',
  ML: 'Mali',
  MT: 'Malta',
  MH: 'Marshall Islands',
  MQ: 'Martinique',
  MR: 'Mauritania',
  MU: 'Mauritius',
  YT: 'Mayotte',
  MX: 'Mexico',
  FM: 'Micronesia',
  MD: 'Moldova',
  MC: 'Monaco',
  MN: 'Mongolia',
  ME: 'Montenegro',
  MS: 'Montserrat',
  MA: 'Morocco',
  MZ: 'Mozambique',
  NA: 'Namibia',
  NR: 'Nauru',
  NP: 'Nepal',
  NL: 'Netherlands',
  AN: 'Netherlands Antilles',
  NC: 'New Caledonia',
  NZ: 'New Zealand',
  NI: 'Nicaragua',
  NE: 'Niger',
  NG: 'Nigeria',
  NU: 'Niue',
  NF: 'Norfolk Island',
  NO: 'Norway',
  OM: 'Oman',
  PW: 'Palau',
  PA: 'Panama',
  PG: 'Papua New Guinea',
  PY: 'Paraguay',
  PE: 'Peru',
  PH: 'Philippines',
  PN: 'Pitcairn Islands',
  PL: 'Poland',
  PT: 'Portugal',
  QA: 'Qatar',
  RE: 'Runion',
  RO: 'Romania',
  RU: 'Russia',
  RW: 'Rwanda',
  WS: 'Samoa',
  SM: 'San Marino',
  ST: 'So Tom & Prncipe',
  SA: 'Saudi Arabia',
  SN: 'Senegal',
  RS: 'Serbia',
  SC: 'Seychelles',
  SL: 'Sierra Leone',
  SG: 'Singapore',
  SK: 'Slovakia',
  SI: 'Slovenia',
  SB: 'Solomon Islands',
  SO: 'Somalia',
  ZA: 'South Africa',
  KR: 'South Korea',
  ES: 'Spain',
  LK: 'Sri Lanka',
  SH: 'St. Helena',
  KN: 'St. Kitts & Nevis',
  LC: 'St. Lucia',
  PM: 'St. Pierre & Miquelon',
  VC: 'St. Vincent & Grenadines',
  SR: 'Suriname',
  SJ: 'Svalbard & Jan Mayen',
  SZ: 'Swaziland',
  SE: 'Sweden',
  CH: 'Switzerland',
  TW: 'Taiwan',
  TJ: 'Tajikistan',
  TZ: 'Tanzania',
  TH: 'Thailand',
  TG: 'Togo',
  TO: 'Tonga',
  TT: 'Trinidad & Tobago',
  TN: 'Tunisia',
  TR: 'Turkey',
  TM: 'Turkmenistan',
  TC: 'Turks & Caicos Islands',
  TV: 'Tuvalu',
  UG: 'Uganda',
  UA: 'Ukraine',
  AE: 'United Arab Emirates',
  GB: 'United Kingdom',
  US: 'United States',
  UY: 'Uruguay',
  VU: 'Vanuatu',
  VA: 'Vatican City',
  VE: 'Venezuela',
  VN: 'Vietnam',
  WF: 'Wallis & Futuna',
  YE: 'Yemen',
  ZM: 'Zambia',
  ZW: 'Zimbabwe'
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Currency.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _InvoiceBigNumber = require('./InvoiceBigNumber');

var _InvoiceBigNumber2 = _interopRequireDefault(_InvoiceBigNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var currencies = void 0;

var Currency = function () {
  function Currency(props) {
    _classCallCheck(this, Currency);

    this.decimals = props.decimals || 2;
    this.symbol = props.symbol || '$';
    this.roundMode = props.roundMode || _InvoiceBigNumber2.default.ROUND_HALF_UP;
    this.iso4217 = props.iso4217;
  }

  Currency.getCurrency = function getCurrency(currencyCode) {
    return currencies[currencyCode];
  };

  Currency.setCurrency = function setCurrency(currencyCode, currency) {
    currencies[currencyCode] = currency;
  };

  Currency.prototype.round = function round(amount) {
    return (0, _InvoiceBigNumber.$$)(amount).round(this.decimals, this.roundMode);
  };

  Currency.prototype.toCents = function toCents(amount) {
    return (0, _InvoiceBigNumber.$$)(10).pow(this.decimals).times(amount);
  };

  Currency.prototype.format = function format(amount) {
    return this.symbol + (0, _InvoiceBigNumber.$$)(amount).toFormat(this.decimals, this.roundMode);
  };

  Currency.round = function round(currency, amount) {
    return Currency.getCurrency(currency).round(amount);
  };

  Currency.toCents = function toCents(currency, amount) {
    return Currency.getCurrency(currency).toCents(amount);
  };

  Currency.format = function format(currency, amount) {
    return Currency.getCurrency(currency).format(amount);
  };

  return Currency;
}();

exports.default = Currency;


currencies = {
  AUD: new Currency({
    iso4217: 36
  }),
  GBP: new Currency({
    symbol: '',
    iso4217: 826
  }),
  USD: new Currency({
    iso4217: 840
  }),
  HKD: new Currency({
    iso4217: 344,
    decimals: 1
  }),
  EUR: new Currency({
    symbol: '',
    iso4217: 978
  }),
  CAD: new Currency({
    iso4217: 124
  })
};
},{"./InvoiceBigNumber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceBigNumber.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/CustomAmount.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _InvoiceBigNumber = require('./InvoiceBigNumber');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Container for custom amounts on invoices
 * @class
 *
 * @property {string} label Custom amount label
 * @property {decimal} amount this is an amount object on the server
 *  which has a string for currency, and value
 */

var InvoiceCustomAmount = function () {
  function InvoiceCustomAmount() {
    _classCallCheck(this, InvoiceCustomAmount);
  }

  InvoiceCustomAmount.fromJSON = function fromJSON(json) {
    var customAmount = new InvoiceCustomAmount();
    if (json.label) {
      customAmount.label = json.label;
    }

    if (json.amount) {
      customAmount.amount = (0, _InvoiceBigNumber.$$)(json.amount.value);
    }

    return customAmount;
  };

  InvoiceCustomAmount.prototype.toJSON = function toJSON(currencyCode) {
    var r = {};
    if (this.amount) {
      r.amount = {
        currency: currencyCode,
        value: this.amount
      };
    }
    r.label = this.label;

    return r;
  };

  return InvoiceCustomAmount;
}();

exports.default = InvoiceCustomAmount;
},{"./InvoiceBigNumber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceBigNumber.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Invoice.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _InvoiceBigNumber = require('./InvoiceBigNumber');

var _InvoiceBigNumber2 = _interopRequireDefault(_InvoiceBigNumber);

var _Currency = require('./Currency');

var _Currency2 = _interopRequireDefault(_Currency);

var _CustomAmount = require('./CustomAmount');

var _CustomAmount2 = _interopRequireDefault(_CustomAmount);

var _Item = require('./Item');

var _Item2 = _interopRequireDefault(_Item);

var _MerchantInfo = require('./MerchantInfo');

var _MerchantInfo2 = _interopRequireDefault(_MerchantInfo);

var _BillingInfo = require('./BillingInfo');

var _BillingInfo2 = _interopRequireDefault(_BillingInfo);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _manticoreUtil = require('manticore-util');

var _InvoicingUtil = require('./InvoicingUtil');

var _InvoicingUtil2 = _interopRequireDefault(_InvoicingUtil);

var _Requester = require('./Requester');

var _ShippingInfo = require('./ShippingInfo');

var _ShippingInfo2 = _interopRequireDefault(_ShippingInfo);

var _totalCalculator = require('./totalCalculator');

var _totalCalculator2 = _interopRequireDefault(_totalCalculator);

var _CCInfo = require('./CCInfo');

var _CCInfo2 = _interopRequireDefault(_CCInfo);

var _Payment = require('./Payment');

var _Payment2 = _interopRequireDefault(_Payment);

var _PaymentTerm = require('./PaymentTerm');

var _PaymentTerm2 = _interopRequireDefault(_PaymentTerm);

var _Refund = require('./Refund');

var _Refund2 = _interopRequireDefault(_Refund);

var _Attachment = require('./Attachment');

var _Attachment2 = _interopRequireDefault(_Attachment);

var _InvoiceEnums = require('./InvoiceEnums');

var _InvoiceEnums2 = _interopRequireDefault(_InvoiceEnums);

var _InvoiceMetaData = require('./InvoiceMetaData');

var _InvoiceMetaData2 = _interopRequireDefault(_InvoiceMetaData);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = (0, _manticoreLog2.default)('invoicing');

// TODO: talk about the different dates correctly

function statusFromServer(s) {
  if (!s) {
    return _InvoiceEnums2.default.Status.NEW;
  } else if (_InvoiceEnums2.default.Status[s]) {
    return _InvoiceEnums2.default.Status[s];
  }
  Log.warn('Received unknown server invoice status ' + s);
  return _InvoiceEnums2.default.Status.DRAFT;
}

/**
 * Invoice is the fundamental transaction record for retail payments.
 * It contains header data, such as buyer and seller information and
 * {@link InvoiceItem line items} with unit prices, quantities, etc.
 * @class
 *
 * @property {string} currency The currency for all amounts on this invoice @readonly
 * @property {Date} invoiceDate The date the invoice was 'enabled'. Can be set by user.
 * @property {string} payPalId The id assigned by PayPal for this invoice
 *  (if it has been saved to PayPal at some point) @readonly
 * @property {string} number The unique order number that can be assigned by you
 *  (you must ensure uniqueness) or automatically generated by PayPal
 * @property {Invoice.Status} status The current status of the invoice @readonly
 * @property {string} reference Reference data such as PO Number to be added to invoice.
 *  60 characters max.
 * @property {InvoiceMerchantInfo} merchantInfo Merchant email address and contact
 *  information (email defaults to a PayPal no-reply address)
 * @property {InvoiceBillingInfo} billingInfo Information about the payer or
 *  intended payer of the invoice
 * @property {InvoiceShippingInfo} shippingInfo The shipping address for this
 *  invoice (usually blank in retail use cases)
 * @property {bool} taxInclusive Prices for items on this invoice are INCLUSIVE
 *  of tax - defaults to false.
 * @property {bool} taxCalculatedAfterDiscount Taxes for line items are calculated
 *  after any discounts - defaults to false
 * @property {[InvoiceItem]} items The list of items on this invoice
 * @property {int} itemCount Get the number of items on this invoice @readonly
 * @property {InvoicePaymentTerm} paymentTerms Describes when payment is expected on the
 *  invoice (defaults to DueOnReceipt)
 * @property {decimal} gratuityAmount The amount of gratuity to be applied to the invoice, if any
 * @property {decimal} discountAmount Discount amount applied to the invoice
 * @property {decimal} minimumAmountDue Base object for all financial value related fields
 *  (balance, payment due, etc.)
 * @property {decimal} discountPercentage Discount percentage applied to the invoice
 * @property {string} note A note to the customer
 * @property {decimal} shippingAmount The shipping cost to be applied to the invoice, if any
 * @property {decimal} shippingTaxRate The shipping tax rate, as percent of the
 *  total shipping amount.
 * @property {string} shippingTaxName The name of the shipping tax.
 * @property {string} termsAndConditions General terms of the invoice. 4000 characters max.
 * @property {string} merchantMemo Bookkeeping memo that is private to the merchant.
 *  150 characters max.
 * @property {bool} isDirtyFromServer Has this invoice changed since the last time it was
 *  saved to the server? @readonly
 * @property {bool} hasDetails If false, this invoice doesn't know what items are in its item list.
 *  This can happen when only "summary" information has been fetched from the server
 *  (typically as the result of a search). You can get the total, but items and subtotals
 *  totals aren't available until you call getDetails. @readonly
 * @property {decimal} total The total amount due on the invoice @readonly
 * @property {decimal} subTotal The subtotal of the items on the invoice @readonly
 * @property {decimal} itemTax The total tax on the items (as opposed to the shipping tax,
 *  for example) @readonly
 * @property {decimal} totalDiscount The total amount of discounts applied to the invoice items
 *  and overall invoice @readonly
 * @property {object} taxBreakdown An associative array of tax rate names to the total tax on the
 *  invoice from that rate @readonly
 * @property {bool} allowPartialPayment Indicates if a partial payment is allowed over the invoice.
 *  defaults to false
 * @property {[InvoiceCCInfo]} CCInfo an array of CCInfo Email addresses which should be marked as
 *  Carbon Copy (CC) while the invoice is sent via email. Only email address under participant is
 *  currently supported.
 * @property {[InvoicePayment]} payments an array of payment objects @readonly
 * @property {[InvoiceRefund]} refunds an array of refund objects @readonly
 * @property {decimal} paidAmount payment/refund break up
 * @property {bool} paidAmountIsPayPal indicates whether or not the amount paid was done
 *  so via PayPal
 * @property {decimal} refundedAmount payment/refund break up
 * @property {bool} refundedAmountIsPayPal indicates whether or not the amount refunded
 *  was done so via PayPal
 * @property {string} uri URI of the invoice resource.
 * @property {string} logoURL Full URL of an external image to use as the logo.
 *  4000 characters max.
 * @property {string} additionalData Any miscellaneous invoice data. 4000 characters max.
 * @property {InvoiceCustomAmount} custom Custom amount applied on an invoice. If a label
 *  is included then the amount cannot be empty.
 * @property {InvoiceMetaData} metadata Audit information of the resource. @readonly
 * @property {bool} wasDeleted If true, this invoice was deleted from the server.
 * @property {[InvoiceAttachment]} attachments List of files attached to the invoice.
 * @property {string} templateID Unique identifier id of the template.
 *
 */

var Invoice = function (_EventEmitter) {
  _inherits(Invoice, _EventEmitter);

  // TODO should this constructor also take an object
  // and assume it's from the server? Doesn't really
  // need to be public so that argues not...
  /**
   * Create a new blank invoice.
   * @constructor
   * @param {string} currencyCode currency code identifying the currency for amounts on this invoice
   */

  function Invoice(currencyCode) {
    _classCallCheck(this, Invoice);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.hasDetails = true;
    var useCurrencyCode = currencyCode;
    if (!currencyCode) {
      if (!Invoice.DefaultCurrency) {
        throw new Error(
        /* eslint max-len: 0 */
        'Creating an invoice without a specified currency requires Invoice.DefaultCurrency to be set.');
      }
      useCurrencyCode = Invoice.DefaultCurrency;
    }
    if (!_Currency2.default.getCurrency(useCurrencyCode)) {
      throw new Error('Unsupported currency: ' + useCurrencyCode);
    }
    _this.currency = useCurrencyCode;
    _this.merchantInfo = new _MerchantInfo2.default();
    _this.billingInfo = new _BillingInfo2.default();
    _this.shippingInfo = new _ShippingInfo2.default();
    _this.taxInclusive = false;
    _this.taxCalculatedAfterDiscount = false;
    _this.items = [];
    _this.allowPartialPayment = false;
    _this.CCInfo = [];
    _this.paymentTerms = new _PaymentTerm2.default();
    _this.status = _InvoiceEnums2.default.Status.NEW;

    if (Invoice.DefaultMerchant) {
      _this.merchantInfo.email = Invoice.DefaultMerchant.emailAddress;
      _this.merchantInfo.businessName = Invoice.DefaultMerchant.businessName;
      _this.merchantInfo.address = Invoice.DefaultMerchant.address;
      // TODO copy over more stuff.
    }
    return _this;
  }

  /**
   * Create a new invoice based on an existing invoice as a template.
   * @param {Invoice} invoice which is going to be copied
   * @returns {Invoice} the copy of the invoice
   */


  Invoice.withInvoice = function withInvoice(invoice) {
    (0, _assert2.default)(invoice.hasDetails, 'Can\'t use an invoice as a template if the details aren\'t loaded.');

    var i = new Invoice(invoice.currency);

    i.readJSON((0, _manticoreUtil.deepToJSON)(invoice), true);

    i.status = _InvoiceEnums2.default.Status.NEW;
    i.reference = undefined;
    i.number = undefined;
    i.payPalId = undefined;
    i.metadata = undefined;
    i.paymentTerms = new _PaymentTerm2.default();

    return i;
  };

  /**
   * Create a true copy of an invoice.
   * @returns {Invoice} the copy of the invoice
   */


  Invoice.prototype.copy = function copy() {
    var i = new Invoice(this.currency);
    i.readJSON((0, _manticoreUtil.deepToJSON)(this.toFullJSON()), true);
    i.wasDeleted = this.wasDeleted;
    return i;
  };

  Invoice.prototype.setCleanFromServer = function setCleanFromServer() {
    this._lastKnownServerValue = (0, _manticoreUtil.deepToJSON)(this);
  };

  // ********************************* ITEM LIST **********************************

  /**
   * Adds the specified item to the invoice. If there is an existing matching item
   * on the invoice, we will increment the quantity by the quantity argument.
   * You may pass a negative quantity value to decrement the quantity of an existing item.
   * @param {string} name The name of the item
   * @param {decimal} quantity The quantity of this item - up to three decimals
   * @param {decimal} unitPrice The price of 1 unit of this item
   * @param {string} itemId A unique identifier for this item - not currently
   *  saved to the server but used for local uniqueness such that one line item
   *  per itemId.detailId pair will be stored on an invoice
   * @param {string} detailId A secondary unique identifier (e.g. for item
   *  options or sizes, or to create multiple items on the same invoice
   *  with a single detailId)
   * @returns {InvoiceItem} the item actually stored on the invoice. If you want
   *  to set additional data on the item, you can use this item.
   */


  Invoice.prototype.addItem = function addItem(name, quantity, unitPrice, itemId, detailId) {
    var existing = this.findItem(itemId, detailId);
    if (existing) {
      existing.quantity = existing.quantity.plus(quantity);
      this._totalMayHaveChanged('itemUpdated');
      return existing;
    }
    var newItem = new _Item2.default(name, quantity, unitPrice, itemId, detailId || null);
    this.setupItemListeners(newItem);
    this.items.push(newItem);
    this._totalMayHaveChanged('itemAdded');
    return newItem;
  };

  Invoice.prototype.setupItemListeners = function setupItemListeners(item) {
    var _this2 = this;

    item.on('amountChanged', function () {
      return _this2._totalMayHaveChanged('itemAmountChanged');
    });
    item.on('taxRateChanged', function () {
      return _this2._totalMayHaveChanged('itemTaxRateChanged');
    });
    item.on('discountAmountChanged', function () {
      return _this2._totalMayHaveChanged('itemDiscountAmountChanged');
    });
    item.on('discountPercentageChanged', function () {
      return _this2._totalMayHaveChanged('itemDiscountPercentageChanged');
    });
  };

  /**
   * Remove all items on the invoice
   * @method
   */


  Invoice.prototype.removeAllItems = function removeAllItems() {
    this.items = [];
    this._totalMayHaveChanged('allItemsRemoved');
  };

  /**
   * Remove an item by instance
   * @param {InvoiceItem} item Instance of item to be removed
   * @returns {bool} true if the item was removed from the list
   */


  Invoice.prototype.removeItem = function removeItem(item) {
    if (!item) {
      return false;
    }

    var itemIndex = this.items.indexOf(item);
    if (itemIndex < 0) {
      return false;
    }

    this.items.splice(itemIndex, 1);
    this._totalMayHaveChanged('itemRemoved');
    return true;
  };

  /**
   * Find the InvoiceItem with the specified id and/or detailId
   * @param {string} itemId
   * @param {string} [detailId]
   * @returns {InvoiceItem} The existing item on the invoice, if any
   */


  Invoice.prototype.findItem = function findItem(itemId, detailId) {
    if (!itemId) {
      return null;
    }
    var _detailId = detailId || null;
    var _itemId = itemId;

    if (typeof itemId !== 'string') {
      _detailId = itemId.detailId;
      _itemId = itemId.itemId;
    }
    for (var _iterator = this.items, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var candidate = _ref;

      if (candidate.itemId === _itemId && candidate.detailId === _detailId) {
        return candidate;
      }
    }
    return null;
  };

  /**
   * Get an item by 0-based index
   * @param {int} itemIndex 0-based index of item to retrieve.
   * @returns {InvoiceItem}
   */


  Invoice.prototype.getItem = function getItem(itemIndex) {
    return this.items[itemIndex];
  };

  // ********************************* TOTAL PROPERTIES **********************************

  Invoice.prototype.ensureTotals = function ensureTotals() {
    if (!this._cleanTotals) {
      (0, _totalCalculator2.default)(this);
      this._cleanTotals = true;
    }
  };

  Invoice.prototype._totalMayHaveChanged = function _totalMayHaveChanged(changeEvent, changeDetail) {
    var listeners = this.listeners(Invoice.Event.TotalChanged);
    // If a tree falls in the woods...
    if (listeners && listeners.length) {
      if (!this._total) {
        (0, _totalCalculator2.default)(this);
        this.emit(Invoice.Event.TotalChanged, changeEvent, changeDetail);
      } else {
        var curTotal = new _InvoiceBigNumber2.default(this._total);
        (0, _totalCalculator2.default)(this);
        if (!curTotal.equals(this._total)) {
          this.emit(Invoice.Event.TotalChanged, changeEvent, changeDetail);
        }
      }
    } else {
      this._cleanTotals = false;
    }
  };

  // ********************************* API CALLS **********************************

  /**
   * Update the full invoice from the server, based on its payPalId.
   * @param {Invoice~gotDetails} callback Called with an error
   */

  Invoice.prototype.getDetails = function getDetails(callback) {
    var _this3 = this;

    (0, _assert2.default)(this.payPalId, 'Can\'t get details of an invoice without an id.');
    (0, _assert2.default)(!this.wasDeleted, 'Can\'t get details on an invoice that was deleted.');

    (0, _Requester.request)({
      method: 'GET',
      op: 'invoices/' + this.payPalId
    }, function (error, response) {
      if (!error) {
        _this3.readJSON(response.body, true);
        _this3.setCleanFromServer();
      }
      if (callback) {
        callback(error);
      }
    });
  };

  /**
   * Save the invoice to the PayPal servers.
   * @param {Invoice~saved} callback Called with an error
   */


  Invoice.prototype.save = function save(callback) {
    var _this4 = this;

    (0, _assert2.default)(this.hasDetails, 'Can\'t save an invoice without details');
    (0, _assert2.default)(!this.wasDeleted, 'Can\'t save an invoice that was deleted.');
    if (!this.isDirtyFromServer) {
      if (callback) {
        callback();
      }
      return;
    }
    (0, _Requester.request)({
      // If this invoice has an ID, then it must already be on the server. If it is, update
      // the existing invoice instead of creating a new one.
      method: this.payPalId ? 'PUT' : 'POST',
      op: this.payPalId ? 'invoices/' + this.payPalId : 'invoices',
      body: JSON.stringify(this)
    }, function (error, invoiceResponse) {
      if (!error && invoiceResponse.body) {
        var rz = invoiceResponse.body;
        _this4.payPalId = _this4.payPalId || rz.id;
        _this4.number = _this4.number || rz.number;
        _this4.invoiceDate = _InvoicingUtil2.default.parseServerDateString(rz.invoice_date);
        _this4.status = statusFromServer(rz.status);
        _this4.setCleanFromServer();
      }
      if (callback) {
        callback(error);
      }
    });
  };

  /**
   * Send the invoice. It must have already been saved to the server.
   * @param {bool} shouldNotifyMerchant A flag indicating whether a
   *  copy of the notification has to be sent to the merchant
   * @param {Invoice~sent} callback Called with an error
   */


  Invoice.prototype.send = function send(shouldNotifyMerchant, callback) {
    var _this5 = this;

    // TODO: Once we track whether save is required, save here if it's required.
    (0, _assert2.default)(this.payPalId, 'Can\'t send an invoice without an id.');
    (0, _assert2.default)(!this.wasDeleted, 'Can\'t send an invoice that was deleted.');

    (0, _Requester.request)({
      method: 'POST',
      op: 'invoices/' + this.payPalId + '/send?notify_merchant=' + !!shouldNotifyMerchant
    }, function (error, response) {
      if (!error) {
        _this5.status = _InvoiceEnums2.default.Status.SENT;
      }
      if (callback) {
        callback(error, response);
      }
    });
  };

  /**
   * Delete the invoice from the server. It must have already been saved to the server.
   * @param {Invoice~deleted} callback Called with an error
   */


  Invoice.prototype.deleteFromServer = function deleteFromServer(callback) {
    var _this6 = this;

    (0, _assert2.default)(this.payPalId, 'Can\'t delete an invoice without an id.');
    (0, _assert2.default)(!this.wasDeleted, 'Can\'t delete an invoice that was deleted.');
    (0, _Requester.request)({
      method: 'DELETE',
      op: 'invoices/' + this.payPalId
    }, function (error, response) {
      if (!error) {
        _this6.status = _InvoiceEnums2.default.Status.NEW;
        _this6.wasDeleted = true;
      }
      if (callback) {
        callback(error, response);
      }
    });
  };

  /**
   * Send a reminder about this invoice to its intended recipient
   * @param {InvoiceNotification} notification
   * @param {Invoice~reminded} callback
   */


  Invoice.prototype.remind = function remind(notification, callback) {
    (0, _assert2.default)(this.payPalId, 'Can\'t remind an invoice without an id.');
    (0, _assert2.default)(notification.send_to_payer !== false, 'Can\'t send a reminder that doesn\'t go to the payer.');
    (0, _assert2.default)(!this.wasDeleted, 'Can\'t remind an invoice that was deleted.');
    (0, _Requester.request)({
      method: 'POST',
      op: 'invoices/' + this.payPalId + '/remind',
      body: JSON.stringify(notification)
    }, callback);
  };

  /**
   * Cancel this invoice
   * @param {InvoiceNotification} notification
   * @param {Invoice~cancelled} callback
   */


  Invoice.prototype.cancel = function cancel(notification, callback) {
    var _this7 = this;

    (0, _assert2.default)(this.payPalId, 'Can\'t cancel an invoice without an id.');
    (0, _assert2.default)(!this.wasDeleted, 'Can\'t cancel an invoice that was deleted.');

    (0, _Requester.request)({
      method: 'POST',
      op: 'invoices/' + this.payPalId + '/cancel',
      body: JSON.stringify(notification)
    }, function (error, response) {
      if (!error) {
        _this7.status = _InvoiceEnums2.default.Status.CANCELLED;
      }
      if (callback) {
        callback(error, response);
      }
    });
  };

  /**
   * @param {InvoicePayment} paymentInfo
   * @param {Invoice~paid} callback
   */


  Invoice.prototype.recordPayment = function recordPayment(paymentInfo, callback) {
    var _this8 = this;

    (0, _assert2.default)(this.payPalId, 'Can\'t record payment on an invoice without an id.');
    (0, _assert2.default)(paymentInfo, 'Can\'t record payment on an invoice without paymentInfo.');
    (0, _assert2.default)(!this.wasDeleted, 'Can\'t record payment on an invoice that was deleted.');

    paymentInfo.validate();
    (0, _Requester.request)({
      method: 'POST',
      op: 'invoices/' + this.payPalId + '/record-payment',
      body: JSON.stringify(paymentInfo)
    }, function (error, response) {
      if (!error) {
        if (paymentInfo.type === _InvoiceEnums2.default.PaymentType.EXTERNAL) {
          _this8.status = _InvoiceEnums2.default.Status.MARKED_AS_PAID;
        } else if (paymentInfo.type === _InvoiceEnums2.default.PaymentType.PAYPAL) {
          _this8.status = _InvoiceEnums2.default.Status.PAID;
        }
      }
      if (callback) {
        callback(error, response);
      }
    });
  };

  /**
   * @param {InvoiceRefund} refundInfo
   * @param {Invoice~paid} callback
   */


  Invoice.prototype.recordRefund = function recordRefund(refundInfo, callback) {
    var _this9 = this;

    (0, _assert2.default)(this.payPalId, 'Can\'t record refund on an invoice without an id.');
    (0, _assert2.default)(!this.wasDeleted, 'Can\'t record refund on an invoice that was deleted.');
    (0, _assert2.default)(this.status === _InvoiceEnums2.default.Status.MARKED_AS_PAID || this.status === _InvoiceEnums2.default.Status.PAID || this.status === _InvoiceEnums2.default.Status.PARTIALLY_REFUNDED, 'Can\'t record refund on an invoice that hasn\'t been paid yet.');
    (0, _assert2.default)(refundInfo, 'Can\'t record refund on an invoice without refundInfo.');

    (0, _Requester.request)({
      method: 'POST',
      op: 'invoices/' + this.payPalId + '/record-refund',
      body: JSON.stringify(refundInfo)
    }, function (error, response) {
      if (!error) {
        if (refundInfo.type === _InvoiceEnums2.default.PaymentType.EXTERNAL) {
          _this9.status = _InvoiceEnums2.default.Status.MARKED_AS_REFUNDED;
        } else if (refundInfo.type === _InvoiceEnums2.default.PaymentType.PAYPAL) {
          _this9.status = _InvoiceEnums2.default.Status.REFUNDED;
        }
      }
      if (callback) {
        callback(error, response);
      }
    });
  };

  // **************************** JSON PARSING AND SERIALIZATION *****************************

  Invoice.prototype.toJSON = function toJSON() {
    /* jshint maxcomplexity: false */
    var r = {};
    r.note = this.note;
    r.number = this.number;
    r.invoice_date = _InvoicingUtil2.default.toServerDateString(this.invoiceDate, false);
    r.merchant_info = this.merchantInfo;
    r.shipping_info = this.shippingInfo;
    r.billing_info = [this.billingInfo];
    r.tax_inclusive = this.taxInclusive;
    r.tax_calculated_after_discount = this.taxCalculatedAfterDiscount;
    r.allow_partial_payment = this.allowPartialPayment;
    r.uri = this.uri;
    r.logo_url = this.logoURL;
    r.additional_data = this.additionalData;
    r.attachments = this.attachments;
    r.template_id = this.templateID;

    this._CCInfoToJson(r);

    if (this.termsAndConditions) {
      r.terms = this.termsAndConditions.substring(0, 3999);
    }
    if (this.merchantMemo) {
      r.merchant_memo = this.merchantMemo.substring(0, 149);
    }

    this._shippingToJson(r);

    if (this.minimumAmountDue) {
      r.minimum_amount_due = {
        currency: this.currency,
        value: this.minimumAmountDue
      };
    }

    r.id = this.payPalId;
    if (this.status) {
      r.status = _InvoiceEnums2.default.Status.toString[this.status];
    }
    r.reference = this.reference;

    if (this.gratuityAmount) {
      r.gratuity = {
        currency: this.currency,
        value: this.gratuityAmount
      };
    }
    if (this.discountAmount || this.discountPercentage) {
      r.discount = this.discountObject();
    }
    if (this.paymentTerms.dueDate || this.paymentTerms.paymentTerms) {
      r.payment_term = this.paymentTerms.toJSONHack(r.invoice_date);
    }
    this._itemsToJson(r);

    if (this.custom) {
      r.custom = this.custom.toJSON(this.currency);
    }
    return r;
  };

  // Returns the full JSON, including readonly properties like payments
  // and refunds which should not be sent to the server.


  Invoice.prototype.toFullJSON = function toFullJSON() {
    var r = this.toJSON();
    r.payments = this.payments;
    r.refunds = this.refunds;

    if (this.paidAmount) {
      r.paid_amount = {};
      if (this.paidAmountIsPayPal) {
        r.paid_amount.paypal = {
          currency: this.currency,
          value: this.paidAmount
        };
      } else {
        r.paid_amount.other = {
          currency: this.currency,
          value: this.paidAmount
        };
      }
    }

    if (this.refundedAmount) {
      r.refunded_amount = {};
      if (this.refundedAmountIsPayPal) {
        r.refunded_amount.paypal = {
          currency: this.currency,
          value: this.refundedAmount
        };
      } else {
        r.refunded_amount.other = {
          currency: this.currency,
          value: this.refundedAmount
        };
      }
    }

    // Due to a server bug (see PaymentTerm.js), toJSON does a weird hack with the payment terms.
    // We don't want that in toFullJSON, so this overwrites it.
    // TODO: sto this once server is fixed.
    r.payment_term = this.paymentTerms;

    return r;
  };

  Invoice.prototype._shippingToJson = function _shippingToJson(r) {
    if (this.shippingAmount) {
      r.shipping_cost = {};

      r.shipping_cost.amount = {
        currency: this.currency,
        value: this.shippingAmount
      };
      if (this.shippingTaxRate && !this.shippingTaxRate.isZero()) {
        r.shipping_cost.tax = {
          name: this.shippingTaxName || 'Shipping Tax',
          percent: this.shippingTaxRate
        };
      }
    }
  };

  Invoice.prototype._itemsToJson = function _itemsToJson(r) {
    if (this.items && this.items.length) {
      r.items = [];
      for (var _iterator2 = this.items, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var i = _ref2;

        r.items.push(i.toJSON(this.currency));
      }
    }
  };

  Invoice.prototype._CCInfoToJson = function _CCInfoToJson(r) {
    if (this.CCInfo && this.CCInfo.length) {
      r.cc_info = [];
      for (var _iterator3 = this.CCInfo, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var i = _ref3;

        r.cc_info.push(i.toJSON());
      }
    }
  };

  Invoice.prototype.discountObject = function discountObject() {
    var discount = {};
    if (this.discountAmount) {
      discount.amount = {};
      discount.amount.value = this.discountAmount;
      discount.amount.currency = this.currency;
    } else if (this.discountPercentage) {
      discount.percent = this.discountPercentage;
    }
    return discount;
  };

  /**
   * Construct an invoice from a server response
   * @param serverJSON
   * @param bool hasDetails
   * @private
   */


  Invoice.prototype.readJSON = function readJSON(serverJSON, hasDetails) {
    /* jshint maxcomplexity: false */

    this.invoiceDate = _InvoicingUtil2.default.parseServerDateString(serverJSON.invoice_date);
    this.status = statusFromServer(serverJSON.status);
    this.reference = serverJSON.reference;
    this.number = serverJSON.number;
    this.payPalId = serverJSON.id;
    this.note = serverJSON.note;
    this.merchantInfo.readFromJson(serverJSON.merchant_info);
    this.allowPartialPayment = serverJSON.allow_partial_payment;
    this.uri = serverJSON.uri;
    this.logoURL = serverJSON.logo_url;
    this.additionalData = serverJSON.additional_data;
    this.templateID = serverJSON.template_id;

    this.hasDetails = hasDetails;

    if (serverJSON.metadata) {
      this.metadata = _InvoiceMetaData2.default.fromJSON(serverJSON.metadata);
    }

    if (serverJSON.custom) {
      this.custom = _CustomAmount2.default.fromJSON(serverJSON.custom);
    }

    if (serverJSON.payments) {
      this.payments = [];
      for (var _iterator4 = serverJSON.payments, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref4;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref4 = _i4.value;
        }

        var payment = _ref4;

        this.payments.push(_Payment2.default.readFromJson(payment));
      }
    }
    if (serverJSON.refunds) {
      this.refunds = [];
      for (var _iterator5 = serverJSON.refunds, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
        var _ref5;

        if (_isArray5) {
          if (_i5 >= _iterator5.length) break;
          _ref5 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done) break;
          _ref5 = _i5.value;
        }

        var refund = _ref5;

        this.refunds.push(_Refund2.default.readFromJson(refund));
      }
    }

    if (serverJSON.attachments) {
      this.attachments = [];
      for (var _iterator6 = serverJSON.attachments, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
        var _ref6;

        if (_isArray6) {
          if (_i6 >= _iterator6.length) break;
          _ref6 = _iterator6[_i6++];
        } else {
          _i6 = _iterator6.next();
          if (_i6.done) break;
          _ref6 = _i6.value;
        }

        var a = _ref6;

        this.attachments.push(_Attachment2.default.readFromJson(a));
      }
    }

    if (serverJSON.terms) {
      this.termsAndConditions = serverJSON.terms;
    }
    if (serverJSON.merchant_memo) {
      this.merchantMemo = serverJSON.merchant_memo;
    }
    if (serverJSON.shipping_cost) {
      this.shippingAmount = (0, _InvoiceBigNumber.$$)(serverJSON.shipping_cost.amount.value);
      if (serverJSON.shipping_cost.tax) {
        this.shippingTaxRate = (0, _InvoiceBigNumber.$$)(serverJSON.shipping_cost.tax.percent);
        if (serverJSON.shipping_cost.tax.name) {
          this.shippingTaxName = serverJSON.shipping_cost.tax.name;
        }
      }
    }
    if (serverJSON.minimum_amount_due) {
      this.minimumAmountDue = (0, _InvoiceBigNumber.$$)(serverJSON.minimum_amount_due.value);
    }
    if (serverJSON.refunded_amount) {
      if (serverJSON.refunded_amount.paypal) {
        this.refundedAmount = (0, _InvoiceBigNumber.$$)(serverJSON.refunded_amount.paypal.value);
        this.refundedAmountIsPayPal = true;
      } else if (serverJSON.refunded_amount.other) {
        this.refundedAmount = (0, _InvoiceBigNumber.$$)(serverJSON.refunded_amount.other.value);
        this.refundedAmountIsPayPal = false;
      }
    }
    if (serverJSON.paid_amount) {
      if (serverJSON.paid_amount.paypal) {
        this.paidAmount = (0, _InvoiceBigNumber.$$)(serverJSON.paid_amount.paypal.value);
        this.paidAmountIsPayPal = true;
      } else if (serverJSON.paid_amount.other) {
        this.paidAmount = (0, _InvoiceBigNumber.$$)(serverJSON.paid_amount.other.value);
        this.paidAmountIsPayPal = false;
      }
    }
    if (serverJSON.billing_info && serverJSON.billing_info.length) {
      this.billingInfo.readFromJson(serverJSON.billing_info[0]);
    }
    if (serverJSON.shipping_info) {
      this.shippingInfo.readFromJson(serverJSON.shipping_info);
    }
    if (serverJSON.cc_info) {
      this.CCInfo = [];
      for (var _iterator7 = serverJSON.cc_info, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
        var _ref7;

        if (_isArray7) {
          if (_i7 >= _iterator7.length) break;
          _ref7 = _iterator7[_i7++];
        } else {
          _i7 = _iterator7.next();
          if (_i7.done) break;
          _ref7 = _i7.value;
        }

        var ccinfo = _ref7;

        var invoiceCCInfo = _CCInfo2.default.fromJson(ccinfo);
        this.CCInfo.push(invoiceCCInfo);
      }
    }
    this.items = [];
    if (serverJSON.items) {
      for (var _iterator8 = serverJSON.items, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
        var _ref8;

        if (_isArray8) {
          if (_i8 >= _iterator8.length) break;
          _ref8 = _iterator8[_i8++];
        } else {
          _i8 = _iterator8.next();
          if (_i8.done) break;
          _ref8 = _i8.value;
        }

        var item = _ref8;

        var invoiceItem = _Item2.default.fromJson(item);
        this.setupItemListeners(invoiceItem);
        this.items.push(invoiceItem);
      }
    } else {
      this._total = serverJSON.total_amount ? (0, _InvoiceBigNumber.$$)(serverJSON.total_amount.value) : (0, _InvoiceBigNumber.$$)('0');
    }
    if (serverJSON.gratuity) {
      this.gratuityAmount = (0, _InvoiceBigNumber.$$)(serverJSON.gratuity.value);
    }
    this.paymentTerms = _PaymentTerm2.default.fromJson(serverJSON.payment_term);
    if (serverJSON.hasOwnProperty('tax_inclusive')) {
      this.taxInclusive = serverJSON.tax_inclusive;
    }
    if (serverJSON.hasOwnProperty('tax_calculated_after_discount')) {
      this.taxCalculatedAfterDiscount = serverJSON.tax_calculated_after_discount;
    }
    if (serverJSON.hasOwnProperty('discount')) {
      var discount = serverJSON.discount;
      if (discount.hasOwnProperty('percent')) {
        this.discountPercentage = (0, _InvoiceBigNumber.$$)(discount.percent);
      } else if (serverJSON.discount.hasOwnProperty('amount')) {
        this.discountAmount = (0, _InvoiceBigNumber.$$)(serverJSON.discount.amount.value);
      }
    }
  };

  Invoice.fromJson = function fromJson(serverJSON, hasDetails) {
    if (!serverJSON.total_amount) {
      throw new Error('Invoice JSON has no total_amount.');
    }
    var i = new Invoice(serverJSON.total_amount.currency);
    i.readJSON(serverJSON, hasDetails);
    return i;
  };

  _createClass(Invoice, [{
    key: 'isDirtyFromServer',
    get: function get() {
      return !this._lastKnownServerValue || !(0, _deepEqual2.default)(this._lastKnownServerValue, (0, _manticoreUtil.deepToJSON)(this));
    }
  }, {
    key: 'invoiceDate',
    set: function set(date) {
      this._invoiceDate = date;
    },
    get: function get() {
      return _InvoicingUtil2.default.getDateValue(this._invoiceDate);
    }
  }, {
    key: 'itemCount',
    get: function get() {
      return this.items.length;
    }
  }, {
    key: 'gratuityAmount',
    get: function get() {
      return this._gratuityAmount;
    },
    set: function set(value) {
      this._gratuityAmount = (0, _InvoiceBigNumber.$$)(value);
      this._totalMayHaveChanged('field', 'gratuityAmount');
    }
  }, {
    key: 'discountAmount',
    get: function get() {
      return this._discountAmount;
    },
    set: function set(value) {
      this._discountAmount = (0, _InvoiceBigNumber.$$)(value);
      this._totalMayHaveChanged('field', 'discountAmount');
    }
  }, {
    key: 'discountPercentage',
    get: function get() {
      return this._discountPercentage;
    },
    set: function set(value) {
      this._discountPercentage = (0, _InvoiceBigNumber.$$)(value);
      this._totalMayHaveChanged('field', 'discountPercentage');
    }
  }, {
    key: 'shippingAmount',
    get: function get() {
      return this._shippingAmount;
    },
    set: function set(value) {
      this._shippingAmount = (0, _InvoiceBigNumber.$$)(value);
      this._totalMayHaveChanged('field', 'shippingAmount');
    }
  }, {
    key: 'shippingTaxRate',
    get: function get() {
      return this._shippingTaxRate;
    },
    set: function set(value) {
      this._shippingTaxRate = (0, _InvoiceBigNumber.$$)(value);
      this._totalMayHaveChanged('field', 'shippingTaxRate');
    }
  }, {
    key: 'total',
    get: function get() {
      if (this.hasDetails) {
        this.ensureTotals();
      }
      return this._total;
    }
  }, {
    key: 'subTotal',
    get: function get() {
      (0, _assert2.default)(this.hasDetails, 'Can\'t calculate the subtotal without details');
      this.ensureTotals();
      return this._subTotal;
    }
  }, {
    key: 'itemTax',
    get: function get() {
      (0, _assert2.default)(this.hasDetails, 'Can\'t calculate the item tax without details');
      this.ensureTotals();
      return this._itemTax;
    }
  }, {
    key: 'totalDiscount',
    get: function get() {
      (0, _assert2.default)(this.hasDetails, 'Can\'t calculate the total discount without details');
      this.ensureTotals();
      return this._totalDiscount;
    }
  }, {
    key: 'taxBreakdown',
    get: function get() {
      (0, _assert2.default)(this.hasDetails, 'Can\'t calculate the tax breakdown without details');
      this.ensureTotals();
      return this._taxBreakdown;
    }
  }]);

  return Invoice;
}(_events.EventEmitter);

exports.default = Invoice;


Invoice.Event = {
  TotalChanged: 'totalChanged'
};

// Put any callback definitions before the module exports, and
// reference them in parameter definitions.

/**
 * @callback Invoice~gotDetails
 * @param {PayPalError} error The error that occurred, if any
 */

/**
 * After an attempt has been made to save your invoice to the PayPal servers,
 * the completion handler will be called with the error (if any, or null if not)
 * and the invoice object will be updated appropriately.
 * @callback Invoice~saved
 * @param {PayPalError} error The error that occurred, if any
 */

/**
 * After an attempt has been made to send your invoice, the completion handler
 * will be called with the error (if any, or null if not) and the invoice object
 * will be updated appropriately.
 * @callback Invoice~sent
 * @param {PayPalError} error The error that occurred, if any
 */

/**
 * @callback Invoice~deleted
 * @param {PayPalError} error The error that occurred, if any
 */

/**
 * @callback Invoice~reminded
 * @param {PayPalError} error The error that occurred, if any
 */

/**
 * @callback Invoice~cancelled
 * @param {PayPalError} error The error that occurred, if any
 */

/**
 * @callback Invoice~paid
 * @param {PayPalError} error The error that occurred, if any
 */

/**
 * @callback Invoice~refunded
 * @param {PayPalError} error The error that occurred, if any
 */
},{"./Attachment":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Attachment.js","./BillingInfo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/BillingInfo.js","./CCInfo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/CCInfo.js","./Currency":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Currency.js","./CustomAmount":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/CustomAmount.js","./InvoiceBigNumber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceBigNumber.js","./InvoiceEnums":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceEnums.js","./InvoiceMetaData":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceMetaData.js","./InvoicingUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoicingUtil.js","./Item":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Item.js","./MerchantInfo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/MerchantInfo.js","./Payment":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Payment.js","./PaymentTerm":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/PaymentTerm.js","./Refund":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Refund.js","./Requester":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Requester.js","./ShippingInfo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/ShippingInfo.js","./totalCalculator":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/totalCalculator.js","assert":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/assert/assert.js","deep-equal":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/deep-equal/index.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js","manticore-util":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceActions.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _InvoiceEnums = require('./InvoiceEnums');

var _InvoiceEnums2 = _interopRequireDefault(_InvoiceEnums);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 */

var InvoiceActions = function () {
  function InvoiceActions() {
    _classCallCheck(this, InvoiceActions);
  }

  /**
   * @param {Invoice} invoice
   * @returns {[Invoice.Action]}
   */

  InvoiceActions.availableActions = function availableActions(invoice) {
    var a = _InvoiceEnums2.default.Action;
    switch (invoice.status) {
      case _InvoiceEnums2.default.Status.NEW:
        throw new Error('Actions are undefined for NEW invoices.');
      case _InvoiceEnums2.default.Status.DRAFT:
        return [a.Send, a.Edit, a.Delete, a.RecordPayment, a.Copy];
      case _InvoiceEnums2.default.Status.SENT:
      case _InvoiceEnums2.default.Status.PARTIALLY_PAID:
        return [a.Remind, a.RecordPayment, a.Call, a.Edit, a.Cancel, a.Copy];
      case _InvoiceEnums2.default.Status.PAID:
      case _InvoiceEnums2.default.Status.MARKED_AS_PAID:
      case _InvoiceEnums2.default.Status.PARTIALLY_REFUNDED:
        if (invoice.total === 0) {
          return [a.Call, a.Copy];
        }
        return [a.RecordRefund, a.Call, a.Copy];
      case _InvoiceEnums2.default.Status.CANCELLED:
      case _InvoiceEnums2.default.Status.REFUNDED:
      case _InvoiceEnums2.default.Status.MARKED_AS_REFUNDED:
        return [a.Call, a.Copy];
      case _InvoiceEnums2.default.Status.UNPAID:
        return [a.RecordPayment, a.Edit, a.Cancel, a.Copy];
      default:
        throw new Error('Unknown invoice status');
    }
  };

  return InvoiceActions;
}();

exports.default = InvoiceActions;
},{"./InvoiceEnums":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceEnums.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceBigNumber.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.$$ = $$;

var _bignumber = require('bignumber.js');

var _bignumber2 = _interopRequireDefault(_bignumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InvoiceBigNumber = function (_BN) {
  _inherits(InvoiceBigNumber, _BN);

  function InvoiceBigNumber() {
    _classCallCheck(this, InvoiceBigNumber);

    return _possibleConstructorReturn(this, _BN.apply(this, arguments));
  }

  InvoiceBigNumber.$$ = function $$(a) {
    return a ? new InvoiceBigNumber(a) : null;
  };

  InvoiceBigNumber.prototype.toJSON = function toJSON() {
    return this.toFixed(2);
  };

  return InvoiceBigNumber;
}(_bignumber2.default);

exports.default = InvoiceBigNumber;
function $$(a) {
  return InvoiceBigNumber.$$(a);
}
},{"bignumber.js":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/bignumber.js/bignumber.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceEnums.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _manticoreUtil = require('manticore-util');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// This class is named Invoice for the sake of codegen

var Invoice = function Invoice() {
  _classCallCheck(this, Invoice);
};

/**
 * Valid invoice statuses
 * @enum {int}
 */


exports.default = Invoice;
Invoice.Status = {
  /**
   * The invoice has not been saved to the server
   */
  NEW: 0,
  /**
   * The invoice has been saved to the server
   */
  DRAFT: 1,
  /**
   * The invoice has been sent to the recipient(payer)
   */
  SENT: 2,
  /**
   * The invoice has been paid with a balance affecting instrument like PayPal or CC
   */
  PAID: 3,
  /**
   * The invoice has been marked as paid with a method outside PayPal
   */
  MARKED_AS_PAID: 4,
  /**
   * The invoice has been cancelled
   */
  CANCELLED: 5,
  /**
   * The invoice has been refunded from a balance affecting instrument
   */
  REFUNDED: 6,
  /**
   * The invoice has been partially refunded from a balance affecting instrument
   */
  PARTIALLY_REFUNDED: 7,
  /**
   * The invoice has been marked as refunded with a method outside PayPal
   */
  MARKED_AS_REFUNDED: 8,
  /**
   * The invoice has been partially paid
   */
  PARTIALLY_PAID: 9,
  /*
   * The invoice has been sent with no receipient
   */
  UNPAID: 10
};

Invoice.Status.toString = (0, _manticoreUtil.reverseKeysAndValues)(Invoice.Status);

/**
 * PayPal payment detail indicating whether payment was made in an invoicing flow via PayPal
 * or externally. In the case of the mark-as-paid API, payment type is EXTERNAL and this
 * is what is now supported. The PAYPAL value is provided for backward compatibility.
 * @enum {int}
 */
Invoice.PaymentType = {
  /**
   * The invoice hasn't been paid
   */
  NONE: 0,
  /**
   * The invoice was paid with an external (non-balance-affecting) source
   */
  EXTERNAL: 1,
  /**
   * The invoice was paid with an internal (balance-affecting) source
   */
  PAYPAL: 2
};

Invoice.PaymentType.toString = (0, _manticoreUtil.reverseKeysAndValues)(Invoice.PaymentType);

/**
 * Payment mode or method.
 * @enum {int}
 */
Invoice.PaymentMethod = {
  /**
   * None
   */
  NONE: 0,
  /**
   * Bank Transfer
   */
  BANK_TRANSFER: 1,
  /**
   * Cash
   */
  CASH: 2,
  /**
   * Check
   */
  CHECK: 3,
  /**
   * Credit Card
   */
  CREDIT_CARD: 4,
  /**
   * Debit Card
   */
  DEBIT_CARD: 5,
  /**
   * PayPal
   */
  PAYPAL: 6,
  /**
   * Wire Transfer
   */
  WIRE_TRANSFER: 7,
  /**
   * Other
   */
  OTHER: 8
};

Invoice.PaymentMethod.toString = (0, _manticoreUtil.reverseKeysAndValues)(Invoice.PaymentMethod);

/**
 * Invoice action
 * @enum {int}
 */
Invoice.Action = {
  /**
   * None
   */
  None: 0,
  /**
   * Delete
   */
  Delete: 1,
  /**
   * Send
   */
  Send: 2,
  /**
   * Remind
   */
  Remind: 3,
  /**
   * Record Payment
   */
  RecordPayment: 4,
  /**
   * Record Refund
   */
  RecordRefund: 5,
  /**
   * Copy
   */
  Copy: 6,
  /**
   * Edit
   */
  Edit: 7,
  /**
   * Call
   */
  Call: 8,
  /**
   * Cancel
   */
  Cancel: 9,
  /**
   * More
   */
  More: 10
};
},{"manticore-util":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceListRequest.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @property {int} startIndex A zero-relative index of the merchant's list of invoices
 * @property {int} pageSize The number of invoices to retrieve, beginning with the specified page
 * @property {bool} totalCountRequired Determines if the total count is returned.
 */

var InvoiceListRequest = function InvoiceListRequest() {
  _classCallCheck(this, InvoiceListRequest);

  this.startIndex = 0;
  this.pageSize = 20;
  this.totalCountRequired = true;
};

exports.default = InvoiceListRequest;
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceListResponse.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Invoice = require('./Invoice');

var _Invoice2 = _interopRequireDefault(_Invoice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @property {[Invoice]} invoices All the invoices in the requested page of the invoice list
 * @property {int} totalCount The total number of invoices in the invoice list.
 *  May be 0 if totalCountRequired wasn't specified.
 * @property {bool} hasMore yes if this is not the last page of invoices
 */

var InvoiceListResponse = function () {
  function InvoiceListResponse() {
    _classCallCheck(this, InvoiceListResponse);
  }

  InvoiceListResponse.fromJSON = function fromJSON(json) {
    var r = new InvoiceListResponse();

    r.invoices = [];
    for (var _iterator = json.invoices, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var invoiceJSON = _ref;

      var i = _Invoice2.default.fromJson(invoiceJSON, false);
      i.setCleanFromServer();
      r.invoices.push(i);
    }

    r.totalCount = json.total_count ? json.total_count : 0;

    return r;
  };

  return InvoiceListResponse;
}();

exports.default = InvoiceListResponse;
},{"./Invoice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Invoice.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceMetaData.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _InvoicingUtil = require('./InvoicingUtil');

var _InvoicingUtil2 = _interopRequireDefault(_InvoicingUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Invoice MetaData
 * @class
 * @property {Date} createdDate Date when the resource was created. @readonly
 * @property {string} createdBy Email address of the account that created the resource. @readonly
 * @property {Date} cancelledDate Date when the resource was cancelled. @readonly
 * @property {string} cancelledBy Actor who cancelled the resource. @readonly
 * @property {Date} lastUpdatedDate Date when the resource was last edited. @readonly
 * @property {string} lastUpdatedBy Email address of the account that last
 *  edited the resource. @readonly
 * @property {Date} firstSentDate Date when the resource was first sent. @readonly
 * @property {Date} lastSentDate Date when the resource was last sent. @readonly
 * @property {string} lastSentBy Email address of the account that last sent the resource. @readonly
 * @property {string} payerViewURL URL representing the payer's view of the invoice. @readonly
 */

var InvoiceMetaData = function () {
  function InvoiceMetaData() {
    _classCallCheck(this, InvoiceMetaData);
  }

  InvoiceMetaData.fromJSON = function fromJSON(json) {
    var m = new InvoiceMetaData();

    m.createdBy = json.created_by;
    m.cancelledBy = json.cancelled_by;
    m.lastUpdatedBy = json.last_updated_by;
    m.lastSentBy = json.last_sent_by;
    m.payerViewURL = json.payer_view_url;

    if (json.created_date) {
      m.createdDate = _InvoicingUtil2.default.parseServerDateString(json.created_date);
    }
    if (json.cancelled_date) {
      m.cancelledDate = _InvoicingUtil2.default.parseServerDateString(json.cancelled_date);
    }
    if (json.last_updated_date) {
      m.lastUpdatedDate = _InvoicingUtil2.default.parseServerDateString(json.last_updated_date);
    }
    if (json.first_sent_date) {
      m.firstSentDate = _InvoicingUtil2.default.parseServerDateString(json.first_sent_date);
    }
    if (json.last_sent_date) {
      m.lastSentDate = _InvoicingUtil2.default.parseServerDateString(json.last_sent_date);
    }
    return m;
  };

  _createClass(InvoiceMetaData, [{
    key: 'createdDate',
    set: function set(date) {
      this._createdDate = date;
    },
    get: function get() {
      return _InvoicingUtil2.default.getDateValue(this._createdDate);
    }
  }, {
    key: 'cancelledDate',
    set: function set(date) {
      this._cancelledDate = date;
    },
    get: function get() {
      return _InvoicingUtil2.default.getDateValue(this._cancelledDate);
    }
  }, {
    key: 'firstSentDate',
    set: function set(date) {
      this._firstSentDate = date;
    },
    get: function get() {
      return _InvoicingUtil2.default.getDateValue(this._firstSentDate);
    }
  }, {
    key: 'lastSentDate',
    set: function set(date) {
      this._lastSentDate = date;
    },
    get: function get() {
      return _InvoicingUtil2.default.getDateValue(this._lastSentDate);
    }
  }]);

  return InvoiceMetaData;
}();

exports.default = InvoiceMetaData;
},{"./InvoicingUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoicingUtil.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceTemplatesResponse.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Template = require('./Template');

var _Template2 = _interopRequireDefault(_Template);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @property {InvoiceTemplate} defaultTemplate The default template
 * @property {[InvoiceTemplate]} templates array of all the templates
 */

var InvoiceTemplatesResponse = function () {
  function InvoiceTemplatesResponse() {
    _classCallCheck(this, InvoiceTemplatesResponse);

    this.templates = [];
  }

  InvoiceTemplatesResponse.fromJSON = function fromJSON(json) {
    var r = void 0;

    if (json.templates) {
      r = new InvoiceTemplatesResponse();

      for (var _iterator = json.templates, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var t = _ref;

        if (t.template_data.currencyCode === undefined) {
          // defaulting to USD just as a temporary workaround so I can get
          // all the templates back because the canned ones don't come back
          // with a currency code
          t.template_data.currencyCode = 'USD';
        }

        var temp = _Template2.default.fromJSON(t);
        if (temp !== undefined) {
          r.templates.push(temp);
          if (temp.isDefault === true) {
            r.defaultTemplate = temp;
          }
        }
      }
    }

    return r;
  };

  return InvoiceTemplatesResponse;
}();

exports.default = InvoiceTemplatesResponse;
},{"./Template":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Template.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoicingService.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _BaseService2 = require('./BaseClasses/BaseService');

var _BaseService3 = _interopRequireDefault(_BaseService2);

var _Requester = require('./Requester');

var _InvoiceListResponse = require('./InvoiceListResponse');

var _InvoiceListResponse2 = _interopRequireDefault(_InvoiceListResponse);

var _InvoiceTemplatesResponse = require('./InvoiceTemplatesResponse');

var _InvoiceTemplatesResponse2 = _interopRequireDefault(_InvoiceTemplatesResponse);

var _AccountSummary = require('./AccountSummary');

var _AccountSummary2 = _interopRequireDefault(_AccountSummary);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class
 */

var InvoicingService = function (_BaseService) {
  _inherits(InvoicingService, _BaseService);

  function InvoicingService() {
    _classCallCheck(this, InvoicingService);

    return _possibleConstructorReturn(this, _BaseService.apply(this, arguments));
  }

  /**
   * @param {InvoiceListRequest} params
   * @param {InvoicingService~getInvoices} completionHandler The completion handler
   */

  InvoicingService.getInvoices = function getInvoices(params, completionHandler) {
    var si = params.startIndex;
    var pg = params.pageSize;
    var tot = params.totalCountRequired;

    (0, _Requester.request)({
      method: 'GET',
      op: 'invoices?page=' + si + '&page_size=' + pg + '&total_count_required=' + tot
    }, function (error, response) {
      if (error) {
        completionHandler(error);
      } else {
        var r = _InvoiceListResponse2.default.fromJSON(response.body);
        r.hasMore = params.startIndex + params.pageSize < r.totalCount;
        completionHandler(error, r);
      }
    });
  };

  /**
   * Search for a specific invoice or invoices by passing a search object that
   * specifies your * search criteria.
   * @param {InvoiceSearchRequest} params
   * @param {InvoicingService~searchInvoices} completionHandler The completion handler
   */


  InvoicingService.searchInvoices = function searchInvoices(params, completionHandler) {
    (0, _Requester.request)({
      method: 'POST',
      op: 'search',
      body: JSON.stringify(params)
    }, function (error, response) {
      if (error) {
        completionHandler(error);
      } else {
        var r = _InvoiceListResponse2.default.fromJSON(response.body);
        r.hasMore = params.startIndex + params.pageSize < r.totalCount;
        completionHandler(error, r);
      }
    });
  };

  /**
   * @param {InvoicingService~getNextInvoiceNumber} completionHandler The completion handler
   */


  InvoicingService.getNextInvoiceNumber = function getNextInvoiceNumber(completionHandler) {
    (0, _Requester.request)({
      method: 'POST',
      op: 'invoices/next-invoice-number'
    }, function (error, response) {
      if (error) {
        completionHandler(error);
      } else {
        var nextInvNum = response.body.number;
        completionHandler(error, nextInvNum);
      }
    });
  };

  /**
   * @param {InvoicingService~getAccountSummary} completionHandler The completion handler
   */


  InvoicingService.getAccountSummary = function getAccountSummary(completionHandler) {
    var _this2 = this;

    // TODO: Should we expose something closer to the actual API? Right now we're returning data
    // specifically for the PPB app.

    var firstError = void 0;
    var secondError = void 0;
    var firstResponse = void 0;
    var secondResponse = void 0;

    var maybeContinue = function maybeContinue() {
      if ((firstError || firstResponse) && (secondError || secondResponse)) {
        _this2.continueGetAccountSummary(firstError, firstResponse, secondError, secondResponse, completionHandler);
      }
    };

    (0, _Requester.request)({
      method: 'GET',
      op: 'summaries?overdue=false'
    }, function (error, response) {
      firstError = error;
      firstResponse = response;
      maybeContinue();
    });

    (0, _Requester.request)({
      method: 'GET',
      op: 'summaries?overdue=true'
    }, function (error, response) {
      secondError = error;
      secondResponse = response;
      maybeContinue();
    });
  };

  InvoicingService.continueGetAccountSummary = function continueGetAccountSummary(firstError, firstResponse, secondError, secondResponse, completionHandler) {
    var error = firstError || secondError;
    if (error) {
      completionHandler(error);
    }
    completionHandler(error, new _AccountSummary2.default(firstResponse.body, secondResponse.body));
  };

  /**
   * @param {InvoicingService~getTemplates} completionHandler The completion handler
   */


  InvoicingService.getTemplates = function getTemplates(completionHandler) {
    (0, _Requester.request)({
      method: 'GET',
      op: 'templates'
    }, function (error, response) {
      if (error) {
        completionHandler(error);
      } else {
        completionHandler(error, _InvoiceTemplatesResponse2.default.fromJSON(response.body));
      }
    });
  };

  return InvoicingService;
}(_BaseService3.default);

/**
 * @callback InvoicingService~getInvoices
 * @param {PayPalError} error The error that occurred, if any
 * @param {InvoiceListResponse} response The server response
 */

/**
 * @callback InvoicingService~searchInvoices
 * @param {PayPalError} error The error that occurred, if any
 * @param {InvoiceListResponse} response The server response
 */

/**
 * @callback InvoicingService~getAccountSummary
 * @param {PayPalError} error The error that occurred, if any
 * @param {AccountSummary} response The server response
 */

/**
 * @callback InvoicingService~getTemplates
 * @param {PayPalError} error The error that occurred, if any
 * @param {InvoiceTemplatesResponse} response The server response
 */

/**
 * @callback InvoicingService~getNextInvoiceNumber
 * @param {PayPalError} error The error that occurred, if any
 * @param {string} response The server response
 */


exports.default = InvoicingService;
},{"./AccountSummary":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/AccountSummary.js","./BaseClasses/BaseService":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/BaseClasses/BaseService.js","./InvoiceListResponse":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceListResponse.js","./InvoiceTemplatesResponse":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceTemplatesResponse.js","./Requester":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Requester.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoicingUtil.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var InvoicingUtils = function () {
  function InvoicingUtils() {
    _classCallCheck(this, InvoicingUtils);
  }

  InvoicingUtils.parseServerDateString = function parseServerDateString(date) {
    if (!date) {
      return date;
    }
    // Sometimes the date string doesn't have a time. In that case, the first replace will add one.
    var _date = date.replace(/(\d{4}-\d{2}-\d{2}) (PST|PDT)/, '$1 23:59:59 $2');
    _date = _date.replace('PST', '-0800').replace('PDT', '-0700');
    return _moment2.default.parseZone(_date, 'YYYY-MM-DD hh:mm:ss Z');
  };

  InvoicingUtils.toServerDateString = function toServerDateString(date, shouldIncludeTime) {
    if (!date) {
      return date;
    }
    var _date = (0, _moment2.default)(date);
    // It's important that we render dates into PDT instead of PST.
    // If we receive a date in PDT and then render it into PST, we'll assume the incoming date is at
    // time 00:00:00, which then ends up being in the previous day PST. Going from PST->PDT, the
    // offset goes the other way, so the day remains the same.
    //
    // Also, some invoicing fields won't accept the hh:mm:ss timestamp,
    // but it's required for others.  So, we are required to make you specify whether
    // you want the time or not.
    //
    // All of this could have been avoided by choosing a non-ridiculous date format, but \_()_/.

    if (shouldIncludeTime) {
      _date.utcOffset(-480);
      return _date.format('YYYY-MM-DD HH:mm:ss') + ' PST';
    }

    // This is a working solution for converting date into PST formats
    // The time stamp applied is PST/PDT EOD. This will set the correct date when parsed from server
    // See function parseServerDateString.
    var offset = _date.utcOffset();
    if (offset > -480) {
      _date.subtract(1, 'days');
    }
    return _date.format('YYYY-MM-DD') + ' PST';
  };

  InvoicingUtils.getDateValue = function getDateValue(date) {
    return date && date.constructor === (0, _moment2.default)().constructor ? date.toDate() : date;
  };

  return InvoicingUtils;
}();

exports.default = InvoicingUtils;
},{"moment":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/moment/moment.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Item.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _InvoiceBigNumber = require('./InvoiceBigNumber');

var _events = require('events');

var _Currency = require('./Currency');

var _Currency2 = _interopRequireDefault(_Currency);

var _manticoreUtil = require('manticore-util');

var _InvoicingUtil = require('./InvoicingUtil');

var _InvoicingUtil2 = _interopRequireDefault(_InvoicingUtil);

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var staticIdAllocator = 1;
var ZERO = (0, _InvoiceBigNumber.$$)(0);

// TODO refactor tax rates into a real object?

/**
 * A line item on an invoice. Can be positive, negative, or zero total/unit price.
 * See https://cms.paypal.com/cms_content/US/en_US/files/developer/PP_InvoicingAPIGuide.pdf
 * for details on field length restrictions and formats.
 * @class
 * @property {string} name The name of this item
 * @property {string} itemDescription A description for this line item
 * @property {decimal} quantity The quantity of this item - up to three decimals
 * @property {decimal} unitPrice The price of 1 unit of this item
 * @property {int} itemId A unique identifier for this item - not currently saved to the
 *  server but used for local uniqueness such that one line item per itemId.detailId pair
 *  will be stored on an invoice @readonly
 * @property {string} detailId A secondary unique identifier (e.g. for item options
 *  or sizes, or to create multiple items on the same invoice with a single detailId) @readonly
 * @property {string} taxName The name for the tax rate applied to this item, if any
 * @property {decimal} taxRate The tax rate to be applied to this item. If non-zero,
 *  the taxName must also be set.
 * @property {decimal} discountPercentage A percentage discount for this line item
 * @property {decimal} discountAmount A flat amount discount for this line item
 * @property {Date} date Date on which the item or service was provided
 * @property {string} imageURL Image url of the item. 4000 characters max.
 * @property {string} unitOfMeasure Unit of measure of the item being invoiced.
 *
 */

var InvoiceItem = function (_EventEmitter) {
  _inherits(InvoiceItem, _EventEmitter);

  /**
   * Create a new invoice item with the required information (detailId is optional).
   * @constructor
   * @private
   * @param {string} name The name of the item
   * @param {decimal} quantity The quantity of this item - up to three decimals
   * @param {decimal} unitPrice The price of 1 unit of this item
   * @param {string} itemId A unique identifier for this item - not currently saved
   *  to the server but used for local
   * uniqeuness such that one line item per itemId.detailId pair will be stored on an invoice
   * @param {string} detailId A secondary unique identifier (e.g. for item options
   *  or sizes, or to create multiple items on the same invoice with a single detailId)
   */

  function InvoiceItem(name, quantity, unitPrice, itemId, detailId) {
    _classCallCheck(this, InvoiceItem);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.name = name;
    if (!quantity || !name || !unitPrice) {
      throw new Error('You must specify a quantity, name and unitPrice when adding an item.');
    }
    // The server can return item quantities with over 15 digits, in which case bignumber errors.
    // We don't really care about the 16th digit, so convert to a string so
    // bignumber doesn't complain.
    _this._quantity = (0, _InvoiceBigNumber.$$)(String(quantity));
    _this.unitPrice = (0, _InvoiceBigNumber.$$)(unitPrice || 0);
    _this.itemId = itemId || staticIdAllocator++;
    _this.detailId = detailId || null;
    return _this;
  }

  /**
   * Create a true copy of an item.
   * @returns {InvoiceItem} the copy of the item
   */


  InvoiceItem.prototype.copy = function copy() {
    var i = InvoiceItem.fromJson((0, _manticoreUtil.deepToJSON)(this.toJSON()));
    return i;
  };

  /**
   * Do simple math without discounts for this line item
   * @private
   */


  InvoiceItem.prototype.subtotalForInvoice = function subtotalForInvoice(invoice) {
    var itemPrice = this.quantity.times(this.unitPrice || ZERO);
    return _Currency2.default.round(invoice.currency, itemPrice);
  };

  /**
   * Do the simple math for this line item
   * @private
   */


  InvoiceItem.prototype.totalForInvoice = function totalForInvoice(invoice) {
    var itemPrice = this.subtotalForInvoice(invoice);
    if (this.discountPercentage) {
      var discount = _Currency2.default.round(invoice.currency, itemPrice.times(this.discountPercentage / 100));
      itemPrice = itemPrice.minus(discount);
    } else if (this.discountAmount) {
      itemPrice = itemPrice.minus(this.discountAmount);
    }
    return _Currency2.default.round(invoice.currency, itemPrice);
  };

  /**
   * Read the properties of this object from json, transforming to numbers where appropriate
   * @param json
   * @private
   */

  InvoiceItem.fromJson = function fromJson(json) {
    /* jshint maxcomplexity: false */
    var item = new InvoiceItem(json.name, json.quantity, json.unit_price.value, json.itemId || staticIdAllocator++, json.detailId);
    if (json.description) {
      item.itemDescription = json.description;
    }
    if (json.unit_price) {
      item.unitPrice = json.unit_price.value;
    }
    if (json.tax) {
      item.taxName = json.tax.name;
      item.taxRate = (0, _InvoiceBigNumber.$$)(json.tax.percent);
    }
    if (json.discount) {
      if (json.discount.amount) {
        item.discountAmount = (0, _InvoiceBigNumber.$$)(json.discount.amount.value);
      }
      if (json.discount.percent) {
        item.discountPercentage = (0, _InvoiceBigNumber.$$)(json.discount.percent);
      }
    }
    if (json.date) {
      item.date = _InvoicingUtil2.default.parseServerDateString(json.date);
    }

    item.imageURL = json.image_url;
    item.unitOfMeasure = json.unit_of_measure;

    return item;
  };

  InvoiceItem.prototype.toJSON = function toJSON(currency) {
    var json = {
      name: this.name,
      description: this.itemDescription,
      quantity: this.quantity.toNumber(),
      image_url: this.imageURL,
      unit_of_measure: this.unitOfMeasure
    };
    if (this.date) {
      json.date = _InvoicingUtil2.default.toServerDateString(this.date, false);
    }
    json.unit_price = {
      value: this.unitPrice,
      currency: currency
    };
    var tempDiscount = {};
    if (this.discountPercentage > 0) {
      tempDiscount.percent = this.discountPercentage;
    } else if (this.discountAmount > 0) {
      tempDiscount.amount = {
        value: this.discountAmount,
        currency: currency
      };
    }
    if (tempDiscount.amount || tempDiscount.percent) {
      json.discount = tempDiscount;
    }

    if (this.taxRate && this.taxName) {
      json.tax = {
        percent: this.taxRate,
        name: this.taxName
      };
    }
    return json;
  };

  /**
   * check if an item is equal to this
   * @param {InvoiceItem} item to which this one will be compared
   * @returns {bool} are they equal
   */


  InvoiceItem.prototype.isEqualToItem = function isEqualToItem(item) {
    return (0, _deepEqual2.default)((0, _manticoreUtil.deepToJSON)(this), (0, _manticoreUtil.deepToJSON)(item));
  };

  _createClass(InvoiceItem, [{
    key: 'quantity',
    get: function get() {
      return this._quantity;
    },
    set: function set(v) {
      this._quantity = (0, _InvoiceBigNumber.$$)(v);
      this.emit('amountChanged', 'quantity');
    }
  }, {
    key: 'taxRate',
    get: function get() {
      return this._taxRate;
    },
    set: function set(v) {
      this._taxRate = (0, _InvoiceBigNumber.$$)(v);
      this.emit('taxRateChanged');
      this.emit('changed');
    }
  }, {
    key: 'discountAmount',
    get: function get() {
      return this._discountAmount;
    },
    set: function set(v) {
      this._discountAmount = (0, _InvoiceBigNumber.$$)(v);
      this.emit('discountAmountChanged');
      this.emit('changed');
    }
  }, {
    key: 'discountPercentage',
    get: function get() {
      return this._discountPercentage;
    },
    set: function set(v) {
      this._discountPercentage = (0, _InvoiceBigNumber.$$)(v);
      this.emit('discountPercentageChanged');
      this.emit('changed');
    }
  }, {
    key: 'unitPrice',
    get: function get() {
      return this._unitPrice;
    },
    set: function set(v) {
      this._unitPrice = (0, _InvoiceBigNumber.$$)(v);
      this.emit('amountChanged', 'unitPrice');
    }
  }, {
    key: 'date',
    set: function set(date) {
      this._date = date;
    },
    get: function get() {
      return _InvoicingUtil2.default.getDateValue(this._date);
    }
  }]);

  return InvoiceItem;
}(_events.EventEmitter);

/**
 * The amount represented by this line item has changed.
 *
 * @event InvoiceItem#amountChanged
 * @param {string} field The field that has changed.
 */


exports.default = InvoiceItem;
},{"./Currency":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Currency.js","./InvoiceBigNumber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceBigNumber.js","./InvoicingUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoicingUtil.js","deep-equal":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/deep-equal/index.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore-util":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/MerchantInfo.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Address = require('./Address');

var _Address2 = _interopRequireDefault(_Address);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Container for information about the merchant requesting payment on an invoice
 * @class
 * @property {string} email The email address of the
 *  merchant @required @length(1,260) @format(email)
 * @property {string} firstName The first name of the merchant @length(,30)
 * @property {string} lastName The last name of the merchant @length(,30)
 * @property {InvoiceAddress} address The address of the merchant
 * @property {string} businessName The business name of the merchant
 * @property {string} phone The phone number of the merchant
 * @property {string} fax The fax number of the merchant
 * @property {string} website The URL of the merchant website @format{url}
 * @property {string} taxId The tax identifier for the merchant
 * @property {string} additionalInfoLabel Option to provide a label to the
 *  additional_info field. 40 characters max.
 * @property {string} additionalInfo Option to display additional information
 *  such as business hours. 40 characters max.
 */

var InvoiceMerchantInfo = function () {
  function InvoiceMerchantInfo() {
    _classCallCheck(this, InvoiceMerchantInfo);

    this.address = new _Address2.default();
  }

  InvoiceMerchantInfo.prototype.readFromJson = function readFromJson(json) {
    if (json) {
      this.address.readFromJson(json.address);

      if (json.address) {
        this.address = new _Address2.default();
        this.address.readFromJson(json.address);
      }
      this.email = json.email;
      this.phone = json.phone;
      this.fax = json.fax;
      this.website = json.website;
      this.firstName = json.first_name;
      this.lastName = json.last_name;
      this.businessName = json.business_name;
      this.taxId = json.tax_id;
      this.additionalInfo = json.additional_info;
      this.additionalInfoLabel = json.additional_info_label;
    }
  };

  InvoiceMerchantInfo.prototype.toJSON = function toJSON() {
    var r = {};
    r.email = this.email;
    r.phone = this.phone;
    r.fax = this.fax;
    r.website = this.website;
    r.address = this.address;
    r.first_name = this.firstName;
    r.last_name = this.lastName;
    r.business_name = this.businessName;
    r.tax_id = this.taxId;
    r.additional_info = this.additionalInfo;
    r.additional_info_label = this.additionalInfoLabel;
    return r;
  };

  return InvoiceMerchantInfo;
}();

exports.default = InvoiceMerchantInfo;
},{"./Address":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Address.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Notification.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * An Invoice notification
 * @class
 * @property {string} subject Subject of the notification
 * @property {string} note Note to the payer
 * @property {bool} shouldSendToMerchant A flag indicating whether a copy of the
 *  email has to be sent to the merchant
 * @property {bool} shouldSendToPayer A flag indicating whether a copy of the email
 *  has to be sent to the payer
 * @property {string} ccEmails If the invoice has CCs associated with it, this field
 *  can be used to specify only certain set of CC emails for which notification is sent.
 *
 */

var InvoiceNotification = function () {
  function InvoiceNotification(subject, note, shouldSendToMerchant, ccEmails, shouldSendToPayer) {
    _classCallCheck(this, InvoiceNotification);

    this.subject = subject;
    this.note = note;
    this.shouldSendToMerchant = shouldSendToMerchant;
    this.shouldSendToPayer = shouldSendToPayer;
    this.ccEmails = ccEmails;
  }

  InvoiceNotification.prototype.toJSON = function toJSON() {
    var json = {};
    json.subject = this.subject;
    json.note = this.note;
    json.send_to_merchant = this.shouldSendToMerchant;
    json.send_to_payer = this.shouldSendToPayer;
    json.cc_emails = this.ccEmails;
    return json;
  };

  return InvoiceNotification;
}();

exports.default = InvoiceNotification;
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Payment.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _InvoiceEnums = require('./InvoiceEnums');

var _InvoiceEnums2 = _interopRequireDefault(_InvoiceEnums);

var _InvoicingUtil = require('./InvoicingUtil');

var _InvoicingUtil2 = _interopRequireDefault(_InvoicingUtil);

var _InvoiceBigNumber = require('./InvoiceBigNumber');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Container for information about the payment on an invoice
 * @class
 * @property {Invoice.PaymentType} type PayPal payment detail indicating whether
 *  payment was made in an invoicing flow via PayPal or externally. @readonly
 * @property {string} transactionID PayPal payment transaction id. Mandatory
 *  field in case the type value is PAYPAL. @readonly
 * @property {string} transactionType type of the transaction @readonly
 * @property {Date} date date when the invoice was paid
 * @property {Invoice.PaymentMethod} method payment mode or method this is mandatory
 * @property {string} note optional note associated with the payment
 * @property {decimal} amount this is an amount object on the server which
 *  has a string for currency, and value
 * @property {string} currency used with the amount
 **/

var InvoicePayment = function () {
  function InvoicePayment() {
    _classCallCheck(this, InvoicePayment);

    this.type = _InvoiceEnums2.default.PaymentType.EXTERNAL;
    this.transactionId = undefined;
    this.transactionType = undefined;
    this.date = undefined;
    this.note = undefined;
    this.method = undefined;
    this.currency = undefined;
    this.amount = undefined;
  }

  InvoicePayment.readFromJson = function readFromJson(json) {
    var payment = new InvoicePayment();

    if (json) {
      payment.type = json.type;
      payment.transactionID = json.transaction_id;
      payment.transactionType = json.transaction_type;
      payment.date = _InvoicingUtil2.default.parseServerDateString(json.date);
      payment.method = json.method;
      payment.note = json.note;
    }

    if (json.amount) {
      payment.amount = (0, _InvoiceBigNumber.$$)(json.amount.value);
      payment.currency = json.amount.currency;
    }

    return payment;
  };

  InvoicePayment.prototype.toJSON = function toJSON() {
    var r = {};

    if (this.amount) {
      r.amount = {};
      r.amount = {
        currency: this.currency,
        value: this.amount
      };
    }

    r.method = _InvoiceEnums2.default.PaymentMethod.toString[this.method];
    r.date = _InvoicingUtil2.default.toServerDateString(this.date, true);
    r.note = this.note;

    return r;
  };

  // Assert if we know the server is going to reject this as the body of record-payment.


  InvoicePayment.prototype.validate = function validate() {
    if (!this.type) {
      (0, _assert2.default)(false, 'InvoicePaymentInfo must have a payment type.');
    }
    switch (this.type) {
      case _InvoiceEnums2.default.PaymentType.EXTERNAL:
        (0, _assert2.default)(this.method, 'InvoicePaymentInfo with payment type=EXTERNAL must have a method.');
        break;
      case _InvoiceEnums2.default.PaymentType.PAYPAL:
        (0, _assert2.default)(this.transactionId, 'InvoicePaymentInfo with payment type=PAYPAL must have a method.');
        throw new Error('The invoicing service doesn\'t currently support setting the payment type to PAYPAL :(.');
      default:
        throw new Error('Unknown payment type');
    }
  };

  return InvoicePayment;
}();

exports.default = InvoicePayment;
},{"./InvoiceBigNumber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceBigNumber.js","./InvoiceEnums":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceEnums.js","./InvoicingUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoicingUtil.js","assert":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/assert/assert.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/PaymentTerm.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _manticoreUtil = require('manticore-util');

var _InvoicingUtil = require('./InvoicingUtil');

var _InvoicingUtil2 = _interopRequireDefault(_InvoicingUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains information about the due date / payment terms of an invoice.
 * @class
 * @property {InvoicePaymentTerm.PaymentTerms} paymentTerms Describes when
 *  payment is expected on the invoice. Setting this to something truthy will clear dueDate.
 * @property {Date} dueDate A specific date on which payment is due. Setting this
 *  to something truthy will clear paymentTerms.
 **/

var InvoicePaymentTerm = function () {
  function InvoicePaymentTerm() {
    _classCallCheck(this, InvoicePaymentTerm);

    this.reset();
  }

  InvoicePaymentTerm.prototype.reset = function reset() {
    this._paymentTerms = InvoicePaymentTerm.PaymentTerms.NoPaymentTerms;
    this._dueDate = undefined;
  };

  InvoicePaymentTerm.fromJson = function fromJson(json) {
    var r = new InvoicePaymentTerm();
    if (json) {
      // Sometimes the server will send us a term_type AND a due_date. In this case, the due
      // date is just bogus, so setting the paymentTerms here will override it.
      r.dueDate = _InvoicingUtil2.default.parseServerDateString(json.due_date);
      r.paymentTerms = InvoicePaymentTerm.PaymentTerms.fromServer[json.term_type];
    } else {
      r.reset();
    }
    return r;
  };

  InvoicePaymentTerm.prototype.toJSON = function toJSON() {
    var r = {};

    if (this.dueDate) {
      r.due_date = _InvoicingUtil2.default.toServerDateString(this.dueDate, false);
    } else if (this.paymentTerms) {
      r.term_type = InvoicePaymentTerm.PaymentTerms.toServer[this.paymentTerms];
    }

    return r;
  };

  // There is a bug on the server where an invoice with the same invoice_date and due_date
  // will fail to validate. So, if those dates would be the same, use DUE_ON_RECEIPT instead.
  // TODO: stop this once the server is fixed.


  InvoicePaymentTerm.prototype.toJSONHack = function toJSONHack(invoiceDateString) {
    var r = this.toJSON();

    if (r.due_date === invoiceDateString) {
      r.due_date = undefined;
      var dor = InvoicePaymentTerm.PaymentTerms.DueOnReceipt;
      r.term_type = InvoicePaymentTerm.PaymentTerms.toServer[dor];
    }

    return r;
  };

  _createClass(InvoicePaymentTerm, [{
    key: 'paymentTerms',
    set: function set(t) {
      if (t) {
        this.reset();
      }
      this._paymentTerms = t;
    },
    get: function get() {
      return this._paymentTerms;
    }
  }, {
    key: 'dueDate',
    set: function set(d) {
      if (d) {
        this.reset();
      }
      this._dueDate = d;
    },
    get: function get() {
      return _InvoicingUtil2.default.getDateValue(this._dueDate);
    }
  }]);

  return InvoicePaymentTerm;
}();

/**
 * A payment term describes when payment is expected in relation to the date it is sent
 * @enum {int}
 */


exports.default = InvoicePaymentTerm;
InvoicePaymentTerm.PaymentTerms = {
  /**
   * The due date does not come from payment terms
   */
  NoPaymentTerms: 0,
  /**
   * The invoice is due immediately upon receipt of the invoice
   */
  DueOnReceipt: 1,
  /**
   * The payment is due 10 days after receipt of the invoice
   */
  Net10: 2,
  /**
   * The payment is due 15 days after receipt of the invoice
   */
  Net15: 3,
  /**
   * The payment is due 30 days after receipt of the invoice
   */
  Net30: 4,
  /**
   * The payment is due 45 days after receipt of the invoice
   */
  Net45: 5,
  /**
   * The payment is due 60 days after receipt of the invoice
   */
  Net60: 6,
  /**
   * The payment is due 90 days after receipt of the invoice
   */
  Net90: 7
};

InvoicePaymentTerm.PaymentTerms.fromServer = {
  DUE_ON_RECEIPT: InvoicePaymentTerm.PaymentTerms.DueOnReceipt,
  NET_10: InvoicePaymentTerm.PaymentTerms.Net10,
  NET_15: InvoicePaymentTerm.PaymentTerms.Net15,
  NET_30: InvoicePaymentTerm.PaymentTerms.Net30,
  NET_45: InvoicePaymentTerm.PaymentTerms.Net45,
  NET_60: InvoicePaymentTerm.PaymentTerms.Net60,
  NET_90: InvoicePaymentTerm.PaymentTerms.Net90
};

InvoicePaymentTerm.PaymentTerms.toServer = (0, _manticoreUtil.reverseKeysAndValues)(InvoicePaymentTerm.PaymentTerms.fromServer);
},{"./InvoicingUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoicingUtil.js","manticore-util":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Refund.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _InvoiceBigNumber = require('./InvoiceBigNumber');

var _InvoiceEnums = require('./InvoiceEnums');

var _InvoiceEnums2 = _interopRequireDefault(_InvoiceEnums);

var _InvoicingUtil = require('./InvoicingUtil');

var _InvoicingUtil2 = _interopRequireDefault(_InvoicingUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Container for information about a refund on an invoice
 * @class
 * @property {string} type PayPal refund type indicating whether refund was
 *  done in invoicing flow via PayPal or externally. @readonly
 * @property {Date} date date when the invoice was paid
 * @property {string} note optional note associated with the payment
 * @property {decimal} amount this is an amount object on the server which
 *  has a string for currency, and value
 * @property {string} currency used with the amount
 **/

var InvoiceRefund = function () {
  function InvoiceRefund() {
    _classCallCheck(this, InvoiceRefund);

    // Default payment type to EXTERNAL since it's the only one the server actually
    // supports right now.
    this.type = _InvoiceEnums2.default.PaymentType.EXTERNAL;
    this.date = undefined;
    this.note = undefined;
    this.currency = undefined;
    this.amount = undefined;
  }

  InvoiceRefund.readFromJson = function readFromJson(json) {
    var refund = new InvoiceRefund();

    if (json) {
      refund.type = json.type;
      refund.date = _InvoicingUtil2.default.parseServerDateString(json.date);
      refund.note = json.note;
    }
    if (json.amount) {
      refund.amount = (0, _InvoiceBigNumber.$$)(json.amount.value);
      refund.currency = json.amount.currency;
    }

    return refund;
  };

  InvoiceRefund.prototype.toJSON = function toJSON() {
    var r = {};
    if (this.amount) {
      r.amount = {};
      r.amount = {
        currency: this.currency,
        value: this.amount
      };
    }

    r.date = _InvoicingUtil2.default.toServerDateString(this.date, true);
    r.note = this.note;

    return r;
  };

  return InvoiceRefund;
}();

exports.default = InvoiceRefund;
},{"./InvoiceBigNumber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceBigNumber.js","./InvoiceEnums":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceEnums.js","./InvoicingUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoicingUtil.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Requester.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.request = request;

var _manticoreUtil = require('manticore-util');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } // The main purpose of this file is to avoid a circular dependency between
// Invoice and InvoicingService, since Invoice needs to make requests and
// the service needs to construct Invoices based on server responses.


var InvoicingRequester = function () {
  function InvoicingRequester() {
    _classCallCheck(this, InvoicingRequester);
  }

  InvoicingRequester.request = function request(opts, cb) {
    if (!InvoicingRequester.api) {
      throw new Error('There is no service interface. Please set the InvoicingRequester.api property.');
    }

    InvoicingRequester.api.request((0, _manticoreUtil.extend)(opts, {
      service: 'invoicing',
      format: 'json',
      headers: { 'Content-Type': 'application/json' }
    }), function (error, response) {
      InvoicingRequester.decorateError(error);

      cb(error, response);
    });
  };

  InvoicingRequester.decorateError = function decorateError(error) {
    if (!error) {
      return;
    }

    var betterMessage = '';
    var firstFieldRegEx = /(.*?)\..*/;
    var lastFieldRegEx = /.*\.(.*)/;

    if (error.details && Array.isArray(error.details) && error.details.length > 0) {
      error.details.forEach(function (obj) {
        if (betterMessage.length) {
          betterMessage += ' ';
        }

        var firstMatches = obj.field.match(firstFieldRegEx);
        var cleanField = obj.field;

        if (Array.isArray(firstMatches) && firstMatches.length) {
          cleanField = firstMatches[1];
          // Get rid of "[0]" if it's there.
          cleanField = cleanField.replace(/(.*?)\[.*/, '$1');

          cleanField = cleanField.replace('_', ' ');

          // Capitalize first letter
          cleanField = cleanField.charAt(0).toUpperCase() + cleanField.slice(1);

          var lastMatches = obj.field.match(lastFieldRegEx);
          if (Array.isArray(lastMatches) && lastMatches.length) {
            cleanField = cleanField + ' ' + lastMatches[1];
          }
        } else {
          // Capitalize first letter
          cleanField = cleanField.charAt(0).toUpperCase() + cleanField.slice(1);
        }

        betterMessage = '' + betterMessage + cleanField + ' ' + obj.issue;
      });
    }

    // If there are details, overwrite the message.
    if (betterMessage.length) {
      error.message = betterMessage;
    }
  };

  return InvoicingRequester;
}();

exports.default = InvoicingRequester;
function request(opts, cb) {
  return InvoicingRequester.request(opts, cb);
}
},{"manticore-util":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-util/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/SearchRequest.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _InvoiceEnums = require('./InvoiceEnums');

var _InvoiceEnums2 = _interopRequireDefault(_InvoiceEnums);

var _InvoicingUtil = require('./InvoicingUtil');

var _InvoicingUtil2 = _interopRequireDefault(_InvoicingUtil);

var _InvoiceBigNumber = require('./InvoiceBigNumber');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @property {string} email Initial letters of the email address.
 * @property {string} recipientFirstName Initial letters of the recipient's first name.
 * @property {string} recipientLastName Initial letters of the recipient's last name.
 * @property {string} recipientBusinessName Initial letters of the recipient's business name.
 * @property {string} number The invoice number that appears on the invoice.
 * @property {decimal} lowerTotalAmount Base object for all financial value
 *  related fields (balance, payment due, etc.)
 * @property {decimal} upperTotalAmount Base object for all financial value
 *  related fields (balance, payment due, etc.)
 * @property {Date} startInvoiceDate Start invoice date.
 *  Date format yyyy-MM-dd z, as defined in ISO8601.
 * @property {Date} endInvoiceDate End invoice date.
 *  Date format yyyy-MM-dd z, as defined in ISO8601.
 * @property {Date} startDueDate Start invoice due date.
 *  Date format yyyy-MM-dd z, as defined in ISO8601.
 * @property {Date} endDueDate End invoice due date.
 *  Date format yyyy-MM-dd z, as defined in ISO8601.
 * @property {Date} startPaymentDate Start invoice payment date.
 *  Date format yyyy-MM-dd z, as defined in ISO8601.
 * @property {Date} endPaymentDate End invoice payment date.
 *  Date format yyyy-MM-dd z, as defined in ISO8601.
 * @property {Date} startCreationDate Start invoice creation date.
 *  Date format yyyy-MM-dd z, as defined in ISO8601.
 * @property {Date} endCreationDate End invoice creation date.
 *  Date format yyyy-MM-dd z, as defined in ISO8601.
 * @property {int} startIndex A zero-relative index of the merchant's list of invoices
 * @property {int} pageSize Page size of the search results.
 * @property {bool} totalCountRequired A flag indicating whether total
 *  count is required in the response.
 * @property {bool} archived A flag indicating whether search is on invoices archived by
 *  merchant. true - returns archived / false returns unarchived / null returns all.
 */

var InvoiceSearchRequest = function () {
  function InvoiceSearchRequest() {
    _classCallCheck(this, InvoiceSearchRequest);

    this.startIndex = 0;
    this.pageSize = 20;
    this.totalCountRequired = false;
    this._statuses = [];
  }

  InvoiceSearchRequest.prototype.toJSON = function toJSON() {
    var json = {};
    this.assignDatesToJSON(json);

    json.email = this.email;
    json.recipientFirstName = this.recipientFirstName;
    json.recipientLastName = this.recipientLastName;
    json.recipientBusinessName = this.recipientBusinessName;
    json.number = this.number;
    for (var _iterator = this._statuses, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var status = _ref;

      if (!json.status) {
        json.status = [];
      }
      json.status.push(_InvoiceEnums2.default.Status.toString[status]);
    }
    json.lower_total_amount = this.lowerTotalAmount;
    json.upper_total_amount = this.upperTotalAmount;
    json.page = this.startIndex;
    json.page_size = this.pageSize;
    json.total_count_required = this.totalCountRequired;
    json.archived = this.archived;
    return json;
  };

  /**
   * Manticore doesn't support properties that are arrays of enum values, and it's complicated.
   * So instead of a property for the status array, we have this method.
   * @param {Invoice.Status} status
   */


  InvoiceSearchRequest.prototype.addStatus = function addStatus(status) {
    this._statuses.push(status);
  };

  // If you send a startXDate, the server requires you to send an endXDate.
  // The server also only accepts certain time ranges (e.g. after 1970), so
  // this method automatically sets the most-lenient available date if you're
  // missing one of a pair.


  InvoiceSearchRequest.prototype.assignDatesToJSON = function assignDatesToJSON(json) {
    var datePairs = [['startInvoiceDate', 'endInvoiceDate', 'start_invoice_date', 'end_invoice_date'], ['startDueDate', 'endDueDate', 'start_due_date', 'end_due_date'], ['startPaymentDate', 'endPaymentDate', 'start_payment_date', 'end_payment_date'], ['startCreationDate', 'endCreationDate', 'start_creation_date', 'end_creation_date']];
    for (var _iterator2 = datePairs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var p = _ref2;

      if (this[p[0]] || this[p[1]]) {
        json[p[2]] = this[p[0]] ? _InvoicingUtil2.default.toServerDateString(this[p[0]], false) : '1970-01-01 PST';
        json[p[3]] = this[p[1]] ? _InvoicingUtil2.default.toServerDateString(this[p[1]], false) : '2100-01-01 PST';
      }
    }
  };

  _createClass(InvoiceSearchRequest, [{
    key: 'lowerTotalAmount',
    get: function get() {
      return this._lowerTotalAmount;
    },
    set: function set(val) {
      this._lowerTotalAmount = (0, _InvoiceBigNumber.$$)(val);
    }
  }, {
    key: 'upperTotalAmount',
    get: function get() {
      return this._upperTotalAmount;
    },
    set: function set(val) {
      this._upperTotalAmount = (0, _InvoiceBigNumber.$$)(val);
    }
  }]);

  return InvoiceSearchRequest;
}();

exports.default = InvoiceSearchRequest;
},{"./InvoiceBigNumber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceBigNumber.js","./InvoiceEnums":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceEnums.js","./InvoicingUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoicingUtil.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/ShippingInfo.js":[function(require,module,exports){
'use strict';

var _Address = require('./Address');

var _Address2 = _interopRequireDefault(_Address);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Container for information about the merchant requesting payment on an invoice
 * @class
 * @property {string} email The email address of the
 *  merchant @required @length(1,260) @format(email)
 * @property {string} firstName The first name of the merchant @length(,30)
 * @property {string} lastName The last name of the merchant @length(,30)
 * @property {InvoiceAddress} address The address of the merchant
 * @property {string} businessName The business name of the merchant
 */

var InvoiceShippingInfo = function () {
  function InvoiceShippingInfo() {
    _classCallCheck(this, InvoiceShippingInfo);

    this.address = new _Address2.default();
  }

  InvoiceShippingInfo.prototype.readFromJson = function readFromJson(json) {
    if (json) {
      this.address.readFromJson(json.address);
      this.firstName = json.first_name;
      this.lastName = json.last_name;
      this.businessName = json.business_name;
    }
  };

  InvoiceShippingInfo.prototype.toJSON = function toJSON() {
    var r = {};
    // If the address is empty, don't include it in the JSON.
    if (Object.keys(this.address).length) {
      r.address = this.address;
    }
    r.first_name = this.firstName;
    r.last_name = this.lastName;
    r.business_name = this.businessName;

    return r;
  };

  /**
   * Check to see if this object has any value
   * @returns {bool}
   */


  InvoiceShippingInfo.prototype.hasAnyValue = function hasAnyValue() {
    if (this.email || this.firstName || this.lastName || this.businessName || this.address.hasAnyValue()) {
      return true;
    }
    return false;
  };

  return InvoiceShippingInfo;
}();

module.exports = InvoiceShippingInfo;
},{"./Address":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Address.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Template.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _Invoice2 = require('./Invoice');

var _Invoice3 = _interopRequireDefault(_Invoice2);

var _TemplateSettings = require('./TemplateSettings');

var _TemplateSettings2 = _interopRequireDefault(_TemplateSettings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Invoice template
 * @class
 * @extends Invoice
 * @property {bool} isDefault true if this is the default template
 * @property {bool} isCustom true if this is a custom template
 * @property {string} name name of the template
 * @property {string} unitOfMeasure unit of measure for the template,
 *  known values: AMOUNT, QUANTITY, HOURS
 * @property {InvoiceTemplateSettings} settings list of which fields are enabled/disabled
 */

var InvoiceTemplate = function (_Invoice) {
  _inherits(InvoiceTemplate, _Invoice);

  /**
   * Create a new blank invoice template.
   * @constructor
   * @param {string} currencyCode currency code identifying the currency for amounts on this invoice
   */

  function InvoiceTemplate(currencyCode) {
    _classCallCheck(this, InvoiceTemplate);

    return _possibleConstructorReturn(this, _Invoice.call(this, currencyCode));
  }

  InvoiceTemplate.fromJSON = function fromJSON(json) {
    if (json.template_data && json.template_data.currencyCode) {
      var t = new InvoiceTemplate(json.template_data.currencyCode);
      t.readJSON(json.template_data, true);
      t.templateID = json.template_id;
      t.isDefault = json.default;
      t.isCustom = json.custom;
      t.name = json.name;
      t.unitOfMeasure = json.unit_of_measure;
      t.settings = _TemplateSettings2.default.fromJSON(json.settings);

      if (!t.isCustom) {
        // the default templates come back with bogus merchant info that we don't want
        // so only tak the merchant info if its a custom/user-made template
        t.merchantInfo = undefined;
      }
      return t;
    }
    return undefined;
  };

  /**
   * Return an invoice with all the fields from the template but the invoice
   * number and paypalID of another invoice
   * @param {Invoice} invoice whose paypalID and number going to be copied
   * @returns {Invoice} the new version of the invoice
   */


  InvoiceTemplate.prototype.invoiceFromInvoice = function invoiceFromInvoice(invoice) {
    var i = this.copy();

    // clear all the template specific fields
    i.isDefault = undefined;
    i.isCustom = undefined;
    i.name = undefined;
    i.unitOfMeasure = undefined;
    i.settings = undefined;

    i.number = invoice.number;
    i.payPalId = invoice.payPalId;
    return i;
  };

  return InvoiceTemplate;
}(_Invoice3.default);

exports.default = InvoiceTemplate;
},{"./Invoice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Invoice.js","./TemplateSettings":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/TemplateSettings.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/TemplateSettings.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Invoice template settings
 * @class
 * @property {bool} shipping true if shipping is displayed
 * @property {bool} discount true if discount is displayed
 * @property {bool} custom true if custom is displayed
 * @property {bool} itemsDiscount true if itemsDiscount is displayed
 * @property {bool} itemsTax true if itemsTax is displayed
 * @property {bool} itemsQuantity true if itemsQuantity is displayed
 * @property {bool} itemsDescription true if itemsDescription is displayed
 * @property {bool} itemsDate true if itemsDate is displayed
 */

var InvoiceTemplateSettings = function () {
  function InvoiceTemplateSettings() {
    _classCallCheck(this, InvoiceTemplateSettings);

    this.shipping = true;
    this.discount = true;
    this.custom = true;
    this.itemsDiscount = true;
    this.itemsTax = true;
    this.itemsQuantity = true;
    this.itemsDescription = true;
    this.itemsDate = true;
  }

  InvoiceTemplateSettings.fromJSON = function fromJSON(json) {
    var s = new InvoiceTemplateSettings();

    for (var _iterator = json, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var f = _ref;

      switch (f.field_name) {
        case 'shipping':
          s.shipping = s.isFieldShown(f);
          break;
        case 'discount':
          s.discount = s.isFieldShown(f);
          break;
        case 'custom':
          s.custom = s.isFieldShown(f);
          break;
        case 'items.discount':
          s.itemsDiscount = s.isFieldShown(f);
          break;
        case 'items.tax':
          s.itemsTax = s.isFieldShown(f);
          break;
        case 'items.quantity':
          s.itemsQuantity = s.isFieldShown(f);
          break;
        case 'items.description':
          s.itemsDescription = s.isFieldShown(f);
          break;
        case 'items.date':
          s.itemsDate = s.isFieldShown(f);
          break;
        default:
          (0, _assert2.default)('unknown field name: ' + f.field_name);
      }
    }
    return s;
  };

  InvoiceTemplateSettings.prototype.isFieldShown = function isFieldShown(field) {
    return field.display_preference.hidden !== true;
  };

  return InvoiceTemplateSettings;
}();

exports.default = InvoiceTemplateSettings;
},{"assert":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/assert/assert.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/totalCalculator.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports.default = function (invoice) {
  var it = new InvoiceTotals(invoice);
  it.calculate();
};

var _Currency = require('./Currency');

var _Currency2 = _interopRequireDefault(_Currency);

var _InvoiceBigNumber = require('./InvoiceBigNumber');

var _InvoiceBigNumber2 = _interopRequireDefault(_InvoiceBigNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ZERO = new _InvoiceBigNumber2.default(0);
var ONE = new _InvoiceBigNumber2.default(1);

function nonZero(amt) {
  return amt && !ZERO.equals(amt);
}

function valOrZero(amt) {
  return amt || ZERO;
}

function compare(a, b) {
  if (a === b) {
    return 0;
  } else if (a < b) {
    return -1;
  }
  return 1;
}

var InvoiceTotals = function () {
  function InvoiceTotals(invoice) {
    _classCallCheck(this, InvoiceTotals);

    this.invoice = invoice;
  }

  InvoiceTotals.prototype.round = function round(amt) {
    return _Currency2.default.round(this.invoice.currency, amt);
  };

  InvoiceTotals.prototype.calculate = function calculate() {
    var invoice = this.invoice;
    var sortedItems = this.sortedInvoiceItems();
    var excludingDiscount = !(invoice.taxCalculatedAfterDiscount || invoice.taxInclusive);
    var subTotals = this.calculateItemSubtotals(sortedItems);
    invoice._subTotal = subTotals[0];
    invoice._subTotalWithItemDiscounts = subTotals[1];
    invoice._discountTotal = this.calculatePreTaxDiscountForItemSubtotal(invoice._subTotalWithItemDiscounts);
    if (invoice.taxCalculatedAfterDiscount) {
      var subWith = invoice._subTotalWithItemDiscounts;
      var dtot = invoice._discountTotal;
      invoice._taxBreakdown = this.calculateTaxesForItemsWithPreTaxDiscountTotal(sortedItems, dtot, subWith);
    } else {
      invoice._taxBreakdown = this.calculateTaxesForItemsWithDiscountAfterTax(sortedItems);
    }
    invoice._shippingTaxTotal = this.calculateShippingTax(invoice._taxBreakdown);
    invoice._itemTax = this.calculateTotalTaxFromTaxes(invoice._taxBreakdown);
    invoice._itemTax = (0, _InvoiceBigNumber.$$)(invoice._itemTax.minus(invoice._shippingTaxTotal));
    invoice._taxBreakdown = this.generateRoundedTaxDetailsFromTaxes(invoice._taxBreakdown);
    if (excludingDiscount) {
      invoice._discountTotal = this.calculateDiscountWithItemSubTotal(invoice._subTotal, invoice._itemTax);
    }
    if (this.invoice.custom) {
      invoice._customAmountTotal = this.invoice.custom.amount;
    }
    this.setDerivedTotals();
  };

  InvoiceTotals.prototype.sortedInvoiceItems = function sortedInvoiceItems() {
    // Sort the items so that the highest tax rate items are first just
    // so we have some logic to the application of pre-sales tax discounts.
    var copy = this.invoice.items.slice(0); // equivalent to array copy
    copy.sort(function (a, b) {
      if (!a.taxRate) {
        if (!b.taxRate) {
          return compare(a.name, b.name);
        }
        // a should go first
        return 1;
      }
      if (!b.taxRate) {
        // b should go first
        return -1;
      }
      if (b.taxRate.equals(a.taxRate)) {
        return compare(a.name, b.name);
      }
      return -1 * a.taxRate.comparedTo(b.taxRate);
    });
    return copy;
  };

  InvoiceTotals.prototype.generateRoundedTaxDetailsFromTaxes = function generateRoundedTaxDetailsFromTaxes(taxes) {
    var roundedTaxDetails = {};
    for (var key in taxes) {
      if (taxes.hasOwnProperty(key)) {
        roundedTaxDetails[key] = this.round(taxes[key]);
      }
    }
    return roundedTaxDetails;
  };

  InvoiceTotals.prototype.calculateTotalTaxFromTaxes = function calculateTotalTaxFromTaxes(taxes) {
    var itemTax = ZERO;
    for (var key in taxes) {
      if (taxes.hasOwnProperty(key)) {
        itemTax = itemTax.plus(taxes[key]);
      }
    }
    return itemTax;
  };

  InvoiceTotals.prototype.calculateTaxesForItemsWithPreTaxDiscountTotal = function calculateTaxesForItemsWithPreTaxDiscountTotal(items, discountTotal, itemSubTotal) {
    var taxes = {};
    for (var _iterator = items, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var i = _ref;

      var itemDiscount = this.calculateItemDiscount(i, this.invoice);
      var itemContribution = i.totalForInvoice(this.invoice);
      if (nonZero(i.taxRate)) {
        var key = [i.taxName, ' (', i.taxRate.toString(), '%)'].join('');
        // Rounding is complicated. We have to match invoicing, and invoicing rounds per line item.
        var taxAmount = void 0;
        if (this.invoice.taxInclusive) {
          var itemTotal = itemContribution.plus(itemDiscount);
          var preTaxItemTotal = this.round(itemTotal.dividedBy(ONE.plus(i.taxRate.dividedBy(100))));
          taxAmount = preTaxItemTotal.times(i.taxRate.dividedBy(100));
        } else {
          var amountToBeTaxed = nonZero(discountTotal) ? itemContribution.minus(itemContribution.dividedBy(itemSubTotal).times(discountTotal)) : itemContribution;
          taxAmount = this.round(amountToBeTaxed.times(i.taxRate.dividedBy(100)));
        }
        if (taxAmount && !ZERO.equals(taxAmount)) {
          taxes[key] = (taxes[key] || ZERO).plus(taxAmount);
        }
      }
    }
    return taxes;
  };

  InvoiceTotals.prototype.calculateItemDiscount = function calculateItemDiscount(i, inv) {
    return (0, _InvoiceBigNumber.$$)(i.subtotalForInvoice(inv)).minus((0, _InvoiceBigNumber.$$)(i.totalForInvoice(inv)));
  };

  InvoiceTotals.prototype.calculateTaxesForItemsWithDiscountAfterTax = function calculateTaxesForItemsWithDiscountAfterTax(items) {
    var taxes = {};
    for (var _iterator2 = items, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var i = _ref2;

      var itemContribution = ZERO;
      if (nonZero(i.unitPrice)) {
        // In this mode (discounts after tax), even line item discounts
        // don't matter for tax calculations
        itemContribution = this.round(i.quantity.times(i.unitPrice));
      }
      if (nonZero(i.taxRate)) {
        var key = [i.taxName, ' (', i.taxRate.toString(), '%)'].join('');
        var taxAmount = void 0;
        if (this.invoice.taxInclusive) {
          var taxSub = itemContribution.dividedBy(ONE.plus(i.taxRate.dividedBy(100)));
          taxAmount = this.round(itemContribution.minus(taxSub));
        } else {
          taxAmount = this.round(itemContribution.times(i.taxRate.dividedBy(100)));
        }
        if (taxAmount && !ZERO.equals(taxAmount)) {
          taxes[key] = (taxes[key] || ZERO).plus(taxAmount);
        }
      }
    }
    return taxes;
  };

  InvoiceTotals.prototype.calculateShippingTax = function calculateShippingTax(taxes) {
    var invoice = this.invoice;
    if (nonZero(invoice.shippingTaxRate) && nonZero(invoice.shippingAmount)) {
      // Rounding is complicated. For best results, we're going to round at the "tax class" level.
      // If you have one tax rate, this means "order level." If you have as many tax rates as
      // line items, this means line level. The advantage is with this rounding I can display
      // valid tax per tax rate and have consistent totals.
      var key = [invoice.shippingTaxName || 'Shipping Tax', ' (', invoice.shippingTaxRate.toString(), '%)'].join('');
      var shippingTaxTotal = invoice.shippingAmount.times(invoice.shippingTaxRate.dividedBy(100));
      if (nonZero(shippingTaxTotal)) {
        taxes[key] = valOrZero(taxes[key]).plus(shippingTaxTotal);
      }
      return shippingTaxTotal;
    }
    return ZERO;
  };

  InvoiceTotals.prototype.calculateItemSubtotals = function calculateItemSubtotals(items) {
    var subtotalWithoutDiscount = ZERO;
    var subtotalWithDiscount = ZERO;
    for (var _iterator3 = items, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var item = _ref3;

      subtotalWithoutDiscount = subtotalWithoutDiscount.plus(item.subtotalForInvoice(this.invoice));
      subtotalWithDiscount = subtotalWithDiscount.plus(item.totalForInvoice(this.invoice));
    }
    return [(0, _InvoiceBigNumber.$$)(subtotalWithoutDiscount), (0, _InvoiceBigNumber.$$)(subtotalWithDiscount)];
  };

  InvoiceTotals.prototype.calculateDiscountWithItemSubTotal = function calculateDiscountWithItemSubTotal(itemSubTotal) {
    if (nonZero(this.invoice.discountAmount)) {
      return this.invoice.discountAmount;
    } else if (nonZero(this.invoice.discountPercentage)) {
      return this.round(itemSubTotal.times(this.invoice.discountPercentage).dividedBy(100));
    }
    return ZERO;
  };

  InvoiceTotals.prototype.calculatePreTaxDiscountForItemSubtotal = function calculatePreTaxDiscountForItemSubtotal(subtotal) {
    if (nonZero(this.invoice.discountAmount)) {
      return (0, _InvoiceBigNumber.$$)(this.invoice.discountAmount);
    } else if (nonZero(this.invoice.discountPercentage)) {
      return this.round((0, _InvoiceBigNumber.$$)(this.invoice.discountPercentage).dividedBy(100).times(subtotal));
    }
    return ZERO;
  };

  /**
   * Once the component values of the total have been calculated, this is used to set
   * various derived totals such as the grand total. Rather than using properties, which
   * in theory won't work on all browsers, we just spend the cycles to do various additions
   * every time the invoice is recalculated.
   * @private
   */


  InvoiceTotals.prototype.setDerivedTotals = function setDerivedTotals() {
    var invoice = this.invoice;
    invoice._total = valOrZero(invoice._subTotalWithItemDiscounts).plus(valOrZero(invoice.gratuityAmount)).plus(valOrZero(invoice.shippingAmount));
    if (!invoice.taxInclusive) {
      invoice._total = invoice._total.plus(valOrZero(invoice._itemTax)).plus(valOrZero(invoice._shippingTaxTotal));
    }
    if (nonZero(invoice._discountTotal)) {
      invoice._total = invoice._total.minus(invoice._discountTotal);
    }
    if (nonZero(invoice._customAmountTotal)) {
      invoice._total = invoice._total.plus(invoice._customAmountTotal);
    }
    invoice._total = (0, _InvoiceBigNumber.$$)(invoice._total);
  };

  return InvoiceTotals;
}();
},{"./Currency":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/Currency.js","./InvoiceBigNumber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypal-invoicing/build/lib/InvoiceBigNumber.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/paypalrest-manticore/build/index.js":[function(require,module,exports){
(function (Buffer){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _manticore = require('manticore');

var _manticore2 = _interopRequireDefault(_manticore);

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Log = (0, _manticoreLog2.default)('paypalrest');

/**
 * An object that manages network calls to authenticated PayPal services.
 * It will automatically refresh expired access tokens and retry as appropriate.
 * It also provides a "url resolution" infrastructure to let callers specify services
 * and operations to be intepreted in the context of an environment to generate a URL
 * for a service call rather than just hand coding all the service endpoints.
 * @class
 */

var PayPalREST = function () {
  _createClass(PayPalREST, null, [{
    key: 'fromToken',

    /**
     * Construct a PayPalREST object from a "token blob" format which contains
     * an environment specifier, access token, and refresh url (typically)
     * @param {string} token The token blob usually from a mid tier server
     */
    value: function fromToken(token) {
      var parsedToken = void 0;
      try {
        if (token && token[0] === '{') {
          parsedToken = JSON.parse(token);
        } else {
          var parts = (token || '').split(':', 2);
          if (parts.length !== 2) {
            throw new Error('Invalid token presented (off by ' + (parts.length - 2) + ')');
          }
          var unpacked = new Buffer(parts[1], 'base64');
          var infoArray = JSON.parse(unpacked.toString('utf8'));
          parsedToken = {
            env: parts[0],
            access_token: infoArray[0],
            expires_in: infoArray[1],
            refresh_url: infoArray[2]
          };
          if (!infoArray[2] && parts[0] !== 'live' && infoArray.length >= 5) {
            parsedToken.app = {
              auth: infoArray[4]
            };
            parsedToken.rt = infoArray[3];
          }
        }
        var api = new PayPalREST(parsedToken.access_token, parsedToken.refresh_url, parsedToken.expires_in);

        api.env = parsedToken.env;
        if (parsedToken.app && parsedToken.rt) {
          api.app = parsedToken.app;
          api.rt = parsedToken.rt;
        }
        return api;
      } catch (x) {
        Log.error('Could not read token: ' + x.message + '\n' + x.stack);
        throw new Error('Invalid token presented (' + x.message + ')');
      }
    }

    /**
     * Build a REST interface with access token, refresh url and optional expiration time
     * @constructor
     * @param {string} accessToken The access token
     * @param {string} refreshUrl The URL to hit to refresh the token
     * @param {string} expiresIn An optional time offset (from now, in msec)
     *  when the access token will expire
     */

  }]);

  function PayPalREST(accessToken, refreshUrl, expiresIn) {
    var _this = this;

    _classCallCheck(this, PayPalREST);

    this.resolvers = {
      token: function token(self, opts) {
        if (_this.env === PayPalREST.Env.LIVE) {
          return 'https://api.paypal.com/v1/oauth2/' + opts.op;
        } else if (_this.env === PayPalREST.Env.SANDBOX) {
          return 'https://api.sandbox.paypal.com/v1/oauth2/' + opts.op;
        } else if (_this.env === PayPalREST.Env.MSMASTER) {
          return 'https://www.msmaster.qa.paypal.com/v1/oauth2/' + opts.op;
        }
        return 'https://www.' + _this.env + '.stage.paypal.com:11888/v1/oauth2/' + opts.op;
      },
      invoicing: function invoicing(self, opts) {
        if (_this.env === PayPalREST.Env.LIVE) {
          return 'https://api.paypal.com/v1/invoicing/' + opts.op;
        } else if (_this.env === PayPalREST.Env.SANDBOX) {
          return 'https://api.sandbox.paypal.com/v1/invoicing/' + opts.op;
        } else if (_this.env === PayPalREST.Env.MSMASTER) {
          return 'https://www.msmaster.qa.paypal.com/v1/invoicing/' + opts.op;
        }
        return 'https://www.' + _this.env + '.stage.paypal.com:11888/v1/invoicing/' + opts.op;
      },
      contactserv: function contactserv(self, opts) {
        if (_this.env === PayPalREST.Env.LIVE) {
          return 'https://api.paypal.com/v1/customer/contacts/' + opts.op;
        } else if (_this.env === PayPalREST.Env.SANDBOX) {
          return 'https://api.sandbox.paypal.com/v1/customer/contacts/' + opts.op;
        } else if (_this.env === PayPalREST.Env.MSMASTER) {
          return 'https://www.msmaster.qa.paypal.com/v1/customer/contacts/' + opts.op;
        }
        return 'https://www.' + _this.env + '.stage.paypal.com:11888/v1/customer/contacts/' + opts.op;
      }
    };
    this.env = PayPalREST.Env.LIVE;
    this.cbs = [];
    this.at = accessToken;
    this.refreshUrl = refreshUrl;
    this.exp = expiresIn;
  }

  /**
   * Add a resolver for a given service
   * @param {string} service The name of the service this resolver will resolve.
   * @param {PayPalRest#serviceResolver} fn The function that will be called to get
   *  the URL for the operation
   */


  _createClass(PayPalREST, [{
    key: 'addResolver',
    value: function addResolver(service, fn) {
      this.resolvers[service] = fn;
    }
  }, {
    key: 'request',
    value: function request(options, callback) {
      var _this2 = this;

      if (!options) {
        var error = new Error('Empty options!');
        Log.error('Empty options: ' + error.stack);
        return callback(error, null);
      }

      if (!options.url) {
        if (!options.service || !this.resolvers[options.service]) {
          var operror = new Error('Options has no url and no resolvable service.');
          Log.error('Bad options: ' + operror.stack);
          return callback(operror, null);
        }
        options.url = this.resolvers[options.service](this, options);
      }

      if (!this.at && !this.refreshUrl) {
        var _error = new Error('The access token is invalid and does not include an access token or refresh url');
        return callback(_error, null);
      }
      if (!this.at) {
        // Refresh right away
        return this.refresh(function (refreshError) {
          if (refreshError) {
            callback(refreshError, null);
          } else {
            _this2.request(options, callback);
          }
        });
      }

      options.headers = options.headers || {};
      options.headers.Authorization = 'Bearer ' + this.at;

      var start = new Date().getTime();
      return _manticore2.default.http(options, function (httpError, response) {
        var error = httpError;
        try {
          var _ret = function () {
            var end = new Date().getTime();
            var elapsed = end - start;
            var msg = response ? response.statusCode : error;
            Log.debug(function () {
              return (options.method || 'GET') + ' ' + options.url + ' (' + elapsed + 'ms): ' + msg;
            });
            if (error) {
              Log.error('Authenticated request error: ' + error.message + '\n' + error.stack);
              return {
                v: callback(error, null)
              };
            }
            var needsRefresh = response && (response.statusCode === 401 || response.statusCode === 403) && !options._tried;
            if (needsRefresh) {
              options._tried = true;
              return {
                v: _this2.refresh(function (refreshError) {
                  if (refreshError) {
                    callback(refreshError, null);
                  } else {
                    _this2.request(options, callback);
                  }
                })
              };
            }
            if (options.format === 'json' && !options.rawError) {
              if (response && response.body) {
                if (response.body.errorCode) {
                  // HereApi style errors
                  error = new Error(response.body.message);
                  error.code = response.body.errorCode;
                  error.debugId = response.body.correlationId;
                } else if (response.statusCode && response.statusCode >= 300) {
                  // Platformapiserv style errors
                  error = new Error(response.body.message);
                  error.code = response.body.name || response.statusCode;
                  // Sometimes errors from invoicing just don't have a debugId in the body. Oh well.
                  error.debugId = response.body.debug_id;
                  if (response.body.details) {
                    error.details = response.body.details;
                  }
                }
              }
              if (response.statusCode >= 400 && !error) {
                // Handle the case where the server returned a failing HTTP status,
                // but no error in the body.
                error = new Error();
                error.code = response.statusCode;
              }
              if (error) {
                error.domain = options.service;
                PayPalREST.generateDevMessage(error);
                Log.error('Received error (' + error.developerMessage + ')');
              }
            }
          }();

          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
        } catch (x) {
          Log.error('Merchant request failure: ' + (x.message || x) + '\n' + x.stack);
          error = x;
        }
        return callback(error, response);
      });
    }
  }, {
    key: 'refresh',
    value: function refresh(callback) {
      var _this3 = this;

      if (this.cbs.length) {
        this.cbs.push(callback);
        return;
      }
      this.cbs.push(callback);

      if (!this.refreshUrl && this.rt && this.app) {
        Log.debug('Attempting a direct token refresh');
        var rt = encodeURIComponent(this.rt);
        var rqBody = 'grant_type=refresh_token&response_type=token&refresh_token=' + rt;
        _manticore2.default.http({
          url: this.resolvers.token(this, { op: 'token' }),
          headers: {
            Authorization: 'Basic ' + this.app.auth,
            'Content-Type': 'application/x-www-form-urlencoded'
          },
          method: 'POST',
          format: 'json',
          body: rqBody,
          timeout: 15000
        }, function (error, rz) {
          var e = error;
          if (rz && rz.body && rz.body.access_token) {
            _this3.at = rz.body.access_token;
            Log.debug('Successfully refreshed token.');
          } else if (!e) {
            Log.error('Invalid response from token refresh');
            e = new Error('Invalid response from token refresh');
          }
          if (e) {
            var rzDesc = JSON.stringify(rz || {});
            Log.error('Failed to directly refresh token: ' + e.message + ': ' + rzDesc);
          }
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _this3.cbs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var cb = _step.value;

              try {
                cb(e);
              } catch (x) {
                // Do nothing.
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          _this3.cbs = [];
        });
        return;
      }
      if (!this.refreshUrl) {
        var e = new Error('Merchant token had no "refreshUrl" property, cannot refresh access token.');
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.cbs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var cb = _step2.value;

            try {
              cb(e);
            } catch (x) {
              // Do nothing.
            }
            this.cbs = [];
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return;
      }
      Log.debug('Attempting a token refresh');
      _manticore2.default.http({
        url: this.refreshUrl,
        format: 'json'
      }, function (httpError, rz) {
        var error = httpError;
        if (rz && rz.body && rz.body.access_token) {
          _this3.at = rz.body.access_token;
          _this3.refreshUrl = rz.body.refresh_url || _this3.refreshUrl;
          Log.debug('Successfully refreshed token.');
        } else if (!error) {
          error = new Error('Invalid response from refreshUrl');
        }
        if (error) {
          var rzDesc = JSON.stringify(rz || {});
          Log.error('Failed to refresh token: ' + error.message + ': ' + rzDesc);
        }
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _this3.cbs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _cb = _step3.value;

            try {
              _cb(error);
            } catch (x) {
              // Do nothing.
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        _this3.cbs = [];
      });
    }
  }], [{
    key: 'generateDevMessage',
    value: function generateDevMessage(error) {
      if (!error) {
        return error;
      }

      var devMessage = [];

      function appendToDevMessage(key, str) {
        if (devMessage.length) {
          devMessage.push(', ');
        }
        devMessage.push(key);
        devMessage.push(': ');
        if (str && str.length) {
          devMessage.push(str);
        }
      }

      appendToDevMessage('domain', error.domain);
      appendToDevMessage('code', error.code);
      appendToDevMessage('message', error.message);
      appendToDevMessage('debugId', error.debugId);

      var details = [];
      if (error.details && Array.isArray(error.details) && error.details.length > 0) {
        error.details.forEach(function (obj) {
          if (details.length) {
            details.push(' ');
          }
          details.push(obj.field);
          details.push(' ');
          details.push(obj.issue);
        });
      }
      appendToDevMessage('details', details.join(''));
      error.developerMessage = devMessage.join('');
      return error;
    }
  }]);

  return PayPalREST;
}();

/**
 * Enum for the main environments
 */


exports.default = PayPalREST;
PayPalREST.Env = {
  LIVE: 'live',
  SANDBOX: 'sandbox',
  MSMASTER: 'msmaster'
};

/**
 * Called when an operation needs to be resolved to a URL.
 * @callback TransactionContext~serviceResolver
 * @param {PayPalREST} api The API which is attempting to make the request
 * @param {object} options The options on the request, in which you typically
 *  only need to see op (meaning operation)
 */
}).call(this,require("buffer").Buffer)
},{"buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/qs/lib/stringify.js":[function(require,module,exports){
'use strict';

var Utils = require('./utils');

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var defaults = {
    delimiter: '&',
    strictNullHandling: false,
    skipNulls: false,
    encode: true,
    encoder: Utils.encode
};

var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = obj.toISOString();
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder ? encoder(prefix) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {
        if (encoder) {
            return [encoder(prefix) + '=' + encoder(obj)];
        }
        return [prefix + '=' + String(obj)];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
        } else {
            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts || {};
    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var objKeys;
    var filter;

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        objKeys = filter = options.filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
    }

    return keys.join(delimiter);
};

},{"./utils":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/qs/lib/utils.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/qs/lib/utils.js":[function(require,module,exports){
'use strict';

var hexTable = (function () {
    var array = new Array(256);
    for (var i = 0; i < 256; ++i) {
        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();
    }

    return array;
}());

exports.arrayToObject = function (source, options) {
    var obj = options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

exports.merge = function (target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            target[source] = true;
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = exports.arrayToObject(target, options);
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (Object.prototype.hasOwnProperty.call(acc, key)) {
            acc[key] = exports.merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

exports.decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

exports.encode = function (str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D || // -
            c === 0x2E || // .
            c === 0x5F || // _
            c === 0x7E || // ~
            (c >= 0x30 && c <= 0x39) || // 0-9
            (c >= 0x41 && c <= 0x5A) || // a-z
            (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

exports.compact = function (obj, references) {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }

    var refs = references || [];
    var lookup = refs.indexOf(obj);
    if (lookup !== -1) {
        return refs[lookup];
    }

    refs.push(obj);

    if (Array.isArray(obj)) {
        var compacted = [];

        for (var i = 0; i < obj.length; ++i) {
            if (obj[i] && typeof obj[i] === 'object') {
                compacted.push(exports.compact(obj[i], refs));
            } else if (typeof obj[i] !== 'undefined') {
                compacted.push(obj[i]);
            }
        }

        return compacted;
    }

    var keys = Object.keys(obj);
    for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        obj[key] = exports.compact(obj[key], refs);
    }

    return obj;
};

exports.isRegExp = function (obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

exports.isBuffer = function (obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/index.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _EmvDevice = require('./src/EmvDevice');

Object.keys(_EmvDevice).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EmvDevice[key];
    }
  });
});

var _PaymentDevice = require('./src/PaymentDevice');

Object.keys(_PaymentDevice).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _PaymentDevice[key];
    }
  });
});

var _BatteryInfo = require('./src/BatteryInfo');

Object.keys(_BatteryInfo).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _BatteryInfo[key];
    }
  });
});

var _Card = require('./src/Card');

Object.keys(_Card).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Card[key];
    }
  });
});

var _MagneticCard = require('./src/MagneticCard');

Object.keys(_MagneticCard).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _MagneticCard[key];
    }
  });
});

var _ManuallyEnteredCard = require('./src/ManuallyEnteredCard');

Object.keys(_ManuallyEnteredCard).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _ManuallyEnteredCard[key];
    }
  });
});

var _CardDataUtil = require('./src/CardDataUtil');

Object.keys(_CardDataUtil).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _CardDataUtil[key];
    }
  });
});

var _MagneticReaderDevice = require('./src/MagneticReaderDevice');

Object.keys(_MagneticReaderDevice).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _MagneticReaderDevice[key];
    }
  });
});

var _DecisionRequired = require('./src/DecisionRequired');

Object.keys(_DecisionRequired).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _DecisionRequired[key];
    }
  });
});

var _PinEvent = require('./src/PinEvent');

Object.keys(_PinEvent).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _PinEvent[key];
    }
  });
});

var _paymentDeviceError = require('./src/paymentDeviceError');

Object.keys(_paymentDeviceError).forEach(function (key) {
  if (key === "default") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _paymentDeviceError[key];
    }
  });
});
},{"./src/BatteryInfo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/BatteryInfo.js","./src/Card":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/Card.js","./src/CardDataUtil":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/CardDataUtil.js","./src/DecisionRequired":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/DecisionRequired.js","./src/EmvDevice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/EmvDevice.js","./src/MagneticCard":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/MagneticCard.js","./src/MagneticReaderDevice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/MagneticReaderDevice.js","./src/ManuallyEnteredCard":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/ManuallyEnteredCard.js","./src/PaymentDevice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/PaymentDevice.js","./src/PinEvent":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/PinEvent.js","./src/paymentDeviceError":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/paymentDeviceError.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/BatteryInfo.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * BatteryInfo class contains information about the health of the device battery
 * and the instant it was measured
 * @class
 * @property {int} percentage The level of battery in percentage
 * @property {bool} isCharging Indicates if the device battery is connected to power
 * @property {bool} isLevelCritical Indicates that the device battery is at Critical or less and not charging
 * @property {bool} isLevelUpdateCritical Indicates that the device battery is at UpdateCritical or less and not charging
 * @property {Date} measuredOn The time the battery information was retrieved
 */

var BatteryInfo = exports.BatteryInfo = function () {
  /**
   * Create a new Battery info object
   * @param {int} percentage The level of battery in percentage @readonly
   * @param {bool} isCharging Boolean indicating whether the battery is charging or not @readonly
   * @param {Date} measuredOn Time stamp at which the battery measurement was received @readonly
   */

  function BatteryInfo(percentage, isCharging, measuredOn) {
    _classCallCheck(this, BatteryInfo);

    this._percentage = parseInt(percentage, 10);
    this._isCharging = isCharging;
    this._measuredOn = measuredOn;
  }

  BatteryInfo.prototype.toString = function toString() {
    /* eslint max-len: "off" */
    return "Battery Info: Percentage: " + this.percentage + ", isCharging: " + this.isCharging + ", level: " + this.level + ", measuredOn: " + this.measuredOn;
  };

  _createClass(BatteryInfo, [{
    key: "percentage",
    get: function get() {
      return this._percentage;
    }
  }, {
    key: "isCharging",
    get: function get() {
      return this._isCharging;
    }
  }, {
    key: "isLevelUpdateCritical",
    get: function get() {
      return !this.isCharging && this._percentage <= 20;
    }
  }, {
    key: "isLevelCritical",
    get: function get() {
      return !this.isCharging && this._percentage <= 15;
    }
  }, {
    key: "measuredOn",
    get: function get() {
      return this._measuredOn;
    }
  }]);

  return BatteryInfo;
}();
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/Card.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.Card = undefined;

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Information about a card presented to the PayPal Retail SDK
 * @class
 * @property {PaymentDevice.FormFactor} formFactor The process used by consumer to present the card
 * @property {bool} failed The presentation failed and this event is simply a notice of failure
 * @property {PaymentDevice} reader The device used to read the card
 * @property {string} timestamp A server-compatible formatted time for when this
 *  presentation occurred
 * @property {string} lastFourDigits Last four digits of the presented card
 * @property {PaymentDevice.CardIssuer} cardIssuer Issuer of the card that was presented to the SDK
 * @property {string} cardholderName Name of consumer who owns the presented card
 */

var Card = exports.Card = function Card() {
  _classCallCheck(this, Card);

  this.timestamp = (0, _moment2.default)().format();
};
},{"moment":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/moment/moment.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/CardDataUtil.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.CardDataUtil = undefined;

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _PaymentDevice = require('./PaymentDevice');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var digitsOnlyRegexMatcher = null;
var Log = (0, _manticoreLog2.default)('card-issuer');

var CardDataUtil = exports.CardDataUtil = function () {
  function CardDataUtil() {
    _classCallCheck(this, CardDataUtil);
  }

  /**
   * Identify card issuer from the value of Application label TLV Tag
   * @param emvAppLabel string Application label TLV tag value
   * @returns {PaymentDevice.CardIssuer|int}
   */

  CardDataUtil.getCardIssuerFromEmvAppLabel = function getCardIssuerFromEmvAppLabel(emvAppLabel) {
    if (!emvAppLabel) {
      return _PaymentDevice.PaymentDevice.CardIssuer.Unknown;
    }

    var appLabel = emvAppLabel.toUpperCase();
    if (appLabel.includes('VISA')) {
      return _PaymentDevice.PaymentDevice.CardIssuer.Visa;
    }

    if (appLabel.includes('MASTERCARD')) {
      return _PaymentDevice.PaymentDevice.CardIssuer.MasterCard;
    }

    if (appLabel.includes('MAESTRO')) {
      return _PaymentDevice.PaymentDevice.CardIssuer.Maestro;
    }

    if (appLabel.includes('AMERICAN')) {
      return _PaymentDevice.PaymentDevice.CardIssuer.Amex;
    }

    if (appLabel.includes('DISCOVER')) {
      return _PaymentDevice.PaymentDevice.CardIssuer.Discover;
    }

    if (appLabel.includes('PAYPAL')) {
      return _PaymentDevice.PaymentDevice.CardIssuer.PayPal;
    }

    Log.warn('Unable to parse Card issuer from Application Label: ' + emvAppLabel);
    return _PaymentDevice.PaymentDevice.CardIssuer.Unknown;
  };

  /**
   * Identify card issuer from the card number
   * @param cardNumberInfo string
   * @returns {PaymentDevice.CardIssuer|int}
   */


  CardDataUtil.getCardIssuerFromCardNumber = function getCardIssuerFromCardNumber(cardNumberInfo) {
    if (!digitsOnlyRegexMatcher) {
      digitsOnlyRegexMatcher = /\D+/;
    }
    var cardNumber = cardNumberInfo.replace(digitsOnlyRegexMatcher, '');

    // Visa
    if (cardNumber.length > 0 && cardNumber[0] === CardDataUtil._controlNumber.Visa) {
      return _PaymentDevice.PaymentDevice.CardIssuer.Visa;
    }

    // MasterCard
    if (cardNumber.length >= 2) {
      var firstTwo = parseInt(cardNumber.substr(0, 2), 10);
      if (firstTwo > 50 && firstTwo < 56) {
        return _PaymentDevice.PaymentDevice.CardIssuer.MasterCard;
      }
    }

    // Maestro
    if (cardNumber.length >= 2) {
      var cn = cardNumber.substr(0, 2);
      if (cn === CardDataUtil._controlNumber.Maestro1 || cn === CardDataUtil._controlNumber.Maestro2) {
        return _PaymentDevice.PaymentDevice.CardIssuer.Maestro;
      }
    }

    // Amex
    if (cardNumber.length >= 2) {
      var _cn = cardNumber.substr(0, 2);
      if (_cn === CardDataUtil._controlNumber.Amex1 || _cn === CardDataUtil._controlNumber.Amex2) {
        return _PaymentDevice.PaymentDevice.CardIssuer.Amex;
      }
    }

    // Discover
    if (cardNumber.length >= 4 && cardNumber.substr(0, 4) === CardDataUtil._controlNumber.Discover1) {
      return _PaymentDevice.PaymentDevice.CardIssuer.Discover;
    }

    if (cardNumber.length >= 2 && cardNumber.substr(0, 2) === CardDataUtil._controlNumber.Discover2) {
      return _PaymentDevice.PaymentDevice.CardIssuer.Discover;
    }

    // PayPal
    if (cardNumber.length >= 2 && cardNumber.substr(0, 2) === CardDataUtil._controlNumber.PayPal) {
      return _PaymentDevice.PaymentDevice.CardIssuer.PayPal;
    }

    return _PaymentDevice.PaymentDevice.CardIssuer.Unknown;
  };

  /**
   * Get the display name for card issuer
   * @param cardIssuer
   * @returns {string}
   */


  CardDataUtil.getCardIssuerDisplayName = function getCardIssuerDisplayName(cardIssuer) {
    for (var issuerName in _PaymentDevice.PaymentDevice.CardIssuer) {
      if (_PaymentDevice.PaymentDevice.CardIssuer.hasOwnProperty(issuerName) && typeof CardIssuer !== 'function' && _PaymentDevice.PaymentDevice.CardIssuer[issuerName] === cardIssuer) {
        return issuerName;
      }
    }
    return null;
  };

  return CardDataUtil;
}();

/**
 * Card issuer control numbers
 */


CardDataUtil._controlNumber = {
  Visa: '4',
  MasterCard: '5',
  Amex1: '34',
  Amex2: '37',
  Discover1: '6011',
  Discover2: '65',
  PayPal: '62',
  Maestro1: '67',
  Maestro2: '50'
};
},{"./PaymentDevice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/PaymentDevice.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/DecisionRequired.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A decision is required to proceed with a transaction
 * @property deviceResponse The raw response from the device
 * @property apps An array of [id,name] pairs identifying applications to pick from
 */

var DecisionRequired = exports.DecisionRequired = function () {
  function DecisionRequired(deviceResponse) {
    _classCallCheck(this, DecisionRequired);

    this.deviceResponse = deviceResponse;
    this.apps = [];
  }

  DecisionRequired.prototype.toString = function toString() {
    /* eslint max-len: "off" */
    return "DecisionRequired: " + this.apps.length + " apps\nRaw Response: " + this.deviceResponse.toString();
  };

  return DecisionRequired;
}();
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/EmvDevice.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.NumericEntryOptions = exports.SecureEntryOptions = exports.EmvDevice = undefined;

var _PaymentDevice2 = require('./PaymentDevice');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Represents an EMV reader which may support contact and/or contactless
 * payments, swipes, PIN entry and more.
 * @class
 * @extends PaymentDevice
 * @property {EmvDevice.CardStatus} cardStatus The current state of the EMV card reader @readonly
 */

var EmvDevice = exports.EmvDevice = function (_PaymentDevice) {
  _inherits(EmvDevice, _PaymentDevice);

  function EmvDevice(uniqueId, native) {
    _classCallCheck(this, EmvDevice);

    var _this = _possibleConstructorReturn(this, _PaymentDevice.call(this, uniqueId, native));

    _this._native = 'EmvDevice';
    return _this;
  }

  /**
   * Prompt for a non-secure amount or numeric value to be entered.
   * @param {NumericEntryOptions} options Options governing numeric entry
   * @param {EmvDevice~amountEntered} callback Called when the attempt completes
   */


  EmvDevice.prototype.promptForNumericEntry = function promptForNumericEntry(options, callback) {
    callback(new Error('Should be implemented by the derived class'));
    throw new Error('Should be implemented by the derived class.');
  };

  /**
   * Get a secure Personal Account Number (PAN) from the device
   * @param {SecureEntryOptions} options
   * @param {EmvDevice~secureEntry} callback
   */


  EmvDevice.prototype.promptForSecureAccountNumber = function promptForSecureAccountNumber(options, callback) {
    callback(new Error('Should be implemented by the derived class'));
    throw new Error('Should be implemented by the derived class.');
  };

  /**
   * Start a contact-based card transaction
   * @private
   * @param {TransactionContext} context
   */


  EmvDevice.prototype.startContactTransaction = function startContactTransaction(context, callback) {
    callback(new Error('Should be implemented by the derived class'));
    throw new Error('Should be implemented by the derived class.');
  };

  return EmvDevice;
}(_PaymentDevice2.PaymentDevice);

/**
 * SecureEntryOptions specify which values you would like the SDK
 * to gather from the terminal and which you would like to just gather
 * on your own
 * @class
 * @property {bool} cvv true to gather the CVV value on terminal, false to skip that
 * @property {bool} expiration true to gather expiration month and year on terminal
 */


var SecureEntryOptions = exports.SecureEntryOptions = function SecureEntryOptions() {
  _classCallCheck(this, SecureEntryOptions);
};

/**
 * Options for asking for numeric entry on the EMV terminal. Because this is typically
 * a PIN entry device, you can't just display any message and get numeric entry
 * (e.g. "ENTER PIN" and then get the raw PIN). These options control and indicate
 * what you can ask for.
 * @class
 * @property {EmvDevice.NumericEntryType} entryType The overall type of numeric entry desired
 * @property {string} editValue The existing amount to edit, if any
 */


var NumericEntryOptions = exports.NumericEntryOptions = function NumericEntryOptions() {
  _classCallCheck(this, NumericEntryOptions);
};

/**
 * Called after a request for amount entry (via promptForAmountEntry) completes.
 * @callback EmvDevice~amountEntered
 * @param {error} error The error encountered - namely cancellation or lack of terminal support
 * @param {string} amount The amount entered
 */

/**
 * Called after a request to secure account number entry
 * @callback EmvDevice~secureEntry
 * @param {error} error The error encountered - namely cancellation or lack of terminal support
 * @param {ManuallyEnteredCard} card The card object representing the information entered.
 *  You may still need to gather more information such as CVV and/or expiration date
 */

/**
 * The current status of the contact based card reader
 * @enum {int}
 */


EmvDevice.CardStatus = {
  /**
   * There is no card inserted in the reader.
   */
  None: 0,
  /**
   * A card is inserted in the reader but it is not EMV
   */
  NonEmvCard: 1,
  /**
   * An EMV card is inserted in the reader
   */
  EmvCard: 3
};

/**
 * When you wish to get a numeric value from the device, you must specify precisely
 * which type of number you're asking for so that prompts and formats can be selected.
 * @enum {int}
 */
EmvDevice.NumericEntryType = {
  /**
   * A tip amount, in the local currency
   */
  GratuityAmount: 1,
  /**
   * A tip amount as a percentage of the current transaction total
   */
  GratuityPercentage: 2,
  /**
   * A mobile phone number
   */
  MobileNumber: 3,
  /**
   * Expiration date
   */
  ExpirationDate: 4,
  /**
   * Cardholder verification value
   */
  Cvv: 5
};
},{"./PaymentDevice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/PaymentDevice.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/MagneticCard.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.MagneticCard = undefined;

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _Card2 = require('./Card');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = (0, _manticoreLog2.default)('payment');

/**
 * Information about a card presented to the PayPal Retail SDK
 * @class
 * @extends Card
 * @property {string} pan The personal account number (usually masked)
 * @property {string} expiration The expiration date (YYMM)
 * @property {string} track1 Encrypted track1 data if available
 * @property {string} track2 Encrypted track2 data if available
 * @property {string} track3 Encrypted track3 data if available
 * @property {string} firstName Cardholder first name
 * @property {string} lastName Cardholder last name
 * @property {string} middleInitial Cardholder middle name
 * @property {string} ksn Key serial number of the reader used to interpret the track data
 * @property {bool} isSignatureRequired true if given the card and the context in which it
 *  was presented, a signature is required.
 */

var MagneticCard = exports.MagneticCard = function (_Card) {
  _inherits(MagneticCard, _Card);

  function MagneticCard() {
    _classCallCheck(this, MagneticCard);

    var _this = _possibleConstructorReturn(this, _Card.call(this));

    _this.nativeClass = 'MagneticCard';
    return _this;
  }

  MagneticCard.prototype.parseName = function parseName(name) {
    Log.debug('Not parsing ' + name);
  };

  return MagneticCard;
}(_Card2.Card);
},{"./Card":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/Card.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/MagneticReaderDevice.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.MagneticReaderDevice = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _PaymentDevice2 = require('./PaymentDevice');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = (0, _manticoreLog2.default)('payment');

/**
 * Represents a magnetic card reader with limited capabilities.
 * @class
 * @protected
 */

var MagneticReaderDevice = exports.MagneticReaderDevice = function (_PaymentDevice) {
  _inherits(MagneticReaderDevice, _PaymentDevice);

  function MagneticReaderDevice(uniqueName, native) {
    _classCallCheck(this, MagneticReaderDevice);

    // Connect to the reader and get details

    var _this = _possibleConstructorReturn(this, _PaymentDevice.call(this, uniqueName, native));

    _this.connect(function () {
      if (!_this.activated) {
        _this.disconnect();
      }
    });
    return _this;
  }

  MagneticReaderDevice.prototype.connect = function connect(callback) {
    var _this2 = this;

    if (this.native.isConnected()) {
      Log.debug(function () {
        return 'Connect called, but ' + _this2.id + ' is already connected.';
      });
      if (callback) {
        callback();
      }
    }
    Log.debug(function () {
      return 'Connecting to Magnetic Reader ' + _this2.id;
    });
    this.native.connect(function (error) {
      Log.debug(function () {
        return 'Connected to Magnetic Reader ' + _this2.id;
      });
      if (callback) {
        callback(error);
      }
    });
  };

  MagneticReaderDevice.prototype.disconnect = function disconnect(callback) {
    this.native.disconnect(callback);
  };

  /**
   * Data has been received from the device
   * @param {object} event
   */


  MagneticReaderDevice.prototype.received = function received(event) {
    if (event && event.type === 'start') {
      // Swipe started
    } else if (event && event.type === 'fail') {
        // Swipe failed
      } else if (event.formFactor) {
          if (!event.reader) {
            event.reader = this;
          }
          this.emit('cardPresented', event);
        }
  };

  _createClass(MagneticReaderDevice, [{
    key: 'formFactors',
    get: function get() {
      return [_PaymentDevice2.PaymentDevice.FormFactor.MagneticCardSwipe];
    }
  }]);

  return MagneticReaderDevice;
}(_PaymentDevice2.PaymentDevice);
},{"./PaymentDevice":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/PaymentDevice.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/ManuallyEnteredCard.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.ManuallyEnteredCard = undefined;

var _Card2 = require('./Card');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Certain regions support manual entry of credit card numbers. The retail SDK requires
 * that you use an EMV certified terminal to gather an encrypted PAN and when doing so,
 * an object of type ManuallyEnteredCard would be returned, which can be presented to
 * the backend services to collect payment
 * @class
 * @extends Card
 * @property {string} expiration The expiration date (YYMM)
 */

var ManuallyEnteredCard = exports.ManuallyEnteredCard = function (_Card) {
  _inherits(ManuallyEnteredCard, _Card);

  function ManuallyEnteredCard() {
    _classCallCheck(this, ManuallyEnteredCard);

    return _possibleConstructorReturn(this, _Card.apply(this, arguments));
  }

  /**
   * Provide the CVV on the card for use in sending to the server.
   * @param {string} cvv The cardholder verification value
   */

  ManuallyEnteredCard.prototype.setCvv = function setCvv(cvv) {
    this._cvv = cvv;
  };

  return ManuallyEnteredCard;
}(_Card2.Card);
},{"./Card":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/Card.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/PaymentDevice.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.PaymentDevice = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _manticoreLog = require('manticore-log');

var _manticoreLog2 = _interopRequireDefault(_manticoreLog);

var _events = require('events');

var _BatteryInfo = require('./BatteryInfo');

var _manticore = require('manticore');

var _manticore2 = _interopRequireDefault(_manticore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Log = (0, _manticoreLog2.default)('payment');

/*
 * The native application is responsible for discovering and communicating
 * with these devices. You are responsible for providing a native object which
 * implements connect/disconnect/isConnected/send functions and calls
 * received(bytes/events) on this object as appropriate.
 */

/**
 * A payment device represents the abstract concept of something that can read
 * payment information from a customer. This includes card swipe readers, EMV
 * readers, barcode scanners, biometric devices we don't have yet, and DNA
 * sequencers. Ok, not so much that last bit.
 *
 * @class
 * @property {string} id A unique identifier for the device
 * @property {string} name A friendly name for the device
 * @property {string} manufacturer The manufacturer of the card reader
 * @property {string} serialNumber The serial number of the device, if available
 * @property {BatteryInfo} batteryInfo Status of the device battery @readonly
 * @property {[PaymentDevice.FormFactor]} formFactors The payment form factors
 *  this device can support @readonly
 * @property {DeviceUpdate} pendingUpdate Any pending software update for
 *  this device, or null if the device is current
 */

var PaymentDevice = exports.PaymentDevice = function (_EventEmitter) {
  _inherits(PaymentDevice, _EventEmitter);

  /**
   * Construct a new PaymentDevice given a native function capable of sending
   *  data to the device
   * @param {string} uniqueId A unique identifier for this device, usually including
   *  type and serial number
   * @private
   */

  function PaymentDevice(uniqueId, native) {
    _classCallCheck(this, PaymentDevice);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.id = uniqueId;
    _this.native = native;
    _this.activated = false;
    return _this;
  }

  /**
   * Extract logs from the device.
   * @method
   * @param {PaymentDevice~callback} callback Called when the logs are extracted
   */


  PaymentDevice.prototype.extractReaderLogs = function extractReaderLogs(callback) {
    callback(new Error("Not implemented"));
  };

  /**
   * Called internally when a new device has been discovered to register the device
   * and notify listeners of the new device.
   * @private
   */


  PaymentDevice.discovered = function discovered(pd) {
    PaymentDevice.devices.push(pd);
    PaymentDevice.Events.emit('deviceDiscovered', pd);
  };

  /**
   * Called internally (by native) when the device has been removed from the system
   * @private
   */


  PaymentDevice.prototype.removed = function removed() {
    if (this.isConnected()) {
      this.disconnect();
    }
    var ix = PaymentDevice.devices.indexOf(this);
    if (ix >= 0) {
      PaymentDevice.devices.splice(ix, 1);
    }
    this.emit('deviceRemoved', this);
  };

  /**
   * Called internally when connection has been verified, but the device must
   * be updated before being ready
   * @private
   */


  PaymentDevice.prototype.updateRequired = function updateRequired(update) {
    Log.debug(this.id + ' needs an update.');
    this.pendingUpdate = update;
    this.emit(PaymentDevice.Event.updateRequired, update);
  };

  /**
   * Connect to the device and be ready for a payment attempt for the invoice
   * @private
   * @param {TransactionContext} invoice The invoice on which payment should be
   *  taken (may be blank/changing)
   */


  PaymentDevice.prototype.activate = function activate(context) {
    // TODO subscribe to invoice events.
    // TODO we need to look for the result of the device connect attempt
    this.activated = true;
    this.context = context;
    if (!this.isConnected()) {
      this.connect();
    }
  };

  /**
   * No longer needs to be active
   * @private
   */


  PaymentDevice.prototype.deactivate = function deactivate(context, shouldDisconnect, callback) {
    var cb = callback;
    if (this.context === context) {
      this.activated = false;
      this.context = null;
      if (shouldDisconnect) {
        this.disconnect(cb);
        cb = null;
      }
    }

    if (cb) {
      cb();
    }
  };

  /**
   * Connect to this device.
   * @method
   * @param {PaymentDevice~callback} callback Called when the connection
   *  attempt is complete
   */


  PaymentDevice.prototype.connect = function connect(callback) {
    var _this2 = this;

    this.beginDeviceConnect(function (err) {
      if (err) {
        Log.error('Connection with ' + _this2.id + ' failed with error ' + err);
        _this2.emit(PaymentDevice.Event.connectionError, err);
      } else {
        Log.debug(function () {
          return 'Successfully connected with ' + _this2.id;
        });
        _this2.onConnected();
      }

      if (callback) {
        callback(err);
      }
    });
  };

  /**
   * Called internally when connection sequence with this device was complete.
   * The device will be ready to be used if payments if the connection was verified
   * with no errors
   * @private
   */


  PaymentDevice.prototype.onConnected = function onConnected() {
    var _this3 = this;

    Log.debug(function () {
      return _this3.id + ' is ready.';
    });
    this.isReady = true;
    this.emit(PaymentDevice.Event.connected);
    this.startPollForBattery();
  };

  /**
   * Should be implemented by the deriving classes to perform the actual connection.
   * After a successful connection, the device should be ready to take payments
   * @param callback Callback that should be invoked on completion of connection
   * process with error (if any) as the first argument
   * @private
   */


  PaymentDevice.prototype.beginDeviceConnect = function beginDeviceConnect(callback) {
    var msg = 'Subclass must implement connection flow';
    callback(new Error(msg));
    throw new Error(msg);
  };

  PaymentDevice.prototype._continuallyPollForBattery = function _continuallyPollForBattery() {
    var _this4 = this;

    if (!this.isReady || !this.pollForBattery) {
      return;
    }
    this.getBatteryInfo(function (err, status) {
      if (status) {
        _this4.batteryStatus = new _BatteryInfo.BatteryInfo(status.batteryPercentage, status.connectedToPower, new Date());
        _this4.emit(PaymentDevice.Event.batteryStatusUpdate, _this4.batteryStatus);
      }

      // TODO - Make the polling smarter (e.g. You could poll less frequently
      // when the battery level is almost full)
      if (_this4.isReady && _this4.pollForBattery) {
        _manticore2.default.setTimeout(function () {
          return _this4._continuallyPollForBattery.call(_this4);
        }, 30 * 1000);
      }
    });
  };

  PaymentDevice.prototype.startPollForBattery = function startPollForBattery() {
    Log.debug('startPollForBattery');
    if (!this.pollForBattery) {
      this.pollForBattery = true;
      this._continuallyPollForBattery();
    }
  };

  PaymentDevice.prototype.stopPollForBattery = function stopPollForBattery() {
    this.pollForBattery = false;
    Log.debug('stopPollForBattery');
  };

  /**
   * Disconnect from the device.
   * @method
   * @param {PaymentDevice~callback} callback Called when the disconnection
   *  attempt is complete
   */


  PaymentDevice.prototype.disconnect = function disconnect(callback) {
    var _this5 = this;

    this.beginDeviceDisconnect(function (err) {
      if (err) {
        Log.warn(' ' + _this5.id + ' disconnect failed with error ' + err);
      } else {
        Log.debug(function () {
          return _this5.id + ' was successfully disconnected';
        });
        _this5.onDisconnected();
      }
      if (callback) {
        callback(err);
      }
    });
  };

  /**
   * Inform the Javascript class that the device has been disconnected.
   * @param {error} error Any error that caused disconnect
   * @private
   */


  PaymentDevice.prototype.onDisconnected = function onDisconnected(error) {
    var _this6 = this;

    Log.debug(function () {
      return 'Device ' + _this6.id + ' was disconnected';
    });
    this.isReady = false;
    this.stopPollForBattery();
    this.emit(PaymentDevice.Event.disconnected, error);
  };

  /**
   * Should be implemented by the deriving classes to perform the actual device disconnect.
   * The device should no longer be able to take payments after a successful disconnect
   * @param callback Callback that should be invoked on completion of disconnection
   * with error (if any) as the first argument
   * @private
   */


  PaymentDevice.prototype.beginDeviceDisconnect = function beginDeviceDisconnect(callback) {
    var msg = 'Subclass must implement disconnection flow';
    callback(new Error(msg));
    throw new Error(msg);
  };

  /**
   * Get supported formFactors for this device
   * @private
   */


  PaymentDevice.prototype.formFactors = function formFactors() {
    throw new Error('Subclass must implement formFactors');
  };

  /**
   * Reset the reader to a state where it is ready to begin a new transaction. The base class
   * throws an exception because your derivved class should implement.
   * @private
   */


  PaymentDevice.prototype.clearTransaction = function clearTransaction(callback) {
    var msg = 'Subclass must implement clearTranaction';
    callback(new Error(msg));
    throw new Error(msg);
  };

  /**
   * Attempt to cleanup any ties to native objects
   * @method
   * @private
   */


  PaymentDevice.prototype.destroy = function destroy() {
    this.native = null;
  };

  /**
   * Return true if this device is connected
   * @method
   * @returns {bool} true if the device is currently connected
   */


  PaymentDevice.prototype.isConnected = function isConnected() {
    return this.native.isConnected();
  };

  /**
   * Send bytes to this device
   * @method
   * @param {string} data The data to be sent
   * @param {string} format Describes the data format to be sent [utf8|base64|hex]
   * @private
   */


  PaymentDevice.prototype.send = function send(data, format) {
    _manticoreLog2.default.error('Unimplemented send', { data: data, format: format });
    throw new Error('Specific interface must implement send.');
  };

  /**
   * The format of this message is device specific
   * @method
   * @param data
   * @private
   */


  PaymentDevice.prototype.received = function received(data) {
    _manticoreLog2.default.error('Unimplemented receive', { data: data });
  };

  PaymentDevice.prototype.getBatteryInfo = function getBatteryInfo(callback) {
    var msg = 'Subclass must implement getBatteryInfo';
    callback(new Error(msg));
    throw new Error(msg);
  };

  /**
   * Display a predefined message on the terminal, if supported
   * @param {PaymentDevice.Message} messageIdentifier The message to display
   * @param {object} substitutions Values to replace in the string
   * @param {function} callback Called when the message has been displayed, with any error
   * @private
   */


  PaymentDevice.prototype.display = function display(messageIdentifier, substitutions, callback) {
    // No-op by default, no error
    callback(null);
  };

  /**
   * Look at an accessory connection and decide if we support it. Will differ a bit
   * on different platforms
   * @private
   * @method
   * @param {object} info
   */

  PaymentDevice.isSupported = function isSupported(info) {
    if (info.protocols.indexOf('com.paypal.here.reader') >= 0) {
      return 'MiuraDevice';
    }
    return null;
  };

  _createClass(PaymentDevice, [{
    key: 'invoice',
    get: function get() {
      return this.context ? this.context.invoice : null;
    }
  }]);

  return PaymentDevice;
}(_events.EventEmitter);

PaymentDevice.devices = [];

/**
 * A payment form factor describes the process used by the consumer to
 * communicate payment credentials to the merchant.
 * @enum {int}
 */
PaymentDevice.FormFactor = {
  /**
   * This value is returned if a given merchant and payment device share no
   * common accepted form factors.
   */
  None: 0,
  /**
   * The consumer (or merchant) swipes the consumer's magnetic card through a
   * magnetic card reader
   */
  MagneticCardSwipe: 5,
  /**
   * The consumer dips a card with a smart chip into a smart card reader (e.g. EMV Chip&PIN)
   */
  Chip: 10,
  /**
   * An EMV-certified contactless card is presented and read by an
   * EMV-certified contactless reader
   */
  EmvCertifiedContactless: 15,
  /**
   * A terminal capable of collecting and encrypting a manually entered
   * account number (aka PAN) was used to collect some or all of the
   * necessary information
   */
  SecureManualEntry: 20
};

/**
 * Issuer of the card that was presented to the SDK
 * @enum {int}
 */
PaymentDevice.CardIssuer = {
  /**
   * Unknown card issuer
   */
  Unknown: 0,

  /**
   * Visa credit/prepaid
   */
  Visa: 1,

  /**
   * Master card
   */
  MasterCard: 2,

  /**
   * Maestro
   */
  Maestro: 3,

  /**
   * American Express
   */
  Amex: 4,

  /**
   * Discover
   */
  Discover: 5,

  /**
   * PayPal
   */
  PayPal: 6
};

PaymentDevice.Event = {
  connected: 'connected',
  connectionError: 'connectionError',
  disconnected: 'disconnected',
  updateRequired: 'updateRequired',
  cardDataRead: 'cardDataRead',
  cardRemoved: 'cardRemoved',
  cardPresented: 'cardPresented',
  cancelled: 'cancelled',
  cancelRequested: 'cancelRequested',
  error: 'error',
  batteryStatusUpdate: 'batteryStatusUpdate',
  decisionRequired: 'decisionRequired',
  approval: 'approval',
  proceed: 'proceed',
  pinEvent: 'pinEvent'
};

/**
 * Indicates the maximum number of payment retries that are allowed per payment error event
 * @type {{InvalidChip: number}}
 * @private
 */
PaymentDevice.constant = {
  InvalidChipRetryCount: 2
};

/**
 * List of Auth codes that could be sent to the terminal in order to complete the transaction.
 * @type {{TrxnFailureAuthCode: string, TrxnSuccessAuthCode: string, NoNetworkAuthCode: string}}
 * @private
 */
PaymentDevice.authCode = {
  TransactionFailure: '8A023035',
  TransactionSuccess: '8A023030',
  NoNetwork: '8A025A33'
};

/**
 * The reader is now connected and ready.
 * @event PaymentDevice#connected
 */

/**
 * The connection attempt with the reader failed
 * @event PaymentDevice#connectionError
 * @param {error} error Any error that caused the connection failure
 */

/**
 * The reader is now disconnected.
 * @event PaymentDevice#disconnected
 * @param {error} error Any error that caused the disconnect
 */

/**
 * A software update is required for the reader.
 * @event PaymentDevice#updateRequired
 * @param {DeviceUpdate} update The update that should or must be applied
 */

/**
 * A card has been removed (generally from an EMV reader, where the card
 * stays in the reader for some time)
 * @event PaymentDevice#cardRemoved
 */

/**
 * Depending on your region and the buyer payment type, this can mean a magnetic card
 * was swiped, an EMV card was
 * inserted, or an NFC card/device was tapped.
 * @event PaymentDevice#cardPresented
 * @param {Card} card Information about the card.
 */

/**
 * @callback PaymentDevice~callback
 * @param {error} error Error (if any) that caused the action to fail
 */

// Used to fire the "global" deviceAdded event
PaymentDevice.Events = new _events.EventEmitter();

PaymentDevice.Message = {
  Connecting: 'Connecting',
  NotConnected: 'NotConnected',
  OrderInProgress: 'Order.InProgress',
  WaitForPayment: 'Order.Ready',
  ProcessingContact: 'Processing.Contact',
  PaidRemoveCard: 'Paid.RemoveCard',
  Paid: 'Paid.Successful',
  RefundRemoveCard: 'Refund.RemoveCard',
  Refund: 'Refund.Successful',
  Processing: 'Processing.Tap',
  ProcessingWithPin: 'Processing.PinOk',
  Complete: 'Complete',
  SignContact: 'Sign.Contact',
  SignTap: 'Sign.Tap',
  SoftwareUpdateRequired: 'SwUpdate.Required',
  SoftwareUpdateAvailable: 'SwUpdate.Available',
  SoftwareUpdateProgress: 'SwUpdate.Progress',
  SoftwareUpdateFailed: 'SwUpdate.Failed',
  Ready: 'Ready',
  NfcTimeOut: 'NfcTimeout',
  GeneralNfcFallback: 'GeneralNfcFallback',
  TransactionCancelled: 'TransactionCancelled',
  TransactionCancelling: 'TransactionCancelling',
  UnableToReadNfcCard: 'Declined.UnableToReadNfcCard',
  InvalidChipCard: 'Declined.InvalidChipCard',
  BlockedCardInserted: 'Declined.BlockedCardInserted',
  NfcDecline: 'Declined.NfcDecline',
  IncorrectPin: 'Declined.IncorrectPin',
  ContactIssuer: 'ContactIssuer',
  RechargeNow: 'RechargeNow',
  ReadyForInsertAndSwipePayment: 'ReadyForInsertAndSwipePayment',
  ReadyForInsertPayment: 'ReadyForInsertPayment',
  ReadyForSwipePayment: 'ReadyForSwipePayment',
  SignatureForInsert: 'Signature.Insert',
  SignatureForTap: 'Signature.Tap',
  SignatureForNonEmv: 'Signature.NonEmv',
  InvoiceTotal: 'InvoiceTotal',
  AmountTooLow: 'AmountTooLow',
  AmountTooHigh: 'AmountTooHigh',
  CompletingPayment: 'CompletingPayment',
  RequestTip: 'RequestTip',
  ConfirmTip: 'ConfirmTip'
};
},{"./BatteryInfo":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/BatteryInfo.js","events":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/events/events.js","manticore":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore/browser.js","manticore-log":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-log/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/PinEvent.js":[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Details about a change in status of PIN entry or validation
 * @property {bool} completed Whether PIN entry has completed
 * @property {bool} correct Whether the PIN is correct
 * @property {bool} isLastAttempt Whether this PIN attempt is the last
 *  attempt before a potential card lockout
 * @property {int} digits Number of digits entered
 * @property {string} failureReason The failure reason, if any
 */

var PinEvent = exports.PinEvent = function PinEvent() {
  _classCallCheck(this, PinEvent);
};
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/retail-payment-device/build/src/paymentDeviceError.js":[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.errorDomain = exports.deviceError = undefined;
exports.getError = getError;

var _manticorePaypalerror = require('manticore-paypalerror');

var domain = 'PaymentDevice';

/**
 * Usage: decorate(new Error(), paymentDeviceError.deviceError.genericError)
 */
function getError(error, info) {
  // TODO PayPalError.makeError should assign {message} after localization is implemented
  // This function would not be needed at that point
  error.message = info.message;
  return _manticorePaypalerror.PayPalError.makeError(error, info);
}

function payPalError(errDomain, code, message) {
  var error = {
    domain: errDomain,
    code: code,
    message: message,
    withDevMessage: function withDevMessage(msg) {
      error.developerMessage = msg;
      return error;
    },
    withDebugId: function withDebugId(id) {
      error.debugId = id;
      return error;
    }
  };

  return error;
}

/**
 * All payment device errors belong here
 */
var deviceError = exports.deviceError = {
  generic: payPalError(domain, 0, 'Generic error'),
  nfcTimeout: payPalError(domain, 1, 'Contactless reader timed out waiting for payment presentation'),
  nfcNotAllowed: payPalError(domain, 2, 'Contactless payment not allowed on this card'),
  tryDifferentCard: payPalError(domain, 3, 'Try different card'),
  mustInsertCard: payPalError(domain, 4, 'Must insert presented card'),
  mustSwipeCard: payPalError(domain, 5, 'Must swipe presented card'),
  hardwareError: payPalError(domain, 6, 'Hardware error'),
  cardBlocked: payPalError(domain, 7, 'Presented card is blocked'),
  contactIssuer: payPalError(domain, 8, 'Payment was declined. Contact issuer'),
  invalidChip: payPalError(domain, 9, 'Chip is invalid'),
  cannotSwipeChipCard: payPalError(domain, 10, 'Cannot swipe a chip card'),
  smartCardNotInSlot: payPalError(domain, 11, 'Card not in slot'),
  paymentCancelled: payPalError(domain, 12, 'Payment was cancelled'),
  contactlessPaymentAbortedByCardInsert: payPalError(domain, 13, 'Contactless payment was aborted by card insert'),
  contactlessPaymentAbortedByCardSwipe: payPalError(domain, 14, 'Contactless payment was aborted by card swipe'),
  badEmvData: payPalError(domain, 15, 'Bad EMV data'),
  deviceNotConnected: payPalError(domain, 16, 'Device not connected'),
  cannotAcceptMessage: payPalError(domain, 17, 'Device cannot accept messages in its current state'),
  actionCancelled: payPalError(domain, 18, 'Action was cancelled'),
  secureEntryFailed: payPalError(domain, 19, 'Secure entry failed'),
  numericEntryFailed: payPalError(domain, 20, 'Numeric entry failed'),
  dataValidationError: payPalError(domain, 21, 'Data validation error'),
  unexpectedResponse: payPalError(domain, 22, 'Received unexpected response'),
  failureResponse: payPalError(domain, 23, 'Received failure response'),
  dataRetrievalFailed: payPalError(domain, 24, 'Failed to retrieve expected data'),
  lowOnBattery: payPalError(domain, 25, 'Battery Low'),
  fileNotFound: payPalError(domain, 26, 'Unable to retrieve the file from the device'),
  fileImportFailed: payPalError(domain, 27, 'File import failed'),
  initializationFailed: payPalError(domain, 28, 'Device initialization failed'),
  tipEntryFailed: payPalError(domain, 29, 'Tip entry failed')
};

exports.errorDomain = domain;
},{"manticore-paypalerror":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/manticore-paypalerror/build/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/index.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var Tlv = exports.Tlv = require('./lib/Tlv').default;
var TlvList = exports.TlvList = require('./lib/TlvList').default;
var Tags = exports.Tags = require('./lib/Tags').default;
var ValueFormat = exports.ValueFormat = require('./lib/ValueFormat').default;
var DefinedTag = exports.DefinedTag = require('./lib/DefinedTag').default;
var ApduCommand = exports.ApduCommand = require('./lib/apdu/Command').default;
var ApduResponse = exports.ApduResponse = require('./lib/apdu/Response').default;
},{"./lib/DefinedTag":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/DefinedTag.js","./lib/Tags":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/Tags.js","./lib/Tlv":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/Tlv.js","./lib/TlvList":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/TlvList.js","./lib/ValueFormat":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/ValueFormat.js","./lib/apdu/Command":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/apdu/Command.js","./lib/apdu/Response":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/apdu/Response.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/DefinedTag.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ValueFormat = require('./ValueFormat');

var _ValueFormat2 = _interopRequireDefault(_ValueFormat);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var allTags = {};
var tagsByName = {};

/**
 * A defined tag represents a TLV format tag with a known type and purpose.
 * Because the TLV format will accommodate any "tag id," not all TLVs encountered
 * in a message will have a matching DefinedTag
 * @class
 * @property {string} name The name of the tag @readOnly
 * @property {int} number The numeric 'index' of this tag @readOnly
 * @property {ValueFormat} format The format of values of this type @readOnly
 * @property {int} length (optional) the length of the value, if fixed @readOnly
 * @property {bool} addToKnownTags (optional) if ===false, do not add this to the
 *  tags for findTag/findTags.
 */

var DefinedTag = function () {
  function DefinedTag(name, number, format, length) {
    var addToKnownTags = arguments.length <= 4 || arguments[4] === undefined ? true : arguments[4];

    _classCallCheck(this, DefinedTag);

    this.name = name;
    this.number = number;
    this.format = format;
    this.length = length;
    if (addToKnownTags !== false) {
      if (allTags[number]) {
        allTags[number].push(this);
      } else {
        allTags[number] = [this];
      }
      tagsByName[name] = this;
    }
  }

  _createClass(DefinedTag, [{
    key: 'valueFromBytes',
    value: function valueFromBytes(bytes) {
      return this.format ? this.format.fromBytes(bytes, this.length) : bytes;
    }
  }, {
    key: 'valueToBytes',
    value: function valueToBytes(value) {
      return this.format.toBytes(value, this.length);
    }
  }], [{
    key: 'findTags',
    value: function findTags(number) {
      if (allTags[number]) {
        return allTags[number];
      }
      return [new DefinedTag('UnknownTag', number, _ValueFormat2.default.Binary, null, false)];
    }
  }, {
    key: 'getTagsByName',
    value: function getTagsByName() {
      return tagsByName;
    }
  }, {
    key: 'findTag',
    value: function findTag(number) {
      return DefinedTag.findTags(number)[0];
    }
  }]);

  return DefinedTag;
}();

exports.default = DefinedTag;
},{"./ValueFormat":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/ValueFormat.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/Tags.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnknownTag = exports.UnpredictableNumberAlternate = exports.UnpredictableNumber = exports.TransactionStatusInformation = exports.TransactionSequenceCounter = exports.TransactionType = exports.TransactionTime = exports.TransactionDate = exports.TransactionCurrencyCode = exports.Track2UnpredictableNumberAndAttackCounterPosition = exports.Track2NumberOfATCDigits = exports.Track2Cvc3Position = exports.Track2Cvc3 = exports.Track2 = exports.Track1UnpredictableNumberAndAttackCounterPosition = exports.Track1NumberOfATCDigits = exports.Track1Cvc3Position = exports.Track1Cvc3 = exports.Track1 = exports.TerminalVerificationResults = exports.TerminalType = exports.TerminalTransactionQualifiers = exports.TerminalIdentification = exports.TerminalCountryCode = exports.TerminalCapabilities = exports.TerminalApplicationIdentifier = exports.ServiceCode = exports.ProcessingDataObjectList = exports.MsdOffset = exports.MobileSupportIndicator = exports.LanguagePreference = exports.IssuerCountryCode = exports.IssuerCodeTableIndex = exports.IssuerApplicationData = exports.IssuerAuthenticationData = exports.InterfaceDeviceSerialNumber = exports.FciProprietaryData = exports.FciProprietaryTemplate = exports.DfNameRaw = exports.DfNameAscii = exports.CryptogramInformationData = exports.CardTransactionQualifiers = exports.CardholderVerificationMethodResults = exports.CardholderNameExtended = exports.CardholderName = exports.CardCvmLimit = exports.CardAuthenticationRelatedData = exports.AuthorizationResponseCode = exports.ApplicationVersionNumber = exports.ApplicationTransactionCounter = exports.ApplicationTemplate = exports.ApplicationPriorityIndicator = exports.ApplicationPreferredName = exports.ApplicationPanSequenceCode = exports.ApplicationLabel = exports.ApplicationInterchangeProfile = exports.ApplicationIdentifier = exports.ApplicationFileLocator = exports.ApplicationExpirationDate = exports.ApplicationCryptogram = exports.AmountOther = exports.AmountAuthorized = undefined;

var _DefinedTag = require('./DefinedTag');

var _DefinedTag2 = _interopRequireDefault(_DefinedTag);

var _ValueFormat = require('./ValueFormat');

var _ValueFormat2 = _interopRequireDefault(_ValueFormat);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * DO NOT EDIT THIS FILE, IT IS AUTOMATICALLY GENERATED BY gulpfile.js
**/
var AmountAuthorized = exports.AmountAuthorized = new _DefinedTag2.default('AmountAuthorized', 0x9F02, _ValueFormat2.default.CompressedNumeric);
var AmountOther = exports.AmountOther = new _DefinedTag2.default('AmountOther', 0x9F03, _ValueFormat2.default.CompressedNumeric);
var ApplicationCryptogram = exports.ApplicationCryptogram = new _DefinedTag2.default('ApplicationCryptogram', 0x9f26, _ValueFormat2.default.Binary);
var ApplicationExpirationDate = exports.ApplicationExpirationDate = new _DefinedTag2.default('ApplicationExpirationDate', 0x5f24, _ValueFormat2.default.Date);
var ApplicationFileLocator = exports.ApplicationFileLocator = new _DefinedTag2.default('ApplicationFileLocator', 0x94, _ValueFormat2.default.Binary);
var ApplicationIdentifier = exports.ApplicationIdentifier = new _DefinedTag2.default('ApplicationIdentifier', 0x4F, _ValueFormat2.default.Binary);
var ApplicationInterchangeProfile = exports.ApplicationInterchangeProfile = new _DefinedTag2.default('ApplicationInterchangeProfile', 0x82, _ValueFormat2.default.Binary, 2);
var ApplicationLabel = exports.ApplicationLabel = new _DefinedTag2.default('ApplicationLabel', 0x50, _ValueFormat2.default.AlphaWithSpace);
var ApplicationPanSequenceCode = exports.ApplicationPanSequenceCode = new _DefinedTag2.default('ApplicationPanSequenceCode', 0x5f34, _ValueFormat2.default.Numeric, 2);
var ApplicationPreferredName = exports.ApplicationPreferredName = new _DefinedTag2.default('ApplicationPreferredName', 0x9f12, _ValueFormat2.default.AlphaWithSpace);
var ApplicationPriorityIndicator = exports.ApplicationPriorityIndicator = new _DefinedTag2.default('ApplicationPriorityIndicator', 0x87, _ValueFormat2.default.Binary, 1);
var ApplicationTemplate = exports.ApplicationTemplate = new _DefinedTag2.default('ApplicationTemplate', 0x61, _ValueFormat2.default.Tlv);
var ApplicationTransactionCounter = exports.ApplicationTransactionCounter = new _DefinedTag2.default('ApplicationTransactionCounter', 0x9F36, _ValueFormat2.default.Binary, 2);
var ApplicationVersionNumber = exports.ApplicationVersionNumber = new _DefinedTag2.default('ApplicationVersionNumber', 0x9F09, _ValueFormat2.default.Binary, 2);
var AuthorizationResponseCode = exports.AuthorizationResponseCode = new _DefinedTag2.default('AuthorizationResponseCode', 0x8A, _ValueFormat2.default.AlphaNumeric, 2);
var CardAuthenticationRelatedData = exports.CardAuthenticationRelatedData = new _DefinedTag2.default('CardAuthenticationRelatedData', 0x9F69, _ValueFormat2.default.Dol);
var CardCvmLimit = exports.CardCvmLimit = new _DefinedTag2.default('CardCvmLimit', 0x9f6b, _ValueFormat2.default.Binary);
var CardholderName = exports.CardholderName = new _DefinedTag2.default('CardholderName', 0x5F20, _ValueFormat2.default.AlphaWithSpace);
var CardholderNameExtended = exports.CardholderNameExtended = new _DefinedTag2.default('CardholderNameExtended', 0x9F0B, _ValueFormat2.default.AlphaWithSpace);
var CardholderVerificationMethodResults = exports.CardholderVerificationMethodResults = new _DefinedTag2.default('CardholderVerificationMethodResults', 0x9F34, _ValueFormat2.default.Binary);
var CardTransactionQualifiers = exports.CardTransactionQualifiers = new _DefinedTag2.default('CardTransactionQualifiers', 0x9F6C, _ValueFormat2.default.Binary, 2);
var CryptogramInformationData = exports.CryptogramInformationData = new _DefinedTag2.default('CryptogramInformationData', 0x9f27, _ValueFormat2.default.Binary, 1);
var DfNameAscii = exports.DfNameAscii = new _DefinedTag2.default('DfNameAscii', 0x84, _ValueFormat2.default.Alpha);
var DfNameRaw = exports.DfNameRaw = new _DefinedTag2.default('DfNameRaw', 0x84, _ValueFormat2.default.Binary);
var FciProprietaryTemplate = exports.FciProprietaryTemplate = new _DefinedTag2.default('FciProprietaryTemplate', 0xA5, _ValueFormat2.default.Tlv);
var FciProprietaryData = exports.FciProprietaryData = new _DefinedTag2.default('FciProprietaryData', 0xBF0C, _ValueFormat2.default.Tlv);
var InterfaceDeviceSerialNumber = exports.InterfaceDeviceSerialNumber = new _DefinedTag2.default('InterfaceDeviceSerialNumber', 0x9F1E, _ValueFormat2.default.AlphaNumeric);
var IssuerAuthenticationData = exports.IssuerAuthenticationData = new _DefinedTag2.default('IssuerAuthenticationData', 0x91, _ValueFormat2.default.Binary);
var IssuerApplicationData = exports.IssuerApplicationData = new _DefinedTag2.default('IssuerApplicationData', 0x9f10, _ValueFormat2.default.Binary);
var IssuerCodeTableIndex = exports.IssuerCodeTableIndex = new _DefinedTag2.default('IssuerCodeTableIndex', 0x9F11, _ValueFormat2.default.Numeric);
var IssuerCountryCode = exports.IssuerCountryCode = new _DefinedTag2.default('IssuerCountryCode', 0x5f28, _ValueFormat2.default.Numeric);
var LanguagePreference = exports.LanguagePreference = new _DefinedTag2.default('LanguagePreference', 0x5F2D, _ValueFormat2.default.Alpha);
var MobileSupportIndicator = exports.MobileSupportIndicator = new _DefinedTag2.default('MobileSupportIndicator', 0x9F7E, _ValueFormat2.default.Binary, 1);
var MsdOffset = exports.MsdOffset = new _DefinedTag2.default('MsdOffset', 0x9f67, _ValueFormat2.default.Binary);
var ProcessingDataObjectList = exports.ProcessingDataObjectList = new _DefinedTag2.default('ProcessingDataObjectList', 0x9F38, _ValueFormat2.default.Dol);
var ServiceCode = exports.ServiceCode = new _DefinedTag2.default('ServiceCode', 0x5f30, _ValueFormat2.default.Numeric);
var TerminalApplicationIdentifier = exports.TerminalApplicationIdentifier = new _DefinedTag2.default('TerminalApplicationIdentifier', 0x9f06, _ValueFormat2.default.Binary);
var TerminalCapabilities = exports.TerminalCapabilities = new _DefinedTag2.default('TerminalCapabilities', 0x9f33, _ValueFormat2.default.Binary);
var TerminalCountryCode = exports.TerminalCountryCode = new _DefinedTag2.default('TerminalCountryCode', 0x9F1A, _ValueFormat2.default.Numeric);
var TerminalIdentification = exports.TerminalIdentification = new _DefinedTag2.default('TerminalIdentification', 0x9F1C, _ValueFormat2.default.Alpha);
var TerminalTransactionQualifiers = exports.TerminalTransactionQualifiers = new _DefinedTag2.default('TerminalTransactionQualifiers', 0x9f66, _ValueFormat2.default.Binary);
var TerminalType = exports.TerminalType = new _DefinedTag2.default('TerminalType', 0x9f35, _ValueFormat2.default.Numeric);
var TerminalVerificationResults = exports.TerminalVerificationResults = new _DefinedTag2.default('TerminalVerificationResults', 0x95, _ValueFormat2.default.Binary);
var Track1 = exports.Track1 = new _DefinedTag2.default('Track1', 0x56, _ValueFormat2.default.Alpha);
var Track1Cvc3 = exports.Track1Cvc3 = new _DefinedTag2.default('Track1Cvc3', 0x9F60, _ValueFormat2.default.Binary, 2);
var Track1Cvc3Position = exports.Track1Cvc3Position = new _DefinedTag2.default('Track1Cvc3Position', 0x9F62, _ValueFormat2.default.Binary);
var Track1NumberOfATCDigits = exports.Track1NumberOfATCDigits = new _DefinedTag2.default('Track1NumberOfATCDigits', 0x9F64, _ValueFormat2.default.Binary, 1);
var Track1UnpredictableNumberAndAttackCounterPosition = exports.Track1UnpredictableNumberAndAttackCounterPosition = new _DefinedTag2.default('Track1UnpredictableNumberAndAttackCounterPosition', 0x9F63, _ValueFormat2.default.Binary);
var Track2 = exports.Track2 = new _DefinedTag2.default('Track2', 0x9F6B, _ValueFormat2.default.Numeric);
var Track2Cvc3 = exports.Track2Cvc3 = new _DefinedTag2.default('Track2Cvc3', 0x9F61, _ValueFormat2.default.Binary, 2);
var Track2Cvc3Position = exports.Track2Cvc3Position = new _DefinedTag2.default('Track2Cvc3Position', 0x9F65, _ValueFormat2.default.Binary);
var Track2NumberOfATCDigits = exports.Track2NumberOfATCDigits = new _DefinedTag2.default('Track2NumberOfATCDigits', 0x9F67, _ValueFormat2.default.Binary, 1);
var Track2UnpredictableNumberAndAttackCounterPosition = exports.Track2UnpredictableNumberAndAttackCounterPosition = new _DefinedTag2.default('Track2UnpredictableNumberAndAttackCounterPosition', 0x9F66, _ValueFormat2.default.Binary);
var TransactionCurrencyCode = exports.TransactionCurrencyCode = new _DefinedTag2.default('TransactionCurrencyCode', 0x5F2A, _ValueFormat2.default.CompressedNumeric, 2);
var TransactionDate = exports.TransactionDate = new _DefinedTag2.default('TransactionDate', 0x9A, _ValueFormat2.default.Date);
var TransactionTime = exports.TransactionTime = new _DefinedTag2.default('TransactionTime', 0x9F21, _ValueFormat2.default.Time);
var TransactionType = exports.TransactionType = new _DefinedTag2.default('TransactionType', 0x9C, _ValueFormat2.default.CompressedNumeric);
var TransactionSequenceCounter = exports.TransactionSequenceCounter = new _DefinedTag2.default('TransactionSequenceCounter', 0x9F41, _ValueFormat2.default.Numeric, 4);
var TransactionStatusInformation = exports.TransactionStatusInformation = new _DefinedTag2.default('TransactionStatusInformation', 0x9B, _ValueFormat2.default.Binary, 2);
var UnpredictableNumber = exports.UnpredictableNumber = new _DefinedTag2.default('UnpredictableNumber', 0x9f37, _ValueFormat2.default.Binary);
var UnpredictableNumberAlternate = exports.UnpredictableNumberAlternate = new _DefinedTag2.default('UnpredictableNumberAlternate', 0x9F6A, _ValueFormat2.default.Binary);
var UnknownTag = exports.UnknownTag = new _DefinedTag2.default('UnknownTag', 0x7FFFFFFF, _ValueFormat2.default.Binary);

exports.default = _DefinedTag2.default.getTagsByName();
},{"./DefinedTag":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/DefinedTag.js","./ValueFormat":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/ValueFormat.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/Tlv.js":[function(require,module,exports){
(function (Buffer){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ber = require('./ber');

var _ber2 = _interopRequireDefault(_ber);

var _DefinedTag = require('./DefinedTag');

var _DefinedTag2 = _interopRequireDefault(_DefinedTag);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A single tag/length/value entry with binary data
 * @class
 * @property {DefinedTag} tag The "defined tag" for this TLV, if known
 * @property {int} tagNumber The raw tag number for this TLV
 * @property {Buffer} bytes The raw bytes of the TLV
 * @property {object} value The value as parsed by ValueFormat for the defined tag. You
 * must call parse() first before this is available
 */

var Tlv = function () {
  function Tlv(tagOrTagNumber, bytes) {
    _classCallCheck(this, Tlv);

    if (tagOrTagNumber instanceof _DefinedTag2.default) {
      this.tag = tagOrTagNumber;
      this.tagNumber = tagOrTagNumber.number;
    } else {
      this.tagNumber = tagOrTagNumber;
      this.tag = _DefinedTag2.default.findTag(tagOrTagNumber);
    }
    if (!Buffer.isBuffer(bytes)) {
      this.bytes = this.tag.valueToBytes(bytes);
    } else {
      this.bytes = bytes;
    }
  }

  _createClass(Tlv, [{
    key: 'parse',
    value: function parse() {
      if (!this.hasOwnProperty('value')) {
        this.value = this.tag.valueFromBytes(this.bytes);
      }
      return this.value;
    }
  }, {
    key: 'toBytes',
    value: function toBytes() {
      var parts = [_ber2.default.encodeTag(this.tagNumber), _ber2.default.encodeLength(this.bytes ? this.bytes.length : 0)];
      if (this.bytes) {
        parts.push(this.bytes);
      }
      return Buffer.concat(parts);
    }
  }, {
    key: 'toString',
    value: function toString(shouldParse) {
      var parts = ['  Tag 0x', this.tagNumber.toString(16)];
      if (this.tag && this.tag.name) {
        parts.push(' ');
        parts.push(this.tag.name);
      }
      parts.push(': ');
      if (this.value || shouldParse) {
        if (Buffer.isBuffer(this.parse())) {
          parts.push('0x');
          parts.push(this.value.toString('hex'));
        } else {
          parts.push(this.value.toString());
        }
      } else if (this.bytes) {
        parts.push('0x');
        parts.push(this.bytes.toString('hex'));
      } else {
        parts.push('<empty>');
      }
      return parts.join('');
    }
  }], [{
    key: 'readLength',
    value: function readLength(bytes, startPosition) {
      return _ber2.default.readLength(bytes, startPosition);
    }
  }]);

  return Tlv;
}();

exports.default = Tlv;
}).call(this,require("buffer").Buffer)
},{"./DefinedTag":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/DefinedTag.js","./ber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/ber.js","buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/TlvList.js":[function(require,module,exports){
(function (Buffer){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tlv = require('./Tlv');

var _Tlv2 = _interopRequireDefault(_Tlv);

var _DefinedTag = require('./DefinedTag');

var _DefinedTag2 = _interopRequireDefault(_DefinedTag);

var _ber = require('./ber');

var _ber2 = _interopRequireDefault(_ber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lengthCheck(index, start, length, message) {
  console.log("==== Index : " + index);
  console.log("==== Start : " + start);
  console.log("==== length : " + length);
  console.log("==== message : " + message);
  if (index > start + length) {
    throw new Error(message);
  }
}

var TlvList = function () {
  function TlvList(bufferOrNull, start, length) {
    _classCallCheck(this, TlvList);

    this.values = [];
    if (bufferOrNull) {
      this._parse(bufferOrNull, start, length);
    }
  }

  _createClass(TlvList, [{
    key: '_parse',
    value: function _parse(buffer) {
      var start = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
      var length = arguments.length <= 2 || arguments[2] === undefined ? buffer.length - start : arguments[2];

      var index = start;
      while (index < start + length) {
        var tagData = _ber2.default.readTag(buffer, index);
        index += tagData.length;
        lengthCheck(index, start, length, 'Invalid TLV - tag ends buffer.');
        var lenData = _ber2.default.readLength(buffer, index);
        index += lenData.lengthOfEncoding;
        lengthCheck(index, start, length, 'Invalid TLV - tag value length ends buffer.');
        var value = void 0;
        if (lenData.lengthValue) {
          console.log("==== length value : " + lenData.lengthValue);
          lengthCheck(index + lenData.lengthValue, start, length, 'Invalid TLV - value overruns buffer.');
          value = buffer.slice(index, index + lenData.lengthValue);
          index += lenData.lengthValue;
        }
        var tags = _DefinedTag2.default.findTags(tagData.number);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = tags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var t = _step.value;

            this.values.push(new _Tlv2.default(t, value));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
  }, {
    key: 'add',
    value: function add(tlvOrTag, valueOrNull) {
      if (tlvOrTag instanceof _DefinedTag2.default) {
        this.values.push(new _Tlv2.default(tlvOrTag, valueOrNull));
      } else if (tlvOrTag instanceof _Tlv2.default) {
        this.values.push(tlvOrTag);
      } else if (!Buffer.isBuffer(valueOrNull)) {
        throw new Error('Add must be called with a tag and value, or a tag number and buffer.');
      } else {
        this.values.push(new _Tlv2.default(_DefinedTag2.default.findTag(tlvOrTag), valueOrNull));
      }
    }

    /**
     * Find a tag in the list of values.
     * @param tag
     * @param skip For multiple tags, pass a non-zero skip value
     * @returns {*}
     */

  }, {
    key: 'find',
    value: function find(tag, skip) {
      var toSkip = skip || 0;
      var findNumber = tag.number || tag;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.values[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var tlv = _step2.value;

          if (tlv.tagNumber === findNumber) {
            if (toSkip > 0) {
              toSkip--;
            } else {
              return tlv;
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return null;
    }
  }, {
    key: 'toBytes',
    value: function toBytes() {
      // TODO this isn't right anymore...
      var parts = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.values[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var tlv = _step3.value;

          parts.push(tlv.toBytes());
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return Buffer.concat(parts);
    }
  }, {
    key: 'toString',
    value: function toString(shouldParse) {
      var parts = ['TLV:'];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.values[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var tlv = _step4.value;

          if (Buffer.isBuffer(tlv)) {
            parts.push(tlv.toString('hex'));
          } else {
            parts.push(tlv.toString(shouldParse));
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return parts.join('\n');
    }
  }, {
    key: 'length',
    get: function get() {
      return this.values.length;
    }
  }]);

  return TlvList;
}();

exports.default = TlvList;
}).call(this,require("buffer").Buffer)
},{"./DefinedTag":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/DefinedTag.js","./Tlv":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/Tlv.js","./ber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/ber.js","buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/ValueFormat.js":[function(require,module,exports){
(function (Buffer){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Delay load this one to avoid circular dependency
var TlvList = void 0;

function fromBytes(buf, len) {
  if (len && buf && buf.length !== len) {
    var b = new Buffer(len);
    buf.copy(b);
    return b;
  }
  return buf;
}

function toBytes(bytes, len) {
  if (len && (!bytes || bytes.length !== len)) {
    var b = new Buffer(len);
    if (bytes) {
      bytes.copy(b);
    }
    return b;
  }
  return bytes;
}

function fromUtf8(buf) {
  return buf.toString('utf8');
}

function toUtf8(val) {
  return new Buffer(val, 'utf8');
}

function toValidHexBytes(val, length) {
  if (Buffer.isBuffer(val)) {
    return val;
  }
  var strval = String(val);
  if (strval.length % 2 === 1) {
    strval = '0' + strval;
  }
  while (length && strval.length < length * 2) {
    strval = '00' + strval;
  }
  return new Buffer(strval, 'hex');
}

/**
 * Encoding/decoding utilities for Javascript to TLV type mapping
 */
exports.default = {
  Alpha: {
    fromBytes: fromUtf8,
    toBytes: toUtf8
  },
  AlphaNumeric: {
    fromBytes: fromUtf8,
    toBytes: toUtf8
  },
  AlphaWithSpace: {
    fromBytes: fromUtf8,
    toBytes: toUtf8
  },
  Binary: {
    fromBytes: fromBytes,
    toBytes: toBytes
  },
  Date: {
    // YYMMDD
    fromBytes: function fromBytes(buf) {
      if (buf.length < 3) {
        throw new Error('Invalid date format.');
      }
      var hex = buf.toString('hex');
      // y,m,d
      return new Date(2000 + parseInt(hex.substring(0, 2), 10), parseInt(hex.substring(2, 4) - 1, 10), parseInt(hex.substring(4, 6), 10));
    },
    toBytes: function toBytes(date) {
      var hexstr = [];
      [date.getFullYear() - 2000, date.getMonth() + 1, date.getDate()].forEach(function (v) {
        if (v < 10) {
          hexstr.push('0');
        }
        hexstr.push(String(v));
      });
      return new Buffer(hexstr.join(''), 'hex');
    }
  },
  Time: {
    // HHmmss
    fromBytes: function fromBytes(buf) {
      if (buf.length < 3) {
        throw new Error('Invalid time format.');
      }
      var hex = buf.toString('hex');
      // hr, min, ss
      return new Date(2000, 1, 1, parseInt(hex.substring(0, 2), 10), parseInt(hex.substring(2, 4), 10), parseInt(hex.substring(4, 6), 10));
    },
    toBytes: function toBytes(date) {
      var hexstr = [];
      [date.getHours(), date.getMinutes(), date.getSeconds()].forEach(function (v) {
        if (v < 10) {
          hexstr.push('0');
        }
        hexstr.push(String(v));
      });
      return new Buffer(hexstr.join(''), 'hex');
    }
  },
  // Otherwise known as BCD?
  CompressedNumeric: {
    fromBytes: function fromBytes(buf) {
      return parseInt(buf.toString('hex'), 10);
    },
    toBytes: toValidHexBytes
  },
  // 0-9A-F
  CompressedAlpha: {
    fromBytes: function fromBytes(buf) {
      return buf.toString('hex');
    },
    toBytes: toValidHexBytes
  },
  Numeric: {
    fromBytes: function fromBytes(buf) {
      var v = 0;
      for (var i = 0; i < buf.length; i++) {
        v = v << 8;
        v += buf[i];
      }
      return v;
    },
    toBytes: function toBytes(val) {
      var len = arguments.length <= 1 || arguments[1] === undefined ? 4 : arguments[1];

      var buf = new Buffer(len);
      var remaining = val;
      for (var i = 0; i < len; i++) {
        buf[len - i - 1] = remaining & 0xFF;
        remaining = remaining >> 8;
      }
      return buf;
    }
  },
  TypeLengthValueList: {
    fromBytes: function fromBytes(buf) {
      if (!TlvList) {
        TlvList = require('./TlvList').default;
      }
      return new TlvList(buf);
    },
    toBytes: function toBytes(tlv) {
      return tlv.toBytes();
    }
  },
  DataObjectList: {}
};
}).call(this,require("buffer").Buffer)
},{"./TlvList":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/TlvList.js","buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/apdu/Command.js":[function(require,module,exports){
(function (Buffer){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ApduCommand = function () {
  /**
   * Create a new ApduCommand either from a data buffer (i.e. parse it)
   * or from command/instruction/p1/p2 with a blank buffer.
   * @param bufferOrCommandClass
   * @param instruction
   * @param p1
   * @param p2
   */

  function ApduCommand(bufferOrCommandClass, instruction, p1, p2, data, le) {
    _classCallCheck(this, ApduCommand);

    this.preamble = new Buffer(4);
    if (data) {
      if (Buffer.isBuffer(data)) {
        this.data = [data];
      } else {
        // Better be an array...
        this.data = data;
      }
    } else {
      this.data = null;
    }
    // This is the common case. Use expectNoBytes property to set it to null and not send the byte.
    this.le = 0;
    if (Buffer.isBuffer(bufferOrCommandClass)) {
      // Parse an Apdu Command
    } else {
        // Create a new Apdu Command
        this.commandClass = bufferOrCommandClass;
        this.instruction = instruction;
        this.p1 = p1 || 0;
        this.p2 = p2 || 0;
        if (le !== undefined) {
          this.le = le;
        }
      }
  }

  _createClass(ApduCommand, [{
    key: 'expectNoBytes',
    value: function expectNoBytes() {
      this.le = null;
    }
  }, {
    key: 'appendHex',
    value: function appendHex(hexString) {
      this.data = this.data || [];
      this.data.push(new Buffer(hexString, 'hex'));
    }
  }, {
    key: 'appendBytes',
    value: function appendBytes(buffer) {
      this.data = this.data || [];
      this.data.push(buffer);
    }
  }, {
    key: 'appendString',
    value: function appendString(utf8String) {
      this.data = this.data || [];
      this.data.push(new Buffer(utf8String, 'utf8'));
    }
  }, {
    key: 'toBytes',
    value: function toBytes() {
      var parts = [this.preamble];

      // https://en.wikipedia.org/wiki/Smart_card_application_protocol_data_unit
      var len = 0;
      if (this.data) {
        parts.push(null);
        this.data.forEach(function (p) {
          len += p.length;
          parts.push(p);
        });
        if (len > 65535) {
          throw new Error('ApduCommand buffer is too long');
        } else if (len > 255) {
          parts[1] = new Buffer([0, len >> 8, len & 0xFF]);
        } else {
          parts[1] = new Buffer([len]);
        }
      }

      if (this.le !== null) {
        if (this.le > 65535) {
          throw new Error('Le value must be between 0 and 65535');
        } else if (this.le <= 256) {
          parts.push(new Buffer([this.le & 0xFF]));
        } else {
          if (parts.length === 1) {
            // In this case (case 2E from http://www.cardwerk.com/smartcards/smartcard_standard_ISO7816-4_5_basic_organizations.aspx#table4), we need a 0 byte for Lc
            parts.push(new Buffer([0]));
          }
          parts.push(new Buffer([this.le >> 8, this.le & 0xFF]));
        }
      }
      return Buffer.concat(parts);
    }
  }, {
    key: 'toString',
    value: function toString() {
      var parts = ['ApduCommand class 0x', this.commandClass.toString(16), ', instruction 0x', this.instruction.toString(16), ', P1 0x', this.p1.toString(16), ', P2 0x', this.p2.toString(16), '\n'];
      if (this.data && this.data.length) {
        var buf = Buffer.concat(this.data);
        parts.push(buf.length + ' bytes: ' + buf.toString('hex'));
      }
      return parts.join('');
    }
  }, {
    key: 'commandClass',
    get: function get() {
      return this.preamble[0];
    },
    set: function set(value) {
      this.preamble.writeUInt8(value, 0);
    }
  }, {
    key: 'instruction',
    get: function get() {
      return this.preamble[1];
    },
    set: function set(value) {
      this.preamble.writeUInt8(value, 1);
    }
  }, {
    key: 'p1',
    get: function get() {
      return this.preamble[2];
    },
    set: function set(value) {
      this.preamble.writeUInt8(value, 2);
    }
  }, {
    key: 'p2',
    get: function get() {
      return this.preamble[3];
    },
    set: function set(value) {
      this.preamble.writeUInt8(value, 3);
    }
  }]);

  return ApduCommand;
}();

exports.default = ApduCommand;
}).call(this,require("buffer").Buffer)
},{"buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/apdu/Response.js":[function(require,module,exports){
(function (Buffer){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ber = require('../ber');

var _ber2 = _interopRequireDefault(_ber);

var _TlvList = require('../TlvList');

var _TlvList2 = _interopRequireDefault(_TlvList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * An APDU response. The truth is this is a nonstandard implementation because we
 * assume the first byte is a "template identifier" as it is in Miura APDU responses,
 * and the rest of the payload is a tlv list. If you don't want that, just pad the
 * buffer with an extra byte at the beginning...
 */

var ApduResponse = function () {
  function ApduResponse(buffer) {
    var start = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
    var length = arguments.length <= 2 || arguments[2] === undefined ? buffer.length - start : arguments[2];
    var isRaw = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

    _classCallCheck(this, ApduResponse);

    if (Buffer.isBuffer(buffer)) {
      this.sw1 = buffer[start + length - 2];
      this.sw2 = buffer[start + length - 1];
      if (length === 2) {
        // Only a success value.
        return;
      }
      if (isRaw) {
        this.data = buffer.slice(start, start + length - 2);
      } else {
        this.template = buffer[start];
        var lenInfo = _ber2.default.readLength(buffer, start + 1);

        if (lenInfo.lengthValue !== length - 3 - lenInfo.lengthOfEncoding) {
          var buflen = length - 3 - lenInfo.lengthOfEncoding;
          var msg = 'Invalid ApduResponse length ' + lenInfo.lengthValue + ' vs buffer length ' + buflen;
          throw new Error(msg);
        }
        this.data = buffer.slice(start + 1 + lenInfo.lengthOfEncoding, start + length - 2);
      }
    } else if (buffer instanceof _TlvList2.default) {
      this._tlvs = buffer;
      this.data = buffer.toBytes();
      this.sw1 = 0x90;
      this.sw2 = 0;
    } else {
      // TODO create a blank response that can be added to
      throw new Error('You must provide a Buffer or TlvList to create an APDU response.');
    }
  }

  _createClass(ApduResponse, [{
    key: 'toString',
    value: function toString(shouldParse) {
      var parts = [];
      if (this.template) {
        parts.push('Template: 0x' + this.template.toString(16));
      }
      if (this.data) {
        parts.push('Data (' + this.data.length + ' bytes): 0x' + this.data.toString('hex'));
      }
      if (this._tlvs || shouldParse && this.tlvs) {
        parts.push(this.tlvs.toString(shouldParse));
      }
      parts.push('SW1: 0x' + this.sw1.toString(16) + ' SW2: 0x' + this.sw2.toString(16));
      return parts.join('\n');
    }
  }, {
    key: 'isSuccess',
    get: function get() {
      return this.sw1 === 0x90 && this.sw2 === 0;
    }
  }, {
    key: 'tlvs',
    get: function get() {
      if (!this._tlvs) {
        this._tlvs = new _TlvList2.default(this.data);
      }
      return this._tlvs;
    }
  }]);

  return ApduResponse;
}();

exports.default = ApduResponse;
}).call(this,{"isBuffer":require("../../../../is-buffer/index.js")})
},{"../../../../is-buffer/index.js":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/is-buffer/index.js","../TlvList":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/TlvList.js","../ber":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/ber.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/tlvlib/build/lib/ber.js":[function(require,module,exports){
(function (Buffer){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  /**
   * Read a tag from a buffer, including multi-byte tags
   * @param {Buffer} buffer The source buffer
   * @param startPosition The position at which to start reading the tag
   * @returns {{length: number, tag: Tag, rawTag: number}}
   */
  readTag: function readTag(buffer, startPosition) {
    var tag = {
      length: 1,
      number: 0
    };
    for (var index = startPosition; index < buffer.length; index++, tag.length++) {
      var t = buffer[index] & 0xff;
      tag.number = (tag.number << 8) + t;
      if (index === startPosition && (t & 0x1F) !== 0x1F) {
        break;
      } else if (index !== startPosition && (t & 0x80) === 0) {
        break;
      }
    }
    return tag;
  },

  /**
   * Return a binary representation of the tag
   * @param tagNumber either a numeric tag value or a DefinedTag object
   */
  encodeTag: function encodeTag(tag) {
    var tagNumber = tag.number || tag;
    var flipped = 0;
    var len = 0;
    while (tagNumber > 0) {
      len++;
      flipped = (flipped << 8) + (tagNumber & 0xFF);
      tagNumber = tagNumber >> 8;
    }
    var buf = new Buffer(len);
    var ix = 0;
    while (flipped > 0) {
      buf.writeUInt8(flipped & 0xFF, ix++);
      flipped = flipped >> 8;
    }
    return buf;
  },

  /**
   * Read a length value and return the value with the number of bytes used to encode
   * the value.
   * @param buffer
   * @param startPosition
   * @returns {{lengthOfEncoding: number, lengthValue: number}}
   */
  readLength: function readLength(buffer, startPosition) {
    var lenInfo = {
      lengthOfEncoding: 1,
      lengthValue: 0
    };
    var curPosition = startPosition;
    var first = buffer[curPosition++];
    if ((first & 0x80) === 0x80) {
      // Long form encoding
      var bytesOfLen = first & 0x7F;
      if (curPosition + bytesOfLen > buffer.length) {
        throw new Error('Malformed length value - not enough bytes.');
      }
      lenInfo.lengthOfEncoding = bytesOfLen + 1;
      for (var j = 0; j < bytesOfLen; j++) {
        lenInfo.lengthValue = (lenInfo.lengthValue << 8) + buffer[curPosition++];
      }
      if (lenInfo.lengthValue < 0) {
        throw new Error('Overflow in length value.');
      }
    } else {
      lenInfo.lengthValue = first;
    }
    return lenInfo;
  },

  /**
   * Return a binary representation of a length value
   * @param len
   * @returns {Buffer} buffer
   */
  encodeLength: function encodeLength(len) {
    if (len > 65535) {
      throw new Error('Invalid length for tlv format: ' + len);
    }
    var buf = void 0;
    if (len <= 127) {
      buf = new Buffer(1);
      buf.writeUInt8(len, 0);
    } else if (len > 0xFF) {
      // Three bytes total
      buf = new Buffer(3);
      buf.writeUInt8(0x82, 0);
      buf.writeUInt8(len >> 8 & 0xFF, 1);
      buf.writeUInt8(len & 0xFF, 2);
    } else {
      // Two bytes
      buf = new Buffer(2);
      buf.writeUInt8(0x81, 0);
      buf.writeUInt8(len & 0xFF, 1);
    }
    return buf;
  }
};
}).call(this,require("buffer").Buffer)
},{"buffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/buffer/index.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/util/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/util/util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/util/support/isBufferBrowser.js","_process":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/process/browser.js","inherits":"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/util/node_modules/inherits/inherits_browser.js"}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/node_modules/yaku/lib/yaku.js":[function(require,module,exports){
(function (global){
/*
 Yaku v0.13.8
 (c) 2015 Yad Smood. http://ysmood.org
 License MIT
*/
(function () {
    "use strict";

    var $undefined
    , $null = null
    , root = typeof global === "object" ? global : window
    , isLongStackTrace = false
    , process = root.process
    , Arr = Array
    , Err = Error

    , $rejected = 0
    , $resolved = 1
    , $pending = 2

    , $Symbol = "Symbol"
    , $iterator = "iterator"
    , $return = "return"

    , $unhandled = "_uh"
    , $promiseTrace = "_pt"
    , $settlerTrace = "_st"

    , $invalidThis = "Invalid this"
    , $invalidArgument = "Invalid argument"
    , $fromPrevious = "\nFrom previous "
    , $promiseCircularChain = "Chaining cycle detected for promise"
    , $unhandledRejectionMsg = "Uncaught (in promise)"
    , $rejectionHandled = "rejectionHandled"
    , $unhandledRejection = "unhandledRejection"

    , $tryCatchFn
    , $tryCatchThis
    , $tryErr = { e: $null }
    , $noop = function () {}
    ;

    /**
     * This class follows the [Promises/A+](https://promisesaplus.com) and
     * [ES6](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects) spec
     * with some extra helpers.
     * @param  {Function} executor Function object with two arguments resolve, reject.
     * The first argument fulfills the promise, the second argument rejects it.
     * We can call these functions, once our operation is completed.
     */
    var Yaku = module.exports = function Promise (executor) {
        var self = this,
            err;

        // "this._s" is the internal state of: pending, resolved or rejected
        // "this._v" is the internal value

        if (!isObject(self) || self._s !== $undefined)
            throw genTypeError($invalidThis);

        self._s = $pending;

        if (isLongStackTrace) self[$promiseTrace] = genTraceInfo();

        if (executor !== $noop) {
            if (!isFunction(executor))
                throw genTypeError($invalidArgument);

            err = genTryCatcher(executor)(
                genSettler(self, $resolved),
                genSettler(self, $rejected)
            );

            if (err === $tryErr)
                settlePromise(self, $rejected, err.e);
        }
    };

    Yaku["default"] = Yaku;

    extendPrototype(Yaku, {
        /**
         * Appends fulfillment and rejection handlers to the promise,
         * and returns a new promise resolving to the return value of the called handler.
         * @param  {Function} onFulfilled Optional. Called when the Promise is resolved.
         * @param  {Function} onRejected  Optional. Called when the Promise is rejected.
         * @return {Yaku} It will return a new Yaku which will resolve or reject after
         * @example
         * the current Promise.
         * ```js
         * var Promise = require('yaku');
         * var p = Promise.resolve(10);
         *
         * p.then((v) => {
         *     console.log(v);
         * });
         * ```
         */
        then: function then (onFulfilled, onRejected) {
            return addHandler(
                this,
                newCapablePromise(Yaku.speciesConstructor(this, Yaku)),
                onFulfilled,
                onRejected
            );
        },

        /**
         * The `catch()` method returns a Promise and deals with rejected cases only.
         * It behaves the same as calling `Promise.prototype.then(undefined, onRejected)`.
         * @param  {Function} onRejected A Function called when the Promise is rejected.
         * This function has one argument, the rejection reason.
         * @return {Yaku} A Promise that deals with rejected cases only.
         * @example
         * ```js
         * var Promise = require('yaku');
         * var p = Promise.reject(new Error("ERR"));
         *
         * p['catch']((v) => {
         *     console.log(v);
         * });
         * ```
         */
        "catch": function (onRejected) {
            return this.then($undefined, onRejected);
        },

        // The number of current promises that attach to this Yaku instance.
        _pCount: 0,

        // The parent Yaku.
        _pre: $null,

        // A unique type flag, it helps different versions of Yaku know each other.
        _Yaku: 1
    });

    /**
     * The `Promise.resolve(value)` method returns a Promise object that is resolved with the given value.
     * If the value is a thenable (i.e. has a then method), the returned promise will "follow" that thenable,
     * adopting its eventual state; otherwise the returned promise will be fulfilled with the value.
     * @param  {Any} value Argument to be resolved by this Promise.
     * Can also be a Promise or a thenable to resolve.
     * @return {Yaku}
     * @example
     * ```js
     * var Promise = require('yaku');
     * var p = Promise.resolve(10);
     * ```
     */
    Yaku.resolve = function resolve (val) {
        return isYaku(val) ? val : settleWithX(newCapablePromise(this), val);
    };

    /**
     * The `Promise.reject(reason)` method returns a Promise object that is rejected with the given reason.
     * @param  {Any} reason Reason why this Promise rejected.
     * @return {Yaku}
     * @example
     * ```js
     * var Promise = require('yaku');
     * var p = Promise.reject(new Error("ERR"));
     * ```
     */
    Yaku.reject = function reject (reason) {
        return settlePromise(newCapablePromise(this), $rejected, reason);
    };

    /**
     * The `Promise.race(iterable)` method returns a promise that resolves or rejects
     * as soon as one of the promises in the iterable resolves or rejects,
     * with the value or reason from that promise.
     * @param  {iterable} iterable An iterable object, such as an Array.
     * @return {Yaku} The race function returns a Promise that is settled
     * the same way as the first passed promise to settle.
     * It resolves or rejects, whichever happens first.
     * @example
     * ```js
     * var Promise = require('yaku');
     * Promise.race([
     *     123,
     *     Promise.resolve(0)
     * ])
     * .then((value) => {
     *     console.log(value); // => 123
     * });
     * ```
     */
    Yaku.race = function race (iterable) {
        var self = this
        , p = newCapablePromise(self)

        , resolve = function (val) {
            settlePromise(p, $resolved, val);
        }

        , reject = function (val) {
            settlePromise(p, $rejected, val);
        }

        , ret = genTryCatcher(each)(iterable, function (v) {
            self.resolve(v).then(resolve, reject);
        });

        if (ret === $tryErr) return self.reject(ret.e);

        return p;
    };

    /**
     * The `Promise.all(iterable)` method returns a promise that resolves when
     * all of the promises in the iterable argument have resolved.
     *
     * The result is passed as an array of values from all the promises.
     * If something passed in the iterable array is not a promise,
     * it's converted to one by Promise.resolve. If any of the passed in promises rejects,
     * the all Promise immediately rejects with the value of the promise that rejected,
     * discarding all the other promises whether or not they have resolved.
     * @param  {iterable} iterable An iterable object, such as an Array.
     * @return {Yaku}
     * @example
     * ```js
     * var Promise = require('yaku');
     * Promise.all([
     *     123,
     *     Promise.resolve(0)
     * ])
     * .then((values) => {
     *     console.log(values); // => [123, 0]
     * });
     * ```
     * @example
     * Use with iterable.
     * ```js
     * var Promise = require('yaku');
     * Promise.all((function * () {
     *     yield 10;
     *     yield new Promise(function (r) { setTimeout(r, 1000, "OK") });
     * })())
     * .then((values) => {
     *     console.log(values); // => [123, 0]
     * });
     * ```
     */
    Yaku.all = function all (iterable) {
        var self = this
        , p1 = newCapablePromise(self)
        , res = []
        , ret
        ;

        function reject (reason) {
            settlePromise(p1, $rejected, reason);
        }

        ret = genTryCatcher(each)(iterable, function (item, i) {
            self.resolve(item).then(function (value) {
                res[i] = value;
                if (!--ret) settlePromise(p1, $resolved, res);
            }, reject);
        });

        if (ret === $tryErr) return self.reject(ret.e);

        if (!ret) settlePromise(p1, $resolved, []);

        return p1;
    };

    /**
     * The ES6 Symbol object that Yaku should use, by default it will use the
     * global one.
     * @type {Object}
     * @example
     * ```js
     * var core = require("core-js/library");
     * var Promise = require("yaku");
     * Promise.Symbol = core.Symbol;
     * ```
     */
    Yaku.Symbol = root[$Symbol] || {};

    /**
     * Use this api to custom the species behavior.
     * https://tc39.github.io/ecma262/#sec-speciesconstructor
     * @param {Any} O The current this object.
     * @param {Function} defaultConstructor
     */
    Yaku.speciesConstructor = function (O, D) {
        var C = O.constructor;

        return C ? (C[Yaku[$Symbol].species] || C) : D;
    };

    /**
     * Catch all possibly unhandled rejections. If you want to use specific
     * format to display the error stack, overwrite it.
     * If it is set, auto `console.error` unhandled rejection will be disabled.
     * @param {Any} reason The rejection reason.
     * @param {Yaku} p The promise that was rejected.
     * @example
     * ```js
     * var Promise = require('yaku');
     * Promise.onUnhandledRejection = (reason) => {
     *     console.error(reason);
     * };
     *
     * // The console will log an unhandled rejection error message.
     * Promise.reject('my reason');
     *
     * // The below won't log the unhandled rejection error message.
     * Promise.reject('v').catch(() => {});
     * ```
     */
    Yaku.unhandledRejection = function (reason, p) {
        var con = root.console;
        if (con) {
            con.error($unhandledRejectionMsg, genStackInfo(reason, p));
        }
    };

    /**
     * Emitted whenever a Promise was rejected and an error handler was
     * attached to it (for example with .catch()) later than after an event loop turn.
     * @param {Any} reason The rejection reason.
     * @param {Yaku} p The promise that was rejected.
     */
    Yaku.rejectionHandled = $noop;

    /**
     * It is used to enable the long stack trace.
     * Once it is enabled, it can't be reverted.
     * While it is very helpful in development and testing environments,
     * it is not recommended to use it in production. It will slow down your
     * application and waste your memory.
     * @example
     * ```js
     * var Promise = require('yaku');
     * Promise.enableLongStackTrace();
     * ```
     */
    Yaku.enableLongStackTrace = function () {
        isLongStackTrace = true;
    };

    /**
     * Only Node has `process.nextTick` function. For browser there are
     * so many ways to polyfill it. Yaku won't do it for you, instead you
     * can choose what you prefer. For example, this project
     * [setImmediate](https://github.com/YuzuJS/setImmediate).
     * By default, Yaku will use `process.nextTick` on Node, `setTimeout` on browser.
     * @type {Function}
     * @example
     * ```js
     * var Promise = require('yaku');
     * Promise.nextTick = fn => window.setImmediate(fn);
     * ```
     * @example
     * You can even use sync resolution if you really know what you are doing.
     * ```js
     * var Promise = require('yaku');
     * Promise.nextTick = fn => fn();
     * ```
     */
    Yaku.nextTick = process ?
        process.nextTick :
        function (fn) { setTimeout(fn); };

    // ********************** Private **********************

    Yaku._Yaku = 1;

    /**
     * All static variable name will begin with `$`. Such as `$rejected`.
     * @private
     */

    // ******************************* Utils ********************************

    function extendPrototype (src, target) {
        for (var k in target) {
            src.prototype[k] = target[k];
        }
        return src;
    }

    function isObject (obj) {
        return typeof obj === "object";
    }

    function isFunction (obj) {
        return typeof obj === "function";
    }

    function isInstanceOf (a, b) {
        return a instanceof b;
    }

    function isError (obj) {
        return isInstanceOf(obj, Err);
    }

    function ensureType (obj, fn, msg) {
        if (!fn(obj)) throw genTypeError(msg);
    }

    /**
     * Wrap a function into a try-catch.
     * @private
     * @return {Any | $tryErr}
     */
    function tryCatcher () {
        try {
            return $tryCatchFn.apply($tryCatchThis, arguments);
        } catch (e) {
            $tryErr.e = e;
            return $tryErr;
        }
    }

    /**
     * Generate a try-catch wrapped function.
     * @private
     * @param  {Function} fn
     * @return {Function}
     */
    function genTryCatcher (fn, self) {
        $tryCatchFn = fn;
        $tryCatchThis = self;
        return tryCatcher;
    }

    /**
     * Generate a scheduler.
     * @private
     * @param  {Integer}  initQueueSize
     * @param  {Function} fn `(Yaku, Value) ->` The schedule handler.
     * @return {Function} `(Yaku, Value) ->` The scheduler.
     */
    function genScheduler (initQueueSize, fn) {
        /**
         * All async promise will be scheduled in
         * here, so that they can be execute on the next tick.
         * @private
         */
        var fnQueue = Arr(initQueueSize)
        , fnQueueLen = 0;

        /**
         * Run all queued functions.
         * @private
         */
        function flush () {
            var i = 0;
            while (i < fnQueueLen) {
                fn(fnQueue[i], fnQueue[i + 1]);
                fnQueue[i++] = $undefined;
                fnQueue[i++] = $undefined;
            }

            fnQueueLen = 0;
            if (fnQueue.length > initQueueSize) fnQueue.length = initQueueSize;
        }

        return function (v, arg) {
            fnQueue[fnQueueLen++] = v;
            fnQueue[fnQueueLen++] = arg;

            if (fnQueueLen === 2) Yaku.nextTick(flush);
        };
    }

    /**
     * Generate a iterator
     * @param  {Any} obj
     * @private
     * @return {Object || TypeError}
     */
    function each (iterable, fn) {
        var len
        , i = 0
        , iter
        , item
        , ret
        ;

        if (!iterable) throw genTypeError($invalidArgument);

        var gen = iterable[Yaku[$Symbol][$iterator]];
        if (isFunction(gen))
            iter = gen.call(iterable);
        else if (isFunction(iterable.next))
            iter = iterable;
        else if (isInstanceOf(iterable, Arr)) {
            len = iterable.length;
            while (i < len) {
                fn(iterable[i], i++);
            }
            return i;
        } else
            throw genTypeError($invalidArgument);

        while (!(item = iter.next()).done) {
            ret = genTryCatcher(fn)(item.value, i++);
            if (ret === $tryErr) {
                if (isFunction(iter[$return])) iter[$return]();
                throw ret.e;
            }
        }

        return i;
    }

    /**
     * Generate type error object.
     * @private
     * @param  {String} msg
     * @return {TypeError}
     */
    function genTypeError (msg) {
        return new TypeError(msg);
    }

    function genTraceInfo (noTitle) {
        return (noTitle ? "" : $fromPrevious) + (new Err().stack || "");
    }


    // *************************** Promise Helpers ****************************

    /**
     * Resolve the value returned by onFulfilled or onRejected.
     * @private
     * @param {Yaku} p1
     * @param {Yaku} p2
     */
    var scheduleHandler = genScheduler(999, function (p1, p2) {
        var x, handler;

        // 2.2.2
        // 2.2.3
        handler = p1._s ? p2._onFulfilled : p2._onRejected;

        // 2.2.7.3
        // 2.2.7.4
        if (handler === $undefined) {
            settlePromise(p2, p1._s, p1._v);
            return;
        }

        // 2.2.7.1
        x = genTryCatcher(callHanler)(handler, p1._v);
        if (x === $tryErr) {
            // 2.2.7.2
            settlePromise(p2, $rejected, x.e);
            return;
        }

        settleWithX(p2, x);
    });

    var scheduleUnhandledRejection = genScheduler(9, function (p) {
        if (!hashOnRejected(p)) {
            p[$unhandled] = 1;
            emitEvent($unhandledRejection, p);
        }
    });

    function emitEvent (name, p) {
        var browserEventName = "on" + name.toLowerCase()
            , browserHandler = root[browserEventName];

        if (process && process.listeners(name).length)
            name === $unhandledRejection ?
                process.emit(name, p._v, p) : process.emit(name, p);
        else if (browserHandler)
            browserHandler({ reason: p._v, promise: p });
        else
            Yaku[name](p._v, p);
    }

    function isYaku (val) { return val && val._Yaku; }

    function newCapablePromise (Constructor) {
        if (isYaku(Constructor)) return new Constructor($noop);

        var p, r, j;
        p = new Constructor(function (resolve, reject) {
            if (p) throw genTypeError();

            r = resolve;
            j = reject;
        });

        ensureType(r, isFunction);
        ensureType(j, isFunction);

        return p;
    }

    /**
     * It will produce a settlePromise function to user.
     * Such as the resolve and reject in this `new Yaku (resolve, reject) ->`.
     * @private
     * @param  {Yaku} self
     * @param  {Integer} state The value is one of `$pending`, `$resolved` or `$rejected`.
     * @return {Function} `(value) -> undefined` A resolve or reject function.
     */
    function genSettler (self, state) {
        return function (value) {
            if (isLongStackTrace)
                self[$settlerTrace] = genTraceInfo(true);

            if (state === $resolved)
                settleWithX(self, value);
            else
                settlePromise(self, state, value);
        };
    }

    /**
     * Link the promise1 to the promise2.
     * @private
     * @param {Yaku} p1
     * @param {Yaku} p2
     * @param {Function} onFulfilled
     * @param {Function} onRejected
     */
    function addHandler (p1, p2, onFulfilled, onRejected) {
        // 2.2.1
        if (isFunction(onFulfilled))
            p2._onFulfilled = onFulfilled;
        if (isFunction(onRejected)) {
            if (p1[$unhandled]) emitEvent($rejectionHandled, p1);

            p2._onRejected = onRejected;
        }

        if (isLongStackTrace) p2._pre = p1;
        p1[p1._pCount++] = p2;

        // 2.2.6
        if (p1._s !== $pending)
            scheduleHandler(p1, p2);

        // 2.2.7
        return p2;
    }

    // iterate tree
    function hashOnRejected (node) {
        // A node shouldn't be checked twice.
        if (node._umark)
            return true;
        else
            node._umark = true;

        var i = 0
        , len = node._pCount
        , child;

        while (i < len) {
            child = node[i++];
            if (child._onRejected || hashOnRejected(child)) return true;
        }
    }

    function genStackInfo (reason, p) {
        var stackInfo = [];

        function trim (str) { return str.replace(/^\s+|\s+$/g, ""); }

        function push (trace) {
            return stackInfo.push(trim(trace));
        }

        if (isLongStackTrace && p[$promiseTrace]) {
            if (p[$settlerTrace])
                push(p[$settlerTrace]);

            // Hope you guys could understand how the back trace works.
            // We only have to iterate through the tree from the bottom to root.
            (function iter (node) {
                if (node) {
                    iter(node._next);
                    push(node[$promiseTrace]);
                    iter(node._pre);
                }
            })(p);
        }

        return (isError(reason) ? reason.stack : reason)
            + ("\n" + stackInfo.join("\n")).replace(/^.+\/node_modules\/yaku\/.+\n?/mg, "");
    }

    function callHanler (handler, value) {
        // 2.2.5
        return handler(value);
    }

    /**
     * Resolve or reject a promise.
     * @private
     * @param  {Yaku} p
     * @param  {Integer} state
     * @param  {Any} value
     */
    function settlePromise (p, state, value) {
        var i = 0
        , len = p._pCount
        , p2;

        // 2.1.2
        // 2.1.3
        if (p._s === $pending) {
            // 2.1.1.1
            p._s = state;
            p._v = value;

            if (state === $rejected) {
                if (isLongStackTrace && isError(value)) {
                    value.longStack = genStackInfo(value, p);
                }

                scheduleUnhandledRejection(p);
            }

            // 2.2.4
            while (i < len) {
                p2 = p[i++];

                if (p2._s !== $pending) continue;

                scheduleHandler(p, p2);
            }
        }

        return p;
    }

    /**
     * Resolve or reject promise with value x. The x can also be a thenable.
     * @private
     * @param {Yaku} p
     * @param {Any | Thenable} x A normal value or a thenable.
     */
    function settleWithX (p, x) {
        // 2.3.1
        if (x === p && x) {
            settlePromise(p, $rejected, genTypeError($promiseCircularChain));
            return p;
        }

        // 2.3.2
        // 2.3.3
        if (x !== $null && (isFunction(x) || isObject(x))) {
            // 2.3.2.1
            var xthen = genTryCatcher(getThen)(x);

            if (xthen === $tryErr) {
                // 2.3.3.2
                settlePromise(p, $rejected, xthen.e);
                return p;
            }

            if (isFunction(xthen)) {
                if (isLongStackTrace && isYaku(x))
                    p._next = x;

                // Fix https://bugs.chromium.org/p/v8/issues/detail?id=4162
                if (isYaku(x))
                    settleXthen(p, x, xthen);
                else
                    Yaku.nextTick(function () {
                        settleXthen(p, x, xthen);
                    });
            } else
                // 2.3.3.4
                settlePromise(p, $resolved, x);
        } else
            // 2.3.4
            settlePromise(p, $resolved, x);

        return p;
    }

    /**
     * Try to get a promise's then method.
     * @private
     * @param  {Thenable} x
     * @return {Function}
     */
    function getThen (x) { return x.then; }

    /**
     * Resolve then with its promise.
     * @private
     * @param  {Yaku} p
     * @param  {Thenable} x
     * @param  {Function} xthen
     */
    function settleXthen (p, x, xthen) {
        // 2.3.3.3
        var err = genTryCatcher(xthen, x)(function (y) {
            // 2.3.3.3.3
            if (x) {
                x = $null;

                // 2.3.3.3.1
                settleWithX(p, y);
            }
        }, function (r) {
            // 2.3.3.3.3
            if (x) {
                x = $null;

                // 2.3.3.3.2
                settlePromise(p, $rejected, r);
            }
        });

        // 2.3.3.3.4.1
        if (err === $tryErr && x) {
            // 2.3.3.3.4.2
            settlePromise(p, $rejected, err.e);
            x = $null;
        }
    }

})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/Users/schandrashekar/Documents/Workspace/retail-sdk-2/resources/feature-map.json":[function(require,module,exports){
module.exports={
  "VERSION":"1.0",
  "US":{
    "MCC_CODES":{
      "4121":"*",
      "5812":"*",
      "5813":"*",
      "5814":"*",
      "7230":"*",
      "7298":"*",
      "4411":"*",
      "7519":"*",
      "7011":"*",
      "7512":"*"
    },
    "CONTACTLESS_LIMIT":"10000"
  },
  "GB":{
    "CONTACTLESS_LIMIT":"20"
  },
  "AU":{
    "CONTACTLESS_LIMIT":"*"
  }
}
},{}]},{},["/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/debug.js","/Users/schandrashekar/Documents/Workspace/retail-sdk-2/js/index.js"]);
